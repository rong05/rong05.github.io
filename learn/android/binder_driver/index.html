<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LEAN</title>
<meta name="keywords" content="">
<meta name="description" content="Binder Driver探索 binder驱动的初始化 在binder.c中有以下一行代码；
device_initcall(binder_init); 在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它可以将驱动设备加载进内核中，以供后续使用。
在Android8.0之后，现在Binder驱动有三个：/dev/binder; /dev/hwbinder; /dev/vndbinder.
static int __init binder_init(void) { int ret; char *device_name, *device_tmp; struct binder_device *device; struct hlist_node *tmp; char *device_names = NULL; //初始化binder缓冲区分配 ret = binder_alloc_shrinker_init(); if (ret) return ret; // ~0U：无符号整型，对0取反。 atomic_set(&amp;binder_transaction_log.cur, ~0U); atomic_set(&amp;binder_transaction_log_failed.cur, ~0U); // 创建/sys/kernel/debug/binder目录。 binder_debugfs_dir_entry_root = debugfs_create_dir(&#34;binder&#34;, NULL); // 创建/sys/kernel/debug/binder/proc目录用于记录每个进程基本信息。 if (binder_debugfs_dir_entry_root) binder_debugfs_dir_entry_proc = debugfs_create_dir(&#34;proc&#34;, binder_debugfs_dir_entry_root); if (binder_debugfs_dir_entry_root) { // 创建/sys/kernel/debug/binder/state文件用于记录状态信息， //并注册操作函数binder_state_fops。 debugfs_create_file(&#34;state&#34;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops); // 创建/sys/kernel/debug/binder/stats文件用于记录统计信息， //并注册操作函数binder_stats_fops。 debugfs_create_file(&#34;stats&#34;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_stats_fops); // 创建/sys/kernel/debug/binder/transactions文件用于记录transaction相关信息， //并注册操作函数binder_transactions_fops。 debugfs_create_file(&#34;transactions&#34;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_transactions_fops); // 创建/sys/kernel/debug/binder/transaction_log文件用于记录transaction日志相关信息， //并注册操作函数binder_transaction_log_fops。 debugfs_create_file(&#34;transaction_log&#34;, 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log, &amp;binder_transaction_log_fops); // 创建/sys/kernel/debug/binder/failed_transaction_log文件用于记录transaction失败日志相关信息， // 并注册操作函数binder_transaction_log_fops debugfs_create_file(&#34;failed_transaction_log&#34;, 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log_failed, &amp;binder_transaction_log_fops); } if (!">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://rong05.github.io/learn/android/binder_driver/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0c4fd3725171366f335155acde6fb3c7b7042cd2fd075bebf5023d9b28a701b2.css" integrity="sha256-DE/TclFxNm8zUVWs3m&#43;zx7cELNL9B1vr9QI9myinAbI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://rong05.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rong05.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rong05.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rong05.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rong05.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://rong05.github.io/learn/android/binder_driver/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="Binder Driver探索 binder驱动的初始化 在binder.c中有以下一行代码；
device_initcall(binder_init); 在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它可以将驱动设备加载进内核中，以供后续使用。
在Android8.0之后，现在Binder驱动有三个：/dev/binder; /dev/hwbinder; /dev/vndbinder.
static int __init binder_init(void) { int ret; char *device_name, *device_tmp; struct binder_device *device; struct hlist_node *tmp; char *device_names = NULL; //初始化binder缓冲区分配 ret = binder_alloc_shrinker_init(); if (ret) return ret; // ~0U：无符号整型，对0取反。 atomic_set(&amp;binder_transaction_log.cur, ~0U); atomic_set(&amp;binder_transaction_log_failed.cur, ~0U); // 创建/sys/kernel/debug/binder目录。 binder_debugfs_dir_entry_root = debugfs_create_dir(&#34;binder&#34;, NULL); // 创建/sys/kernel/debug/binder/proc目录用于记录每个进程基本信息。 if (binder_debugfs_dir_entry_root) binder_debugfs_dir_entry_proc = debugfs_create_dir(&#34;proc&#34;, binder_debugfs_dir_entry_root); if (binder_debugfs_dir_entry_root) { // 创建/sys/kernel/debug/binder/state文件用于记录状态信息， //并注册操作函数binder_state_fops。 debugfs_create_file(&#34;state&#34;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops); // 创建/sys/kernel/debug/binder/stats文件用于记录统计信息， //并注册操作函数binder_stats_fops。 debugfs_create_file(&#34;stats&#34;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_stats_fops); // 创建/sys/kernel/debug/binder/transactions文件用于记录transaction相关信息， //并注册操作函数binder_transactions_fops。 debugfs_create_file(&#34;transactions&#34;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_transactions_fops); // 创建/sys/kernel/debug/binder/transaction_log文件用于记录transaction日志相关信息， //并注册操作函数binder_transaction_log_fops。 debugfs_create_file(&#34;transaction_log&#34;, 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log, &amp;binder_transaction_log_fops); // 创建/sys/kernel/debug/binder/failed_transaction_log文件用于记录transaction失败日志相关信息， // 并注册操作函数binder_transaction_log_fops debugfs_create_file(&#34;failed_transaction_log&#34;, 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log_failed, &amp;binder_transaction_log_fops); } if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rong05.github.io/learn/android/binder_driver/" /><meta property="og:image" content="https://rong05.github.io/papermod-cover.png"/><meta property="article:section" content="learn" />



<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://rong05.github.io/papermod-cover.png"/>

<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Binder Driver探索 binder驱动的初始化 在binder.c中有以下一行代码；
device_initcall(binder_init); 在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它可以将驱动设备加载进内核中，以供后续使用。
在Android8.0之后，现在Binder驱动有三个：/dev/binder; /dev/hwbinder; /dev/vndbinder.
static int __init binder_init(void) { int ret; char *device_name, *device_tmp; struct binder_device *device; struct hlist_node *tmp; char *device_names = NULL; //初始化binder缓冲区分配 ret = binder_alloc_shrinker_init(); if (ret) return ret; // ~0U：无符号整型，对0取反。 atomic_set(&amp;binder_transaction_log.cur, ~0U); atomic_set(&amp;binder_transaction_log_failed.cur, ~0U); // 创建/sys/kernel/debug/binder目录。 binder_debugfs_dir_entry_root = debugfs_create_dir(&#34;binder&#34;, NULL); // 创建/sys/kernel/debug/binder/proc目录用于记录每个进程基本信息。 if (binder_debugfs_dir_entry_root) binder_debugfs_dir_entry_proc = debugfs_create_dir(&#34;proc&#34;, binder_debugfs_dir_entry_root); if (binder_debugfs_dir_entry_root) { // 创建/sys/kernel/debug/binder/state文件用于记录状态信息， //并注册操作函数binder_state_fops。 debugfs_create_file(&#34;state&#34;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops); // 创建/sys/kernel/debug/binder/stats文件用于记录统计信息， //并注册操作函数binder_stats_fops。 debugfs_create_file(&#34;stats&#34;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_stats_fops); // 创建/sys/kernel/debug/binder/transactions文件用于记录transaction相关信息， //并注册操作函数binder_transactions_fops。 debugfs_create_file(&#34;transactions&#34;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_transactions_fops); // 创建/sys/kernel/debug/binder/transaction_log文件用于记录transaction日志相关信息， //并注册操作函数binder_transaction_log_fops。 debugfs_create_file(&#34;transaction_log&#34;, 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log, &amp;binder_transaction_log_fops); // 创建/sys/kernel/debug/binder/failed_transaction_log文件用于记录transaction失败日志相关信息， // 并注册操作函数binder_transaction_log_fops debugfs_create_file(&#34;failed_transaction_log&#34;, 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log_failed, &amp;binder_transaction_log_fops); } if (!"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Learns",
      "item": "https://rong05.github.io/learn/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://rong05.github.io/learn/android/binder_driver/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Binder Driver探索 binder驱动的初始化 在binder.c中有以下一行代码；\ndevice_initcall(binder_init); 在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它可以将驱动设备加载进内核中，以供后续使用。\n在Android8.0之后，现在Binder驱动有三个：/dev/binder; /dev/hwbinder; /dev/vndbinder.\nstatic int __init binder_init(void) { int ret; char *device_name, *device_tmp; struct binder_device *device; struct hlist_node *tmp; char *device_names = NULL; //初始化binder缓冲区分配 ret = binder_alloc_shrinker_init(); if (ret) return ret; // ~0U：无符号整型，对0取反。 atomic_set(\u0026amp;binder_transaction_log.cur, ~0U); atomic_set(\u0026amp;binder_transaction_log_failed.cur, ~0U); // 创建/sys/kernel/debug/binder目录。 binder_debugfs_dir_entry_root = debugfs_create_dir(\u0026#34;binder\u0026#34;, NULL); // 创建/sys/kernel/debug/binder/proc目录用于记录每个进程基本信息。 if (binder_debugfs_dir_entry_root) binder_debugfs_dir_entry_proc = debugfs_create_dir(\u0026#34;proc\u0026#34;, binder_debugfs_dir_entry_root); if (binder_debugfs_dir_entry_root) { // 创建/sys/kernel/debug/binder/state文件用于记录状态信息， //并注册操作函数binder_state_fops。 debugfs_create_file(\u0026#34;state\u0026#34;, 0444, binder_debugfs_dir_entry_root, NULL, \u0026amp;binder_state_fops); // 创建/sys/kernel/debug/binder/stats文件用于记录统计信息， //并注册操作函数binder_stats_fops。 debugfs_create_file(\u0026#34;stats\u0026#34;, 0444, binder_debugfs_dir_entry_root, NULL, \u0026amp;binder_stats_fops); // 创建/sys/kernel/debug/binder/transactions文件用于记录transaction相关信息， //并注册操作函数binder_transactions_fops。 debugfs_create_file(\u0026#34;transactions\u0026#34;, 0444, binder_debugfs_dir_entry_root, NULL, \u0026amp;binder_transactions_fops); // 创建/sys/kernel/debug/binder/transaction_log文件用于记录transaction日志相关信息， //并注册操作函数binder_transaction_log_fops。 debugfs_create_file(\u0026#34;transaction_log\u0026#34;, 0444, binder_debugfs_dir_entry_root, \u0026amp;binder_transaction_log, \u0026amp;binder_transaction_log_fops); // 创建/sys/kernel/debug/binder/failed_transaction_log文件用于记录transaction失败日志相关信息， // 并注册操作函数binder_transaction_log_fops debugfs_create_file(\u0026#34;failed_transaction_log\u0026#34;, 0444, binder_debugfs_dir_entry_root, \u0026amp;binder_transaction_log_failed, \u0026amp;binder_transaction_log_fops); } if (!",
  "keywords": [
    
  ],
  "articleBody": "Binder Driver探索 binder驱动的初始化 在binder.c中有以下一行代码；\ndevice_initcall(binder_init); 在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它可以将驱动设备加载进内核中，以供后续使用。\n在Android8.0之后，现在Binder驱动有三个：/dev/binder; /dev/hwbinder; /dev/vndbinder.\nstatic int __init binder_init(void) { int ret; char *device_name, *device_tmp; struct binder_device *device; struct hlist_node *tmp; char *device_names = NULL; //初始化binder缓冲区分配 ret = binder_alloc_shrinker_init(); if (ret) return ret; // ~0U：无符号整型，对0取反。 atomic_set(\u0026binder_transaction_log.cur, ~0U); atomic_set(\u0026binder_transaction_log_failed.cur, ~0U); // 创建/sys/kernel/debug/binder目录。 binder_debugfs_dir_entry_root = debugfs_create_dir(\"binder\", NULL); // 创建/sys/kernel/debug/binder/proc目录用于记录每个进程基本信息。 if (binder_debugfs_dir_entry_root) binder_debugfs_dir_entry_proc = debugfs_create_dir(\"proc\", binder_debugfs_dir_entry_root); if (binder_debugfs_dir_entry_root) { // 创建/sys/kernel/debug/binder/state文件用于记录状态信息， //并注册操作函数binder_state_fops。 debugfs_create_file(\"state\", 0444, binder_debugfs_dir_entry_root, NULL, \u0026binder_state_fops); // 创建/sys/kernel/debug/binder/stats文件用于记录统计信息， //并注册操作函数binder_stats_fops。 debugfs_create_file(\"stats\", 0444, binder_debugfs_dir_entry_root, NULL, \u0026binder_stats_fops); // 创建/sys/kernel/debug/binder/transactions文件用于记录transaction相关信息， //并注册操作函数binder_transactions_fops。 debugfs_create_file(\"transactions\", 0444, binder_debugfs_dir_entry_root, NULL, \u0026binder_transactions_fops); // 创建/sys/kernel/debug/binder/transaction_log文件用于记录transaction日志相关信息， //并注册操作函数binder_transaction_log_fops。 debugfs_create_file(\"transaction_log\", 0444, binder_debugfs_dir_entry_root, \u0026binder_transaction_log, \u0026binder_transaction_log_fops); // 创建/sys/kernel/debug/binder/failed_transaction_log文件用于记录transaction失败日志相关信息， // 并注册操作函数binder_transaction_log_fops debugfs_create_file(\"failed_transaction_log\", 0444, binder_debugfs_dir_entry_root, \u0026binder_transaction_log_failed, \u0026binder_transaction_log_fops); } if (!IS_ENABLED(CONFIG_ANDROID_BINDERFS) \u0026\u0026 strcmp(binder_devices_param, \"\") != 0) { /* * Copy the module_parameter string, because we don't want to * tokenize it in-place. */ // kzalloc：分配不超过128KB的连续的物理内存映射区域。 // GFP_KERNEL：内存分配器flags，无内存可用时可引起休眠，允许启动磁盘IO和文件系统IO。 // binder_devices_param：binder，hwbinder，vndbinder。 device_names = kstrdup(binder_devices_param, GFP_KERNEL); if (!device_names) { ret = -ENOMEM; goto err_alloc_device_names_failed; } // 创建binder设备 device_tmp = device_names; while ((device_name = strsep(\u0026device_tmp, \",\"))) { ret = init_binder_device(device_name); if (ret) goto err_init_binder_device_failed; } } //初始化binder文件系统 ret = init_binderfs(); if (ret) goto err_init_binder_device_failed; return ret; err_init_binder_device_failed: hlist_for_each_entry_safe(device, tmp, \u0026binder_devices, hlist) { misc_deregister(\u0026device-\u003emiscdev); hlist_del(\u0026device-\u003ehlist); kfree(device); } kfree(device_names); err_alloc_device_names_failed: debugfs_remove_recursive(binder_debugfs_dir_entry_root); return ret; } binder_init函数主要内容是：\n初始化binder缓冲区分配 创建了sys/kernel/debug/binder目录，以及其子目录或文件 注册misc设备，创建binder设备 把binder_device加入到全局链表binder_devices进行管理 那来看看init_binder_device是如何注册misc设备，创建binder设备，代码如下：\nstatic int __init init_binder_device(const char *name) { int ret; struct binder_device *binder_device; binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL); if (!binder_device) return -ENOMEM; //miscdevice结构体 binder_device-\u003emiscdev.fops = \u0026binder_fops; //设备的文件操作结构，这是file_operations结构 binder_device-\u003emiscdev.minor = MISC_DYNAMIC_MINOR;//次设备号 动态分配 binder_device-\u003emiscdev.name = name;//设备名 //binder设备的引用计数 refcount_set(\u0026binder_device-\u003eref, 1); //默认binder驱动的上下文管理者 binder_device-\u003econtext.binder_context_mgr_uid = INVALID_UID; binder_device-\u003econtext.name = name; mutex_init(\u0026binder_device-\u003econtext.context_mgr_node_lock); // 注册misc设备 ret = misc_register(\u0026binder_device-\u003emiscdev); if (ret \u003c 0) { kfree(binder_device); return ret; } // 通过全局链表binder_devices管理binder_device。 hlist_add_head(\u0026binder_device-\u003ehlist, \u0026binder_devices); return ret; } 从init_binder_device函数看出binder驱动设备节点是通过binder_device结构体管理的；设置binder_device的miscdev参数，miscdev其实是miscdevice结构体，misc_register函数注册misc设备，miscdevice参数分别是：\n设备的文件操作结构，这是file_operations结构 次设备号 动态分配 设备名 binder_device结构体定义如下：\nstruct binder_device { // 加入binder_devices全局链表的node。 struct hlist_node hlist; // misc设备。 struct miscdevice miscdev; // 获取service manager对应的binder_node。 struct binder_context context; //属于bindfs挂载的超级块的根节点的inode。 struct inode *binderfs_inode; //binder_device的引用计数 refcount_t ref; }; file_operations结构体,指定相应文件操作的方法\nconst struct file_operations binder_fops = { .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = compat_ptr_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release, }; 用户态的程序调用Kernel层驱动是需要陷入内核态，进行系统调用(syscall)，比如打开Binder驱动方法的调用链为： open-\u003e __open() -\u003e binder_open()。通过binder_fops的定义得出以下调用规则；\n图片来源\nbinder_open 之前已经提到每个进程都会单独创建自己的ProcessState，ProcessState是进程唯一的；在ProcessState创建时会调用open函数，那对应调用的就是binder驱动中的binder_open;\nstatic int binder_open(struct inode *nodp, struct file *filp) { struct binder_proc *proc, *itr; struct binder_device *binder_dev; struct binderfs_info *info; struct dentry *binder_binderfs_dir_entry_proc = NULL; bool existing_pid = false; binder_debug(BINDER_DEBUG_OPEN_CLOSE, \"%s: %d:%d\\n\", __func__, current-\u003egroup_leader-\u003epid, current-\u003epid); //创建binder驱动中管理IPC和保存进程信息的根结构体 proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; // 初始化两个自旋锁。 // inner_lock保护线程、binder_node以及所有与进程相关的的todo队列。 // outer_lock保护binder_ref。 spin_lock_init(\u0026proc-\u003einner_lock); spin_lock_init(\u0026proc-\u003eouter_lock); // 获取当前进程组领头进程。 get_task_struct(current-\u003egroup_leader); proc-\u003etsk = current-\u003egroup_leader;//将当前进程的task_struct保存到binder_proc INIT_LIST_HEAD(\u0026proc-\u003etodo);//初始化todo列表 // 判断当前进程的调度策略是否支持，binder只支持SCHED_NORMAL(00b)、SCHED_FIFO(01b)、SCHED_RR(10b)、SCHED_BATCH(11b)。 // prio为进程优先级，可通过normal_prio获取。一般分为实时优先级及静态优先级。 if (binder_supported_policy(current-\u003epolicy)) { proc-\u003edefault_priority.sched_policy = current-\u003epolicy; proc-\u003edefault_priority.prio = current-\u003enormal_prio; } else { proc-\u003edefault_priority.sched_policy = SCHED_NORMAL; proc-\u003edefault_priority.prio = NICE_TO_PRIO(0); } /* binderfs stashes devices in i_private */ // 通过miscdev获取binder_device。 if (is_binderfs_device(nodp)) { binder_dev = nodp-\u003ei_private; info = nodp-\u003ei_sb-\u003es_fs_info; binder_binderfs_dir_entry_proc = info-\u003eproc_log_dir; } else { binder_dev = container_of(filp-\u003eprivate_data, struct binder_device, miscdev); } //binder_device的引用计数加1 refcount_inc(\u0026binder_dev-\u003eref); //初始化对应进程中的binder驱动上下文管理者 proc-\u003econtext = \u0026binder_dev-\u003econtext; // 初始化binder_proc的binder_alloc字段。 binder_alloc_init(\u0026proc-\u003ealloc); // binder驱动维护静态全局数组binder_stats，其中有一个成员数组obj_created。 // 当binder_open调用时，obj_created[BINDER_STAT_PROC]将自增。该数组用来统计binder对象的数量。 binder_stats_created(BINDER_STAT_PROC); //初始化binder_proc的pid为领头进程的pid值。 proc-\u003epid = current-\u003egroup_leader-\u003epid; // 初始化delivered_death及waiting_threads队列。 INIT_LIST_HEAD(\u0026proc-\u003edelivered_death); INIT_LIST_HEAD(\u0026proc-\u003ewaiting_threads); // private_data保存binder_proc对象。 filp-\u003eprivate_data = proc; // 将binder_proc加入到全局队列binder_procs中,该操作必须加锁。 mutex_lock(\u0026binder_procs_lock); hlist_for_each_entry(itr, \u0026binder_procs, proc_node) { if (itr-\u003epid == proc-\u003epid) { existing_pid = true; break; } } hlist_add_head(\u0026proc-\u003eproc_node, \u0026binder_procs); mutex_unlock(\u0026binder_procs_lock); // 若/sys/kernel/binder/proc目录已经创建好，则在该目录下创建一个以pid为名的文件。 if (binder_debugfs_dir_entry_proc \u0026\u0026 !existing_pid) { char strbuf[11]; snprintf(strbuf, sizeof(strbuf), \"%u\", proc-\u003epid); /* * proc debug entries are shared between contexts. * Only create for the first PID to avoid debugfs log spamming * The printing code will anyway print all contexts for a given * PID so this is not a problem. */ // proc调试条目在上下文之间共享，如果进程尝试使用其他上下文再次打开驱动程序，则此操作将失败。 proc-\u003edebugfs_entry = debugfs_create_file(strbuf, 0444, binder_debugfs_dir_entry_proc, (void *)(unsigned long)proc-\u003epid, \u0026proc_fops); } if (binder_binderfs_dir_entry_proc \u0026\u0026 !existing_pid) { char strbuf[11]; struct dentry *binderfs_entry; snprintf(strbuf, sizeof(strbuf), \"%u\", proc-\u003epid); /* * Similar to debugfs, the process specific log file is shared * between contexts. Only create for the first PID. * This is ok since same as debugfs, the log file will contain * information on all contexts of a given PID. */ binderfs_entry = binderfs_create_file(binder_binderfs_dir_entry_proc, strbuf, \u0026proc_fops, (void *)(unsigned long)proc-\u003epid); if (!IS_ERR(binderfs_entry)) { proc-\u003ebinderfs_entry = binderfs_entry; } else { int error; error = PTR_ERR(binderfs_entry); pr_warn(\"Unable to create file %s in binderfs (error %d)\\n\", strbuf, error); } } return 0; } 从binder_open函数的主要工作是创建binder_proc结构体，并把当前进程等信息保存到binder_proc，初始化binder_proc中管理IPC所需的各种信息并创建其它相关的子结构体；再把binder_proc保存到文件指针filp，以及把binder_proc加入到全局链表binder_procs，这一个双向链表结构。\nbinder_procs结构体 struct binder_proc { //加入binder_procs全局链表的node节点。 struct hlist_node proc_node; //记录执行传输动作的线程信息, binder_thread红黑树的根节点 struct rb_root threads; //用于记录binder实体 ,binder_node红黑树的根节点，它是Server在Binder驱动中的体现 struct rb_root nodes; //binder_ref红黑树的根节点(以handle为key struct rb_root refs_by_desc; //binder_ref红黑树的根节点（以ptr为key） struct rb_root refs_by_node; //该binder进程的线程池中等待处理binder_work的binder_thread链表 struct list_head waiting_threads; //相应进程id int pid; //相应进程的task结构体 struct task_struct *tsk; struct hlist_node deferred_work_node; int deferred_work; bool is_dead; //进程将要做的事 struct list_head todo; //binder统计信息 struct binder_stats stats; //已分发的死亡通知 struct list_head delivered_death; //最大线程数 int max_threads; //请求的线程数 int requested_threads; //已启动的请求线程数 int requested_threads_started; int tmp_ref; //默认优先级 struct binder_priority default_priority; struct dentry *debugfs_entry; //进程通信数据内存分配相关 struct binder_alloc alloc; //binder驱动的上下文管理者 struct binder_context *context; spinlock_t inner_lock; spinlock_t outer_lock; struct dentry *binderfs_entry; }; struct binder_alloc { struct mutex mutex; //指向进程虚拟地址空间的指针 struct vm_area_struct *vma; //相应进程的内存结构体 struct mm_struct *vma_vm_mm; // map 的地址就是这里了 void __user *buffer; //所有的buffers列表 struct list_head buffers; //只进行了预定，没有分配，按大小排序 struct rb_root free_buffers; //已经分配了,按地址排序 struct rb_root allocated_buffers; //用于异步请求的空间 size_t free_async_space; //所有的pages指向物理内存页 struct binder_lru_page *pages; //映射的内核空间大小 size_t buffer_size; uint32_t buffer_free; int pid; size_t pages_high; }; binder_mmap 主要功能：\n为用户进程分配一块内核空间作为缓冲区，并把分配的缓冲区指针存放到binder_proc的buffer字段； 分配pages空间，并内核分配一块同样页数的内核空间,并把它的物理内存和前面为用户进程分配的内存地址关联； 分配的内存块加入用户进程内存链表； static int binder_mmap(struct file *filp, struct vm_area_struct *vma) { //private_data保存了我们open设备时创建的binder_proc信息 struct binder_proc *proc = filp-\u003eprivate_data; if (proc-\u003etsk != current-\u003egroup_leader) return -EINVAL; binder_debug(BINDER_DEBUG_OPEN_CLOSE, \"%s: %d %lx-%lx (%ld K) vma %lx pagep %lx\\n\", __func__, proc-\u003epid, vma-\u003evm_start, vma-\u003evm_end, (vma-\u003evm_end - vma-\u003evm_start) / SZ_1K, vma-\u003evm_flags, (unsigned long)pgprot_val(vma-\u003evm_page_prot)); //mmap 的 buffer 禁止用户进行写操作。mmap 只是为了分配内核空间，传递数据通过 ioctl() if (vma-\u003evm_flags \u0026 FORBIDDEN_MMAP_FLAGS) { pr_err(\"%s: %d %lx-%lx %s failed %d\\n\", __func__, proc-\u003epid, vma-\u003evm_start, vma-\u003evm_end, \"bad vm_flags\", -EPERM); return -EPERM; } // 将 VM_DONTCOP 置起，禁止 拷贝，禁止 写操作 vma-\u003evm_flags |= VM_DONTCOPY | VM_MIXEDMAP; vma-\u003evm_flags \u0026= ~VM_MAYWRITE; vma-\u003evm_ops = \u0026binder_vm_ops; vma-\u003evm_private_data = proc; // 再次完善 binder buffer allocator return binder_alloc_mmap_handler(\u0026proc-\u003ealloc, vma); } int binder_alloc_mmap_handler(struct binder_alloc *alloc, struct vm_area_struct *vma) { int ret; const char *failure_string; //每一次Binder传输数据时，都会先从Binder内存缓存区中分配一个binder_buffer来存储传输数据 struct binder_buffer *buffer; //同步锁 mutex_lock(\u0026binder_alloc_mmap_lock); // 不需要重复mmap if (alloc-\u003ebuffer_size) { ret = -EBUSY; failure_string = \"already mapped\"; goto err_already_mapped; } //vma-\u003evm_end, vma-\u003evm_start 指向要 映射的用户空间地址, map size 不允许 大于 4M alloc-\u003ebuffer_size = min_t(unsigned long, vma-\u003evm_end - vma-\u003evm_start, SZ_4M); mutex_unlock(\u0026binder_alloc_mmap_lock); //指向用户进程内核虚拟空间的 start地址 alloc-\u003ebuffer = (void __user *)vma-\u003evm_start; //分配物理页的指针数组，数组大小为vma的等效page个数 alloc-\u003epages = kcalloc(alloc-\u003ebuffer_size / PAGE_SIZE, sizeof(alloc-\u003epages[0]), GFP_KERNEL); if (alloc-\u003epages == NULL) { ret = -ENOMEM; failure_string = \"alloc page array\"; goto err_alloc_pages_failed; } //申请一个binder_buffer的内存 buffer = kzalloc(sizeof(*buffer), GFP_KERNEL); if (!buffer) { ret = -ENOMEM; failure_string = \"alloc buffer struct\"; goto err_alloc_buf_struct_failed; } //指向用户进程内核虚拟空间的 start地址，即为当前进程mmap的内核空间地址 buffer-\u003euser_data = alloc-\u003ebuffer; //将binder_buffer地址，加入到所属进程的buffers队列 list_add(\u0026buffer-\u003eentry, \u0026alloc-\u003ebuffers); buffer-\u003efree = 1; //将当前buffer加入到红黑树alloc-\u003efree_buffers中，表示当前buffer是空闲buffer binder_insert_free_buffer(alloc, buffer); // 将异步事务的空间大小设置为 整个空间的一半 alloc-\u003efree_async_space = alloc-\u003ebuffer_size / 2; binder_alloc_set_vma(alloc, vma); mmgrab(alloc-\u003evma_vm_mm); return 0; err_alloc_buf_struct_failed: kfree(alloc-\u003epages); alloc-\u003epages = NULL; err_alloc_pages_failed: alloc-\u003ebuffer = NULL; mutex_lock(\u0026binder_alloc_mmap_lock); alloc-\u003ebuffer_size = 0; err_already_mapped: mutex_unlock(\u0026binder_alloc_mmap_lock); binder_alloc_debug(BINDER_DEBUG_USER_ERROR, \"%s: %d %lx-%lx %s failed %d\\n\", __func__, alloc-\u003epid, vma-\u003evm_start, vma-\u003evm_end, failure_string, ret); return ret; } static void binder_insert_free_buffer(struct binder_alloc *alloc, struct binder_buffer *new_buffer) { struct rb_node **p = \u0026alloc-\u003efree_buffers.rb_node; struct rb_node *parent = NULL; struct binder_buffer *buffer; size_t buffer_size; size_t new_buffer_size; BUG_ON(!new_buffer-\u003efree); // 通过binder_alloc_buffer_size计算当前new_buffer的大小，之后将用于比较。 new_buffer_size = binder_alloc_buffer_size(alloc, new_buffer); binder_alloc_debug(BINDER_DEBUG_BUFFER_ALLOC, \"%d: add free buffer, size %zd, at %pK\\n\", alloc-\u003epid, new_buffer_size, new_buffer); while (*p) { parent = *p; // 获取当前红黑树节点的buffer。 buffer = rb_entry(parent, struct binder_buffer, rb_node); BUG_ON(!buffer-\u003efree); // 计算当前红黑树节点的buffer大小。 buffer_size = binder_alloc_buffer_size(alloc, buffer); // 红黑树遵循二叉树规则：当新的buffer比当前节点的buffer小时，向左子节点继续重复，否则转向右子节点。 if (new_buffer_size \u003c buffer_size) p = \u0026parent-\u003erb_left; else p = \u0026parent-\u003erb_right; } // 找到合适位置后，将new_buffer插入到该位置。 rb_link_node(\u0026new_buffer-\u003erb_node, parent, p); rb_insert_color(\u0026new_buffer-\u003erb_node, \u0026alloc-\u003efree_buffers); } binder_mmap通过加锁，保证一次只有一个进程分配内存，保证多进程间的并发访问。将分配一块内核空间缓冲区buffer加入到红黑树alloc-\u003efree_buffers中，表示当前buffer是空闲buffer；每一次Binder传输数据时，都会先从Binder内存缓存区中分配一个binder_buffer来存储传输数据。\nbinder_buffer结构体 struct binder_buffer { //buffer实体的地址 struct list_head entry; /* free and allocated entries by address */ struct rb_node rb_node; /* free entry by size or allocated entry */ /* by address */ //标记是否是空闲buffer，占位1bit unsigned free:1; //是否允许用户释放，占位1bit unsigned clear_on_free:1; unsigned allow_user_free:1; unsigned async_transaction:1; unsigned debug_id:28; //该缓存区的需要处理的事务 struct binder_transaction *transaction; //该缓存区所需处理的Binder实体 struct binder_node *target_node; //数据大小 size_t data_size; //数据偏移量 size_t offsets_size; size_t extra_buffers_size; //用户数据 void __user *user_data; int pid; }; struct binder_lru_page { struct list_head lru;//binder_alloc_lru中的条目 struct page *page_ptr;//指向mmap空间中的物理页面的指针 struct binder_alloc *alloc;//proc的binder_alloc }; binder_mmap这里主要映射的内存只允许用户空间读，不允许用户空间写；binder驱动可以读写这块内存；存映射实现一次拷贝的概念是：\n用户空间给binder驱动传入信息时，都需要内存拷贝； binder驱动给发送用户空间则不需要； 物理内存的分配和释放 binder_update_page_range函数主要的作用是分配和释放物理内存；\nbinder_ioctl binder_ioctl()函数负责在两个进程间收发IPC数据和IPC reply数据。\nioctl命令和数据类型是一体的，不同的命令对应不同的数据类型\nioctl命令 数据类型 操作 BINDER_WRITE_READ struct binder_write_read 收发Binder IPC数据 BINDER_SET_MAX_THREADS __u32 设置Binder线程最大个数 BINDER_SET_CONTEXT_MGR __s32 设置Service Manager节点 BINDER_THREAD_EXIT __s32 释放Binder线程 BINDER_VERSION struct binder_version 获取Binder版本信息 BINDER_SET_IDLE_TIMEOUT __s64 没有使用 BINDER_SET_IDLE_PRIORITY __s32 没有使用 这些命令中BINDER_WRITE_READ命令使用率最为频繁，也是ioctl最为核心的命令。\nstatic long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { int ret; //oepn的时候包在filp的private_data struct binder_proc *proc = filp-\u003eprivate_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; /*pr_info(\"binder_ioctl: %d:%d %x %lx\\n\", proc-\u003epid, current-\u003epid, cmd, arg);*/ binder_selftest_alloc(\u0026proc-\u003ealloc); trace_binder_ioctl(cmd, arg); //这里时一个阻塞代码，如果binder_stop_on_user_error 大于2这里会被休眠 //这里先无视即可 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error \u003c 2); if (ret) goto err_unlocked; //获取当前线程对应的结构体，如果没有创建过，那么就创建一个放入到proc的红黑树 thread = binder_get_thread(proc); if (thread == NULL) { ret = -ENOMEM; goto err; } switch (cmd) { case BINDER_WRITE_READ://进行binder的读写操作 ret = binder_ioctl_write_read(filp, cmd, arg, thread); if (ret) goto err; break; case BINDER_SET_MAX_THREADS: {//设置binder最大支持的线程数 int max_threads; if (copy_from_user(\u0026max_threads, ubuf, sizeof(max_threads))) { ret = -EINVAL; goto err; } binder_inner_proc_lock(proc); proc-\u003emax_threads = max_threads; binder_inner_proc_unlock(proc); break; } case BINDER_SET_CONTEXT_MGR_EXT: { //设置Service Manager节点，带flag参数， servicemanager进程成为上下文管理者 struct flat_binder_object fbo; if (copy_from_user(\u0026fbo, ubuf, sizeof(fbo))) { ret = -EINVAL; goto err; } ret = binder_ioctl_set_ctx_mgr(filp, \u0026fbo); if (ret) goto err; break; } case BINDER_SET_CONTEXT_MGR://成为binder的上下文管理者，不带flag参数，也就是ServiceManager成为守护进程 ret = binder_ioctl_set_ctx_mgr(filp, NULL); if (ret) goto err; break; case BINDER_THREAD_EXIT://当binder线程退出，释放binder线程 binder_debug(BINDER_DEBUG_THREADS, \"%d:%d exit\\n\", proc-\u003epid, thread-\u003epid); binder_thread_release(proc, thread); thread = NULL; break; case BINDER_VERSION: {//获取binder的版本号 struct binder_version __user *ver = ubuf; if (size != sizeof(struct binder_version)) { ret = -EINVAL; goto err; } if (put_user(BINDER_CURRENT_PROTOCOL_VERSION, \u0026ver-\u003eprotocol_version)) { ret = -EINVAL; goto err; } break; } case BINDER_GET_NODE_INFO_FOR_REF: { struct binder_node_info_for_ref info; if (copy_from_user(\u0026info, ubuf, sizeof(info))) { ret = -EFAULT; goto err; } ret = binder_ioctl_get_node_info_for_ref(proc, \u0026info); if (ret \u003c 0) goto err; if (copy_to_user(ubuf, \u0026info, sizeof(info))) { ret = -EFAULT; goto err; } break; } case BINDER_GET_NODE_DEBUG_INFO: { struct binder_node_debug_info info; if (copy_from_user(\u0026info, ubuf, sizeof(info))) { ret = -EFAULT; goto err; } ret = binder_ioctl_get_node_debug_info(proc, \u0026info); if (ret \u003c 0) goto err; if (copy_to_user(ubuf, \u0026info, sizeof(info))) { ret = -EFAULT; goto err; } break; } default: ret = -EINVAL; goto err; } ret = 0; err: if (thread) thread-\u003elooper_need_return = false; wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error \u003c 2); if (ret \u0026\u0026 ret != -ERESTARTSYS) pr_info(\"%d:%d ioctl %x %lx returned %d\\n\", proc-\u003epid, current-\u003epid, cmd, arg, ret); err_unlocked: trace_binder_ioctl_done(ret); return ret; } 获取binder线程 从binder_proc中查找binder_thread,如果当前线程已经加入到proc的线程队列则直接返回，如果不存在则创建binder_thread，并将当前线程添加到当前的proc\nstatic struct binder_thread *binder_get_thread(struct binder_proc *proc) { struct binder_thread *thread; struct binder_thread *new_thread; binder_inner_proc_lock(proc); //从当前进程中获取线程 thread = binder_get_thread_ilocked(proc, NULL); binder_inner_proc_unlock(proc); if (!thread) { //如果当前进程中没有线程，那么创建一个 new_thread = kzalloc(sizeof(*thread), GFP_KERNEL); if (new_thread == NULL) return NULL; binder_inner_proc_lock(proc); thread = binder_get_thread_ilocked(proc, new_thread); binder_inner_proc_unlock(proc); if (thread != new_thread) kfree(new_thread); } return thread; } binder_thread结构体 binder_thread是当前binder操作所在的线程；\nstruct binder_thread { struct binder_proc *proc;//线程所属的进程 struct rb_node rb_node; //红黑树节点 struct list_head waiting_thread_node; int pid;//线程pid int looper; /* only modified by this thread */ bool looper_need_return; /* can be written by other thread */ struct binder_transaction *transaction_stack;//线程正在处理的事务 struct list_head todo;//将要处理的链表 bool process_todo; struct binder_error return_error;//write失败后，返回的错误码 struct binder_error reply_error; wait_queue_head_t wait; //等待队列的队头 struct binder_stats stats;//binder线程的统计信息 atomic_t tmp_ref; bool is_dead; struct task_struct *task; }; ServiceManager是如何成binder驱动的上下文管理者 ServiceManager在native层中ProcessState的becomeContextManager函数通过ioctl发送BINDER_SET_CONTEXT_MGR_EXT 命令，让自身成为上下文管理者;然后在binder驱动中的binder_ioctl接收到了BINDER_SET_CONTEXT_MGR_EXT指令后；通过binder_ioctl_set_ctx_mgr函数进行处理；\nbinder_ioctl_set_ctx_mgr()处理如下：\n通过filp-\u003eprivate_data找到binder_proc; 对当前进程进行是否具注册Context Manager的SELinux安全权限的检查 进行uid检查，线程只能注册自己，且只能有一个线程设置为Context Manager 设置当前线程euid作为ServiceManager的uid； 创建一个binder实体binder_node，并加入到当前进程的nodes红黑树中； 把新创建的binder_node,赋值给当前进程的binder_context_mgr_node，这样就约定该进程就成为了binder驱动的上下文的管理者； static int binder_ioctl_set_ctx_mgr(struct file *filp, struct flat_binder_object *fbo) { int ret = 0; //filp-\u003eprivate_data 在open()binder驱动时，保存了一个创建的binder_proc，即是此时调用进程的binder_proc. struct binder_proc *proc = filp-\u003eprivate_data; //获得当前进程的context struct binder_context *context = proc-\u003econtext; struct binder_node *new_node; kuid_t curr_euid = current_euid(); mutex_lock(\u0026context-\u003econtext_mgr_node_lock); //保证只创建一次mgr_node对象 if (context-\u003ebinder_context_mgr_node) { pr_err(\"BINDER_SET_CONTEXT_MGR already set\\n\"); ret = -EBUSY; goto out; } //检查当前进程是否具注册Context Manager的SEAndroid安全权限 ret = security_binder_set_context_mgr(proc-\u003etsk); if (ret \u003c 0) goto out; //检查已的uid是否有效 if (uid_valid(context-\u003ebinder_context_mgr_uid)) { //uid有效但是与当前运行线程的效用户ID不相等，则出错。 //即线程只能注册自己，且只能有一个线程设置为Context Manager if (!uid_eq(context-\u003ebinder_context_mgr_uid, curr_euid)) { pr_err(\"BINDER_SET_CONTEXT_MGR bad uid %d != %d\\n\", from_kuid(\u0026init_user_ns, curr_euid), from_kuid(\u0026init_user_ns, context-\u003ebinder_context_mgr_uid)); ret = -EPERM; goto out; } } else { //设置当前线程euid作为ServiceManager的uid context-\u003ebinder_context_mgr_uid = curr_euid; } //创建binder实体，并加入到当前进程的nodes红黑树中，我们这里可以是ServiceManager new_node = binder_new_node(proc, fbo); if (!new_node) { ret = -ENOMEM; goto out; } binder_node_lock(new_node); //更新new_node的相关强弱引用计数 new_node-\u003elocal_weak_refs++; new_node-\u003elocal_strong_refs++; new_node-\u003ehas_strong_ref = 1; new_node-\u003ehas_weak_ref = 1; //new_node 赋值给进程的上下文管理节点，作为上下文管理者 context-\u003ebinder_context_mgr_node = new_node; binder_node_unlock(new_node); binder_put_node(new_node); out: mutex_unlock(\u0026context-\u003econtext_mgr_node_lock); return ret; } binder_node结构体 binder_node代表一个binder实体\nstruct binder_node { int debug_id;//节点创建时分配，具有全局唯一性，用于调试使用 spinlock_t lock; struct binder_work work; union { struct rb_node rb_node;//binder节点正常使用，union struct hlist_node dead_node;//binder节点已销毁，union }; struct binder_proc *proc;//binder所在的进程 struct hlist_head refs;//所有指向该节点的binder引用队列 int internal_strong_refs; int local_weak_refs; int local_strong_refs; int tmp_refs; binder_uintptr_t ptr;//指向用户空间binder_node的指针，对应flat_binder_object.binder binder_uintptr_t cookie;//数据，对应flat_binder_object.cooki struct { /* * bitfield elements protected by * proc inner_lock */ u8 has_strong_ref:1; u8 pending_strong_ref:1; u8 has_weak_ref:1; u8 pending_weak_ref:1; }; struct { /* * invariant after initialization */ u8 sched_policy:2; u8 inherit_rt:1; u8 accept_fds:1; u8 txn_security_ctx:1; u8 min_priority; }; bool has_async_transaction; struct list_head async_todo;//异步todo队列 }; binder_ioctl_write_read binder_ioctl_write_read是binder数据交互的核心入口,在native层中通过ioctl发送BINDER_WRITE_READ命令执行该函数，arg是一个binder_write_read结构体;\nstatic int binder_ioctl_write_read(struct file *filp, unsigned int cmd, unsigned long arg, struct binder_thread *thread) { int ret = 0; struct binder_proc *proc = filp-\u003eprivate_data; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; struct binder_write_read bwr; if (size != sizeof(struct binder_write_read)) { ret = -EINVAL; goto out; } //把用户空间数据ubuf拷贝到bwr if (copy_from_user(\u0026bwr, ubuf, sizeof(bwr))) { ret = -EFAULT; goto out; } binder_debug(BINDER_DEBUG_READ_WRITE, \"%d:%d write %lld at %016llx, read %lld at %016llx\\n\", proc-\u003epid, thread-\u003epid, (u64)bwr.write_size, (u64)bwr.write_buffer, (u64)bwr.read_size, (u64)bwr.read_buffer); if (bwr.write_size \u003e 0) { //当写缓存中有数据，则执行binder写操作 ret = binder_thread_write(proc, thread, bwr.write_buffer, bwr.write_size, \u0026bwr.write_consumed); trace_binder_write_done(ret); if (ret \u003c 0) { //binder_thread_write中有错误发生，则read_consumed设为0，表示kernel没有数据返回给进程 bwr.read_consumed = 0; //将bwr返回给用户态调用者，bwr在binder_thread_write中会被修改 if (copy_to_user(ubuf, \u0026bwr, sizeof(bwr))) ret = -EFAULT; goto out; } } if (bwr.read_size \u003e 0) { //当读缓存中有数据，则执行binder读操作 ret = binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, \u0026bwr.read_consumed, filp-\u003ef_flags \u0026 O_NONBLOCK); trace_binder_read_done(ret); binder_inner_proc_lock(proc); //读取完后，如果proc-\u003etodo链表不为空，则唤醒在proc-\u003ewait等待队列上的进程 if (!binder_worklist_empty_ilocked(\u0026proc-\u003etodo)) binder_wakeup_proc_ilocked(proc); binder_inner_proc_unlock(proc); if (ret \u003c 0) { //如果binder_thread_read返回小于0，可能处理一半就中断了，需要将bwr拷贝回进程的用户态地址 if (copy_to_user(ubuf, \u0026bwr, sizeof(bwr))) ret = -EFAULT; goto out; } } binder_debug(BINDER_DEBUG_READ_WRITE, \"%d:%d wrote %lld of %lld, read return %lld of %lld\\n\", proc-\u003epid, thread-\u003epid, (u64)bwr.write_consumed, (u64)bwr.write_size, (u64)bwr.read_consumed, (u64)bwr.read_size); //将内核数据bwr拷贝到用户空间ubuf if (copy_to_user(ubuf, \u0026bwr, sizeof(bwr))) { ret = -EFAULT; goto out; } out: return ret; } 流程:\n用户空间数据ubuf拷贝到内核空间bwr; 当bwr写缓存有数据，则执行binder_thread_write；当写失败则read_consumed设为0，并将bwr数据写回用户空间并退出； 当bwr读缓存有数据，则执行binder_thread_read，读取完后，如果proc-\u003etodo链表不为空，则唤醒在proc-\u003ewait等待队列上的进程;当读失败则再将bwr数据写回用户空间并退出； 把内核数据bwr拷贝到用户空间ubuf。 ",
  "wordCount" : "2127",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://rong05.github.io/learn/android/binder_driver/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "LEAN",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rong05.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rong05.github.io/" accesskey="h" title="LEAN (Alt + H)">LEAN</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://rong05.github.io/fr/" title="French"
                            aria-label=":fr:">🇫🇷</a>
                    </li>
                    <li>
                        <a href="https://rong05.github.io/fa/" title="Fa"
                            aria-label="Fa">Fa</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rong05.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://rong05.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://rong05.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://discord.gg/ahpmTvhVmp" title="Discord">
                    <span>Discord</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://rong05.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://rong05.github.io/learn/">Learns</a></div>
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">10 min&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/learn/android/Binder_Driver.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#binder-driver%e6%8e%a2%e7%b4%a2" aria-label="Binder Driver探索">Binder Driver探索</a><ul>
                        
                <li>
                    <a href="#binder%e9%a9%b1%e5%8a%a8%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="binder驱动的初始化">binder驱动的初始化</a></li>
                <li>
                    <a href="#binder_open" aria-label="binder_open">binder_open</a><ul>
                        
                <li>
                    <a href="#binder_procs%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="binder_procs结构体">binder_procs结构体</a></li></ul>
                </li>
                <li>
                    <a href="#binder_mmap" aria-label="binder_mmap">binder_mmap</a><ul>
                        
                <li>
                    <a href="#binder_buffer%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="binder_buffer结构体">binder_buffer结构体</a></li>
                <li>
                    <a href="#%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e9%87%8a%e6%94%be" aria-label="物理内存的分配和释放">物理内存的分配和释放</a></li></ul>
                </li>
                <li>
                    <a href="#binder_ioctl" aria-label="binder_ioctl">binder_ioctl</a><ul>
                        
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96binder%e7%ba%bf%e7%a8%8b" aria-label="获取binder线程">获取binder线程</a></li>
                <li>
                    <a href="#binder_thread%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="binder_thread结构体">binder_thread结构体</a></li>
                <li>
                    <a href="#servicemanager%e6%98%af%e5%a6%82%e4%bd%95%e6%88%90binder%e9%a9%b1%e5%8a%a8%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e7%ae%a1%e7%90%86%e8%80%85" aria-label="ServiceManager是如何成binder驱动的上下文管理者">ServiceManager是如何成binder驱动的上下文管理者</a></li>
                <li>
                    <a href="#binder_node%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="binder_node结构体">binder_node结构体</a></li>
                <li>
                    <a href="#binder_ioctl_write_read" aria-label="binder_ioctl_write_read">binder_ioctl_write_read</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="binder-driver探索">Binder Driver探索<a hidden class="anchor" aria-hidden="true" href="#binder-driver探索">#</a></h1>
<h2 id="binder驱动的初始化">binder驱动的初始化<a hidden class="anchor" aria-hidden="true" href="#binder驱动的初始化">#</a></h2>
<p>在binder.c中有以下一行代码；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">device_initcall</span><span class="p">(</span><span class="n">binder_init</span><span class="p">);</span>
</span></span></code></pre></div><p>在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它可以将驱动设备加载进内核中，以供后续使用。</p>
<p>在Android8.0之后，现在Binder驱动有三个：/dev/binder; /dev/hwbinder; /dev/vndbinder.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">binder_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">device_name</span><span class="p">,</span> <span class="o">*</span><span class="n">device_tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">device_names</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//初始化binder缓冲区分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ret</span> <span class="o">=</span> <span class="nf">binder_alloc_shrinker_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ~0U：无符号整型，对0取反。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_transaction_log</span><span class="p">.</span><span class="n">cur</span><span class="p">,</span> <span class="o">~</span><span class="mi">0U</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_transaction_log_failed</span><span class="p">.</span><span class="n">cur</span><span class="p">,</span> <span class="o">~</span><span class="mi">0U</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建/sys/kernel/debug/binder目录。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">binder_debugfs_dir_entry_root</span> <span class="o">=</span> <span class="nf">debugfs_create_dir</span><span class="p">(</span><span class="s">&#34;binder&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建/sys/kernel/debug/binder/proc目录用于记录每个进程基本信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">binder_debugfs_dir_entry_root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">binder_debugfs_dir_entry_proc</span> <span class="o">=</span> <span class="nf">debugfs_create_dir</span><span class="p">(</span><span class="s">&#34;proc&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="n">binder_debugfs_dir_entry_root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">binder_debugfs_dir_entry_root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建/sys/kernel/debug/binder/state文件用于记录状态信息，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//并注册操作函数binder_state_fops。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">debugfs_create_file</span><span class="p">(</span><span class="s">&#34;state&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="mo">0444</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">binder_debugfs_dir_entry_root</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">binder_state_fops</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建/sys/kernel/debug/binder/stats文件用于记录统计信息，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//并注册操作函数binder_stats_fops。     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">debugfs_create_file</span><span class="p">(</span><span class="s">&#34;stats&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="mo">0444</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">binder_debugfs_dir_entry_root</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">binder_stats_fops</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 创建/sys/kernel/debug/binder/transactions文件用于记录transaction相关信息，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="c1">//并注册操作函数binder_transactions_fops。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">debugfs_create_file</span><span class="p">(</span><span class="s">&#34;transactions&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="mo">0444</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">binder_debugfs_dir_entry_root</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">binder_transactions_fops</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建/sys/kernel/debug/binder/transaction_log文件用于记录transaction日志相关信息，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//并注册操作函数binder_transaction_log_fops。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">debugfs_create_file</span><span class="p">(</span><span class="s">&#34;transaction_log&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="mo">0444</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">binder_debugfs_dir_entry_root</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">binder_transaction_log</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">binder_transaction_log_fops</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建/sys/kernel/debug/binder/failed_transaction_log文件用于记录transaction失败日志相关信息，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 并注册操作函数binder_transaction_log_fops
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">debugfs_create_file</span><span class="p">(</span><span class="s">&#34;failed_transaction_log&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="mo">0444</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">binder_debugfs_dir_entry_root</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">binder_transaction_log_failed</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">binder_transaction_log_fops</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_ANDROID_BINDERFS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">strcmp</span><span class="p">(</span><span class="n">binder_devices_param</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    * Copy the module_parameter string, because we don&#39;t want to
</span></span></span><span class="line"><span class="cl"><span class="cm">    * tokenize it in-place.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// kzalloc：分配不超过128KB的连续的物理内存映射区域。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// GFP_KERNEL：内存分配器flags，无内存可用时可引起休眠，允许启动磁盘IO和文件系统IO。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// binder_devices_param：binder，hwbinder，vndbinder。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">device_names</span> <span class="o">=</span> <span class="nf">kstrdup</span><span class="p">(</span><span class="n">binder_devices_param</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device_names</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err_alloc_device_names_failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 创建binder设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">device_tmp</span> <span class="o">=</span> <span class="n">device_names</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">device_name</span> <span class="o">=</span> <span class="nf">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_tmp</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="nf">init_binder_device</span><span class="p">(</span><span class="n">device_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">err_init_binder_device_failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//初始化binder文件系统
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ret</span> <span class="o">=</span> <span class="nf">init_binderfs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">err_init_binder_device_failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">err_init_binder_device_failed</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">binder_devices</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">miscdev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">kfree</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">kfree</span><span class="p">(</span><span class="n">device_names</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">err_alloc_device_names_failed</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">debugfs_remove_recursive</span><span class="p">(</span><span class="n">binder_debugfs_dir_entry_root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>binder_init</code>函数主要内容是：</p>
<ul>
<li>初始化binder缓冲区分配</li>
<li>创建了sys/kernel/debug/binder目录，以及其子目录或文件</li>
<li>注册misc设备，创建binder设备</li>
<li>把binder_device加入到全局链表binder_devices进行管理</li>
</ul>
<p>那来看看<code>init_binder_device</code>是如何注册misc设备，创建binder设备，代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_binder_device</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_device</span> <span class="o">*</span><span class="n">binder_device</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">binder_device</span> <span class="o">=</span> <span class="nf">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">binder_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">binder_device</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//miscdevice结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">miscdev</span><span class="p">.</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">binder_fops</span><span class="p">;</span> <span class="c1">//设备的文件操作结构，这是file_operations结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">miscdev</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">;</span><span class="c1">//次设备号 动态分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">miscdev</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span><span class="c1">//设备名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//binder设备的引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">refcount_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//默认binder驱动的上下文管理者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">binder_context_mgr_uid</span> <span class="o">=</span> <span class="n">INVALID_UID</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">context_mgr_node_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 注册misc设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ret</span> <span class="o">=</span> <span class="nf">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">miscdev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">kfree</span><span class="p">(</span><span class="n">binder_device</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通过全局链表binder_devices管理binder_device。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">binder_devices</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从<code>init_binder_device</code>函数看出binder驱动设备节点是通过<code>binder_device</code>结构体管理的；设置<code>binder_device</code>的<code>miscdev</code>参数，<code>miscdev</code>其实是<code>miscdevice</code>结构体，misc_register函数注册misc设备，<code>miscdevice</code>参数分别是：</p>
<ol>
<li>设备的文件操作结构，这是file_operations结构</li>
<li>次设备号 动态分配</li>
<li>设备名</li>
</ol>
<p><code>binder_device</code>结构体定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">binder_device</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 加入binder_devices全局链表的node。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hlist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// misc设备。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">miscdev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 获取service manager对应的binder_node。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_context</span> <span class="n">context</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//属于bindfs挂载的超级块的根节点的inode。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">binderfs_inode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//binder_device的引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">refcount_t</span> <span class="n">ref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><code>file_operations</code>结构体,指定相应文件操作的方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">binder_fops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">binder_poll</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">binder_ioctl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span> <span class="n">compat_ptr_ioctl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">binder_mmap</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">binder_open</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">binder_flush</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">binder_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>用户态的程序调用Kernel层驱动是需要陷入内核态，进行系统调用(<code>syscall</code>)，比如打开Binder驱动方法的调用链为： open-&gt; __open() -&gt; binder_open()。通过<code>binder_fops</code>的定义得出以下调用规则；</p>
<p><img loading="lazy" src="./img/binder_syscall.png" alt="binder_syscall"  />
</p>
<p><a href="http://gityuan.com/2015/11/01/binder-driver/">图片来源</a></p>
<h2 id="binder_open">binder_open<a hidden class="anchor" aria-hidden="true" href="#binder_open">#</a></h2>
<p>之前已经提到每个进程都会单独创建自己的<code>ProcessState</code>，<code>ProcessState</code>是进程唯一的；在<code>ProcessState</code>创建时会调用<code>open</code>函数，那对应调用的就是binder驱动中的<code>binder_open</code>;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">binder_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">nodp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="o">*</span><span class="n">itr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_device</span> <span class="o">*</span><span class="n">binder_dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binderfs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">binder_binderfs_dir_entry_proc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">existing_pid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_OPEN_CLOSE</span><span class="p">,</span> <span class="s">&#34;%s: %d:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//创建binder驱动中管理IPC和保存进程信息的根结构体  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">proc</span> <span class="o">=</span> <span class="nf">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">proc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">proc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 初始化两个自旋锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// inner_lock保护线程、binder_node以及所有与进程相关的的todo队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// outer_lock保护binder_ref。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">inner_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">outer_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取当前进程组领头进程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">get_task_struct</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">proc</span><span class="o">-&gt;</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span><span class="c1">//将当前进程的task_struct保存到binder_proc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">todo</span><span class="p">);</span><span class="c1">//初始化todo列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 判断当前进程的调度策略是否支持，binder只支持SCHED_NORMAL(00b)、SCHED_FIFO(01b)、SCHED_RR(10b)、SCHED_BATCH(11b)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// prio为进程优先级，可通过normal_prio获取。一般分为实时优先级及静态优先级。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nf">binder_supported_policy</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">default_priority</span><span class="p">.</span><span class="n">sched_policy</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">default_priority</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">default_priority</span><span class="p">.</span><span class="n">sched_policy</span> <span class="o">=</span> <span class="n">SCHED_NORMAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">default_priority</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="nf">NICE_TO_PRIO</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* binderfs stashes devices in i_private */</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 通过miscdev获取binder_device。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nf">is_binderfs_device</span><span class="p">(</span><span class="n">nodp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">binder_dev</span> <span class="o">=</span> <span class="n">nodp</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">info</span> <span class="o">=</span> <span class="n">nodp</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">binder_binderfs_dir_entry_proc</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">proc_log_dir</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">binder_dev</span> <span class="o">=</span> <span class="nf">container_of</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">struct</span> <span class="n">binder_device</span><span class="p">,</span> <span class="n">miscdev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//binder_device的引用计数加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">refcount_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_dev</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//初始化对应进程中的binder驱动上下文管理者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">proc</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">binder_dev</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 初始化binder_proc的binder_alloc字段。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">binder_alloc_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// binder驱动维护静态全局数组binder_stats，其中有一个成员数组obj_created。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当binder_open调用时，obj_created[BINDER_STAT_PROC]将自增。该数组用来统计binder对象的数量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">binder_stats_created</span><span class="p">(</span><span class="n">BINDER_STAT_PROC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//初始化binder_proc的pid为领头进程的pid值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 初始化delivered_death及waiting_threads队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">delivered_death</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">waiting_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// private_data保存binder_proc对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将binder_proc加入到全局队列binder_procs中,该操作必须加锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_procs_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">hlist_for_each_entry</span><span class="p">(</span><span class="n">itr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">binder_procs</span><span class="p">,</span> <span class="n">proc_node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">itr</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">existing_pid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">proc_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">binder_procs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_procs_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 若/sys/kernel/binder/proc目录已经创建好，则在该目录下创建一个以pid为名的文件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">binder_debugfs_dir_entry_proc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">existing_pid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">strbuf</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">snprintf</span><span class="p">(</span><span class="n">strbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">strbuf</span><span class="p">),</span> <span class="s">&#34;%u&#34;</span><span class="p">,</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">     * proc debug entries are shared between contexts.
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Only create for the first PID to avoid debugfs log spamming
</span></span></span><span class="line"><span class="cl"><span class="cm">     * The printing code will anyway print all contexts for a given
</span></span></span><span class="line"><span class="cl"><span class="cm">     * PID so this is not a problem.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// proc调试条目在上下文之间共享，如果进程尝试使用其他上下文再次打开驱动程序，则此操作将失败。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">debugfs_entry</span> <span class="o">=</span> <span class="nf">debugfs_create_file</span><span class="p">(</span><span class="n">strbuf</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">binder_debugfs_dir_entry_proc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;</span><span class="n">proc_fops</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">binder_binderfs_dir_entry_proc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">existing_pid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">strbuf</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">binderfs_entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">snprintf</span><span class="p">(</span><span class="n">strbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">strbuf</span><span class="p">),</span> <span class="s">&#34;%u&#34;</span><span class="p">,</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Similar to debugfs, the process specific log file is shared
</span></span></span><span class="line"><span class="cl"><span class="cm">     * between contexts. Only create for the first PID.
</span></span></span><span class="line"><span class="cl"><span class="cm">     * This is ok since same as debugfs, the log file will contain
</span></span></span><span class="line"><span class="cl"><span class="cm">     * information on all contexts of a given PID.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">binderfs_entry</span> <span class="o">=</span> <span class="nf">binderfs_create_file</span><span class="p">(</span><span class="n">binder_binderfs_dir_entry_proc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">strbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_fops</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">IS_ERR</span><span class="p">(</span><span class="n">binderfs_entry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">proc</span><span class="o">-&gt;</span><span class="n">binderfs_entry</span> <span class="o">=</span> <span class="n">binderfs_entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">error</span> <span class="o">=</span> <span class="nf">PTR_ERR</span><span class="p">(</span><span class="n">binderfs_entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">pr_warn</span><span class="p">(</span><span class="s">&#34;Unable to create file %s in binderfs (error %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">strbuf</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从<code>binder_open</code>函数的主要工作是创建<code>binder_proc</code>结构体，并把当前进程等信息保存到<code>binder_proc</code>，初始化<code>binder_proc</code>中管理IPC所需的各种信息并创建其它相关的子结构体；再把<code>binder_proc</code>保存到文件指针<code>filp</code>，以及把<code>binder_proc</code>加入到全局链表<code>binder_procs</code>，这一个双向链表结构。</p>
<h3 id="binder_procs结构体">binder_procs结构体<a hidden class="anchor" aria-hidden="true" href="#binder_procs结构体">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">binder_proc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//加入binder_procs全局链表的node节点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">proc_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//记录执行传输动作的线程信息, binder_thread红黑树的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//用于记录binder实体  ,binder_node红黑树的根节点，它是Server在Binder驱动中的体现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">nodes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//binder_ref红黑树的根节点(以handle为key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">refs_by_desc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//binder_ref红黑树的根节点（以ptr为key）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">refs_by_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//该binder进程的线程池中等待处理binder_work的binder_thread链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">waiting_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//相应进程id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//相应进程的task结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">deferred_work_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">deferred_work</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">is_dead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//进程将要做的事
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">todo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//binder统计信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_stats</span> <span class="n">stats</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//已分发的死亡通知
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">delivered_death</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//最大线程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">max_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//请求的线程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">requested_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//已启动的请求线程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">requested_threads_started</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">tmp_ref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//默认优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_priority</span> <span class="n">default_priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//进程通信数据内存分配相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_alloc</span> <span class="n">alloc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//binder驱动的上下文管理者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_context</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">spinlock_t</span> <span class="n">inner_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">spinlock_t</span> <span class="n">outer_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">binderfs_entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">binder_alloc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//指向进程虚拟地址空间的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//相应进程的内存结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">vma_vm_mm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// map 的地址就是这里了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//所有的buffers列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">buffers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//只进行了预定，没有分配，按大小排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">free_buffers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//已经分配了,按地址排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">allocated_buffers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//用于异步请求的空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">size_t</span> <span class="n">free_async_space</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//所有的pages指向物理内存页 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_lru_page</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//映射的内核空间大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">buffer_free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">pages_high</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="binder_mmap">binder_mmap<a hidden class="anchor" aria-hidden="true" href="#binder_mmap">#</a></h2>
<p>主要功能：</p>
<ol>
<li>为用户进程分配一块内核空间作为缓冲区，并把分配的缓冲区指针存放到binder_proc的buffer字段；</li>
<li>分配pages空间，并内核分配一块同样页数的内核空间,并把它的物理内存和前面为用户进程分配的内存地址关联；</li>
<li>分配的内存块加入用户进程内存链表；</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">binder_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//private_data保存了我们open设备时创建的binder_proc信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">tsk</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="nf">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_OPEN_CLOSE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="s">&#34;%s: %d %lx-%lx (%ld K) vma %lx pagep %lx</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">__func__</span><span class="p">,</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">/</span> <span class="n">SZ_1K</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="nf">pgprot_val</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//mmap 的 buffer 禁止用户进行写操作。mmap 只是为了分配内核空间，传递数据通过 ioctl()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">FORBIDDEN_MMAP_FLAGS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pr_err</span><span class="p">(</span><span class="s">&#34;%s: %d %lx-%lx %s failed %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span> <span class="s">&#34;bad vm_flags&#34;</span><span class="p">,</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将 VM_DONTCOP 置起，禁止 拷贝，禁止 写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_DONTCOPY</span> <span class="o">|</span> <span class="n">VM_MIXEDMAP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_MAYWRITE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">binder_vm_ops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 再次完善 binder buffer allocator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nf">binder_alloc_mmap_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">binder_alloc_mmap_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">binder_alloc</span> <span class="o">*</span><span class="n">alloc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">failure_string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//每一次Binder传输数据时，都会先从Binder内存缓存区中分配一个binder_buffer来存储传输数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//同步锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_alloc_mmap_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 不需要重复mmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">failure_string</span> <span class="o">=</span> <span class="s">&#34;already mapped&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">err_already_mapped</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//vma-&gt;vm_end, vma-&gt;vm_start 指向要 映射的用户空间地址, map size 不允许 大于 4M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="kt">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">SZ_4M</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_alloc_mmap_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//指向用户进程内核虚拟空间的 start地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//分配物理页的指针数组，数组大小为vma的等效page个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="nf">kcalloc</span><span class="p">(</span><span class="n">alloc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="k">sizeof</span><span class="p">(</span><span class="n">alloc</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl">             <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">failure_string</span> <span class="o">=</span> <span class="s">&#34;alloc page array&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">err_alloc_pages_failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//申请一个binder_buffer的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">buffer</span> <span class="o">=</span> <span class="nf">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">failure_string</span> <span class="o">=</span> <span class="s">&#34;alloc buffer struct&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">err_alloc_buf_struct_failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//指向用户进程内核虚拟空间的 start地址，即为当前进程mmap的内核空间地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//将binder_buffer地址，加入到所属进程的buffers队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//将当前buffer加入到红黑树alloc-&gt;free_buffers中，表示当前buffer是空闲buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">binder_insert_free_buffer</span><span class="p">(</span><span class="n">alloc</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将异步事务的空间大小设置为 整个空间的一半
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">free_async_space</span> <span class="o">=</span> <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">binder_alloc_set_vma</span><span class="p">(</span><span class="n">alloc</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mmgrab</span><span class="p">(</span><span class="n">alloc</span><span class="o">-&gt;</span><span class="n">vma_vm_mm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">err_alloc_buf_struct_failed</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">kfree</span><span class="p">(</span><span class="n">alloc</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">err_alloc_pages_failed</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_alloc_mmap_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">err_already_mapped</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binder_alloc_mmap_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">binder_alloc_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_USER_ERROR</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="s">&#34;%s: %d %lx-%lx %s failed %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">failure_string</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">binder_insert_free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">binder_alloc</span> <span class="o">*</span><span class="n">alloc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="k">struct</span> <span class="n">binder_buffer</span> <span class="o">*</span><span class="n">new_buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="o">-&gt;</span><span class="n">free_buffers</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">new_buffer_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">new_buffer</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通过binder_alloc_buffer_size计算当前new_buffer的大小，之后将用于比较。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">new_buffer_size</span> <span class="o">=</span> <span class="nf">binder_alloc_buffer_size</span><span class="p">(</span><span class="n">alloc</span><span class="p">,</span> <span class="n">new_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">binder_alloc_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_BUFFER_ALLOC</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="s">&#34;%d: add free buffer, size %zd, at %pK</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">alloc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">new_buffer_size</span><span class="p">,</span> <span class="n">new_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取当前红黑树节点的buffer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">buffer</span> <span class="o">=</span> <span class="nf">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">binder_buffer</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 计算当前红黑树节点的buffer大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">buffer_size</span> <span class="o">=</span> <span class="nf">binder_alloc_buffer_size</span><span class="p">(</span><span class="n">alloc</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 红黑树遵循二叉树规则：当新的buffer比当前节点的buffer小时，向左子节点继续重复，否则转向右子节点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">new_buffer_size</span> <span class="o">&lt;</span> <span class="n">buffer_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">      <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 找到合适位置后，将new_buffer插入到该位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_buffer</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_buffer</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alloc</span><span class="o">-&gt;</span><span class="n">free_buffers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>binder_mmap</code>通过加锁，保证一次只有一个进程分配内存，保证多进程间的并发访问。将分配一块内核空间缓冲区buffer加入到红黑树alloc-&gt;free_buffers中，表示当前buffer是空闲buffer；每一次Binder传输数据时，都会先从Binder内存缓存区中分配一个binder_buffer来存储传输数据。</p>
<h3 id="binder_buffer结构体">binder_buffer结构体<a hidden class="anchor" aria-hidden="true" href="#binder_buffer结构体">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">binder_buffer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//buffer实体的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span> <span class="cm">/* free and allocated entries by address */</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb_node</span><span class="p">;</span> <span class="cm">/* free entry by size or allocated entry */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* by address */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//标记是否是空闲buffer，占位1bit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="nl">free</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//是否允许用户释放，占位1bit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="nl">clear_on_free</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="nl">allow_user_free</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="nl">async_transaction</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="nl">debug_id</span><span class="p">:</span><span class="mi">28</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//该缓存区的需要处理的事务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//该缓存区所需处理的Binder实体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_node</span> <span class="o">*</span><span class="n">target_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//数据大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">size_t</span> <span class="n">data_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//数据偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">size_t</span> <span class="n">offsets_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">extra_buffers_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//用户数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span>    <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">binder_lru_page</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">lru</span><span class="p">;</span><span class="c1">//binder_alloc_lru中的条目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page_ptr</span><span class="p">;</span><span class="c1">//指向mmap空间中的物理页面的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_alloc</span> <span class="o">*</span><span class="n">alloc</span><span class="p">;</span><span class="c1">//proc的binder_alloc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p><code>binder_mmap</code>这里主要映射的内存只允许用户空间读，不允许用户空间写；<code>binder</code>驱动可以读写这块内存；存映射实现一次拷贝的概念是：</p>
<ol>
<li>用户空间给<code>binder</code>驱动传入信息时，都需要内存拷贝；</li>
<li><code>binder</code>驱动给发送用户空间则不需要；</li>
</ol>
<h3 id="物理内存的分配和释放">物理内存的分配和释放<a hidden class="anchor" aria-hidden="true" href="#物理内存的分配和释放">#</a></h3>
<p><code>binder_update_page_range</code>函数主要的作用是分配和释放物理内存；</p>
<h2 id="binder_ioctl">binder_ioctl<a hidden class="anchor" aria-hidden="true" href="#binder_ioctl">#</a></h2>
<p>binder_ioctl()函数负责在两个进程间收发IPC数据和IPC reply数据。</p>
<p>ioctl命令和数据类型是一体的，不同的命令对应不同的数据类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">ioctl命令</th>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>BINDER_WRITE_READ</strong></td>
<td style="text-align:left">struct binder_write_read</td>
<td style="text-align:left">收发Binder IPC数据</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_MAX_THREADS</td>
<td style="text-align:left">__u32</td>
<td style="text-align:left">设置Binder线程最大个数</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_CONTEXT_MGR</td>
<td style="text-align:left">__s32</td>
<td style="text-align:left">设置Service Manager节点</td>
</tr>
<tr>
<td style="text-align:left">BINDER_THREAD_EXIT</td>
<td style="text-align:left">__s32</td>
<td style="text-align:left">释放Binder线程</td>
</tr>
<tr>
<td style="text-align:left">BINDER_VERSION</td>
<td style="text-align:left">struct binder_version</td>
<td style="text-align:left">获取Binder版本信息</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_IDLE_TIMEOUT</td>
<td style="text-align:left">__s64</td>
<td style="text-align:left">没有使用</td>
</tr>
<tr>
<td style="text-align:left">BINDER_SET_IDLE_PRIORITY</td>
<td style="text-align:left">__s32</td>
<td style="text-align:left">没有使用</td>
</tr>
</tbody>
</table>
<p>这些命令中<code>BINDER_WRITE_READ</code>命令使用率最为频繁，也是ioctl最为核心的命令。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">long</span> <span class="nf">binder_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//oepn的时候包在filp的private_data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="nf">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/*pr_info(&#34;binder_ioctl: %d:%d %x %lx\n&#34;,
</span></span></span><span class="line"><span class="cl"><span class="cm">      proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">binder_selftest_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">trace_binder_ioctl</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//这里时一个阻塞代码，如果binder_stop_on_user_error 大于2这里会被休眠
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//这里先无视即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ret</span> <span class="o">=</span> <span class="nf">wait_event_interruptible</span><span class="p">(</span><span class="n">binder_user_error_wait</span><span class="p">,</span> <span class="n">binder_stop_on_user_error</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">err_unlocked</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//获取当前线程对应的结构体，如果没有创建过，那么就创建一个放入到proc的红黑树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">thread</span> <span class="o">=</span> <span class="nf">binder_get_thread</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="kr">thread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">BINDER_WRITE_READ</span><span class="p">:</span><span class="c1">//进行binder的读写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="nf">binder_ioctl_write_read</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">BINDER_SET_MAX_THREADS</span><span class="p">:</span> <span class="p">{</span><span class="c1">//设置binder最大支持的线程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">max_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max_threads</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="k">sizeof</span><span class="p">(</span><span class="n">max_threads</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">binder_inner_proc_lock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">max_threads</span> <span class="o">=</span> <span class="n">max_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">binder_inner_proc_unlock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">BINDER_SET_CONTEXT_MGR_EXT</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//设置Service Manager节点，带flag参数， servicemanager进程成为上下文管理者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">flat_binder_object</span> <span class="n">fbo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fbo</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fbo</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">binder_ioctl_set_ctx_mgr</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">BINDER_SET_CONTEXT_MGR</span><span class="p">:</span><span class="c1">//成为binder的上下文管理者，不带flag参数，也就是ServiceManager成为守护进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="nf">binder_ioctl_set_ctx_mgr</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">BINDER_THREAD_EXIT</span><span class="p">:</span><span class="c1">//当binder线程退出，释放binder线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_THREADS</span><span class="p">,</span> <span class="s">&#34;%d:%d exit</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">binder_thread_release</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">BINDER_VERSION</span><span class="p">:</span> <span class="p">{</span><span class="c1">//获取binder的版本号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">binder_version</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ver</span> <span class="o">=</span> <span class="n">ubuf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">binder_version</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">put_user</span><span class="p">(</span><span class="n">BINDER_CURRENT_PROTOCOL_VERSION</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="o">&amp;</span><span class="n">ver</span><span class="o">-&gt;</span><span class="n">protocol_version</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">BINDER_GET_NODE_INFO_FOR_REF</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">binder_node_info_for_ref</span> <span class="n">info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">binder_ioctl_get_node_info_for_ref</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">BINDER_GET_NODE_DEBUG_INFO</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">binder_node_debug_info</span> <span class="n">info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">binder_ioctl_get_node_debug_info</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">err</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">looper_need_return</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">wait_event_interruptible</span><span class="p">(</span><span class="n">binder_user_error_wait</span><span class="p">,</span> <span class="n">binder_stop_on_user_error</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pr_info</span><span class="p">(</span><span class="s">&#34;%d:%d ioctl %x %lx returned %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nl">err_unlocked</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">trace_binder_ioctl_done</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="获取binder线程">获取binder线程<a hidden class="anchor" aria-hidden="true" href="#获取binder线程">#</a></h3>
<p>从binder_proc中查找binder_thread,如果当前线程已经加入到proc的线程队列则直接返回，如果不存在则创建binder_thread，并将当前线程添加到当前的proc</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">binder_thread</span> <span class="o">*</span><span class="nf">binder_get_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_thread</span> <span class="o">*</span><span class="n">new_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">binder_inner_proc_lock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//从当前进程中获取线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">thread</span> <span class="o">=</span> <span class="nf">binder_get_thread_ilocked</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">binder_inner_proc_unlock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果当前进程中没有线程，那么创建一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">new_thread</span> <span class="o">=</span> <span class="nf">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="kr">thread</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">new_thread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">binder_inner_proc_lock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">thread</span> <span class="o">=</span> <span class="nf">binder_get_thread_ilocked</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">new_thread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">binder_inner_proc_unlock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="kr">thread</span> <span class="o">!=</span> <span class="n">new_thread</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">kfree</span><span class="p">(</span><span class="n">new_thread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kr">thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="binder_thread结构体">binder_thread结构体<a hidden class="anchor" aria-hidden="true" href="#binder_thread结构体">#</a></h3>
<p><code>binder_thread</code>是当前binder操作所在的线程；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">binder_thread</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">;</span><span class="c1">//线程所属的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb_node</span><span class="p">;</span> <span class="c1">//红黑树节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">waiting_thread_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span><span class="c1">//线程pid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">looper</span><span class="p">;</span>              <span class="cm">/* only modified by this thread */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">looper_need_return</span><span class="p">;</span> <span class="cm">/* can be written by other thread */</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_transaction</span> <span class="o">*</span><span class="n">transaction_stack</span><span class="p">;</span><span class="c1">//线程正在处理的事务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">todo</span><span class="p">;</span><span class="c1">//将要处理的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">process_todo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_error</span> <span class="n">return_error</span><span class="p">;</span><span class="c1">//write失败后，返回的错误码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_error</span> <span class="n">reply_error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">wait_queue_head_t</span> <span class="n">wait</span><span class="p">;</span> <span class="c1">//等待队列的队头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_stats</span> <span class="n">stats</span><span class="p">;</span><span class="c1">//binder线程的统计信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">atomic_t</span> <span class="n">tmp_ref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">is_dead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="servicemanager是如何成binder驱动的上下文管理者">ServiceManager是如何成binder驱动的上下文管理者<a hidden class="anchor" aria-hidden="true" href="#servicemanager是如何成binder驱动的上下文管理者">#</a></h3>
<p><code>ServiceManager</code>在native层中<code>ProcessState</code>的<code>becomeContextManager</code>函数通过<code>ioctl</code>发送<code>BINDER_SET_CONTEXT_MGR_EXT</code> 命令，让自身成为上下文管理者;然后在binder驱动中的<code>binder_ioctl</code>接收到了<code>BINDER_SET_CONTEXT_MGR_EXT</code>指令后；通过<code>binder_ioctl_set_ctx_mgr</code>函数进行处理；</p>
<p><strong>binder_ioctl_set_ctx_mgr()处理如下：</strong></p>
<ol>
<li>通过<code>filp-&gt;private_data</code>找到<code>binder_proc</code>;</li>
<li>对当前进程进行是否具注册Context Manager的SELinux安全权限的检查</li>
<li>进行uid检查，线程只能注册自己，且只能有一个线程设置为Context Manager</li>
<li>设置当前线程euid作为ServiceManager的uid；</li>
<li>创建一个binder实体binder_node，并加入到当前进程的nodes红黑树中；</li>
<li>把新创建的binder_node,赋值给当前进程的binder_context_mgr_node，这样就约定该进程就成为了binder驱动的上下文的管理者；</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">binder_ioctl_set_ctx_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">struct</span> <span class="n">flat_binder_object</span> <span class="o">*</span><span class="n">fbo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//filp-&gt;private_data 在open()binder驱动时，保存了一个创建的binder_proc，即是此时调用进程的binder_proc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//获得当前进程的context
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">binder_context</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_node</span> <span class="o">*</span><span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">kuid_t</span> <span class="n">curr_euid</span> <span class="o">=</span> <span class="nf">current_euid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">context_mgr_node_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//保证只创建一次mgr_node对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">binder_context_mgr_node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pr_err</span><span class="p">(</span><span class="s">&#34;BINDER_SET_CONTEXT_MGR already set</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//检查当前进程是否具注册Context Manager的SEAndroid安全权限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ret</span> <span class="o">=</span> <span class="nf">security_binder_set_context_mgr</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">tsk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//检查已的uid是否有效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nf">uid_valid</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">binder_context_mgr_uid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//uid有效但是与当前运行线程的效用户ID不相等，则出错。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//即线程只能注册自己，且只能有一个线程设置为Context Manager
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">uid_eq</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">binder_context_mgr_uid</span><span class="p">,</span> <span class="n">curr_euid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">pr_err</span><span class="p">(</span><span class="s">&#34;BINDER_SET_CONTEXT_MGR bad uid %d != %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="nf">from_kuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">curr_euid</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">             <span class="nf">from_kuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">context</span><span class="o">-&gt;</span><span class="n">binder_context_mgr_uid</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置当前线程euid作为ServiceManager的uid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">context</span><span class="o">-&gt;</span><span class="n">binder_context_mgr_uid</span> <span class="o">=</span> <span class="n">curr_euid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//创建binder实体，并加入到当前进程的nodes红黑树中，我们这里可以是ServiceManager
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">new_node</span> <span class="o">=</span> <span class="nf">binder_new_node</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fbo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">binder_node_lock</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//更新new_node的相关强弱引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">local_weak_refs</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">local_strong_refs</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">has_strong_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">has_weak_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//new_node 赋值给进程的上下文管理节点，作为上下文管理者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">context</span><span class="o">-&gt;</span><span class="n">binder_context_mgr_node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">binder_node_unlock</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">binder_put_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nl">out</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">context_mgr_node_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="binder_node结构体">binder_node结构体<a hidden class="anchor" aria-hidden="true" href="#binder_node结构体">#</a></h3>
<p><code>binder_node</code>代表一个binder实体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">binder_node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">debug_id</span><span class="p">;</span><span class="c1">//节点创建时分配，具有全局唯一性，用于调试使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_work</span> <span class="n">work</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb_node</span><span class="p">;</span><span class="c1">//binder节点正常使用，union
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">dead_node</span><span class="p">;</span><span class="c1">//binder节点已销毁，union
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">;</span><span class="c1">//binder所在的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">refs</span><span class="p">;</span><span class="c1">//所有指向该节点的binder引用队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">internal_strong_refs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">local_weak_refs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">local_strong_refs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">tmp_refs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">binder_uintptr_t</span> <span class="n">ptr</span><span class="p">;</span><span class="c1">//指向用户空间binder_node的指针，对应flat_binder_object.binder
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">binder_uintptr_t</span> <span class="n">cookie</span><span class="p">;</span><span class="c1">//数据，对应flat_binder_object.cooki
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">     * bitfield elements protected by
</span></span></span><span class="line"><span class="cl"><span class="cm">     * proc inner_lock
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="nl">has_strong_ref</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="nl">pending_strong_ref</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="nl">has_weak_ref</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="nl">pending_weak_ref</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">     * invariant after initialization
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="nl">sched_policy</span><span class="p">:</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="nl">inherit_rt</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="nl">accept_fds</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="nl">txn_security_ctx</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="n">min_priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">has_async_transaction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">async_todo</span><span class="p">;</span><span class="c1">//异步todo队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h3 id="binder_ioctl_write_read">binder_ioctl_write_read<a hidden class="anchor" aria-hidden="true" href="#binder_ioctl_write_read">#</a></h3>
<p><code>binder_ioctl_write_read</code>是binder数据交互的核心入口,在native层中通过<code>ioctl</code>发送<code>BINDER_WRITE_READ</code>命令执行该函数，<code>arg</code>是一个<code>binder_write_read</code>结构体;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">binder_ioctl_write_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">binder_thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="nf">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">binder_write_read</span> <span class="n">bwr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">binder_write_read</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//把用户空间数据ubuf拷贝到bwr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nf">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bwr</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bwr</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_READ_WRITE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="s">&#34;%d:%d write %lld at %016llx, read %lld at %016llx</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_size</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_buffer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//当写缓存中有数据，则执行binder写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="nf">binder_thread_write</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="kr">thread</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">bwr</span><span class="p">.</span><span class="n">write_buffer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">bwr</span><span class="p">.</span><span class="n">write_size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">trace_binder_write_done</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//binder_thread_write中有错误发生，则read_consumed设为0，表示kernel没有数据返回给进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//将bwr返回给用户态调用者，bwr在binder_thread_write中会被修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nf">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bwr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bwr</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//当读缓存中有数据，则执行binder读操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="nf">binder_thread_read</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">bwr</span><span class="p">.</span><span class="n">read_buffer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="o">&amp;</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">trace_binder_read_done</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">binder_inner_proc_lock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//读取完后，如果proc-&gt;todo链表不为空，则唤醒在proc-&gt;wait等待队列上的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">binder_worklist_empty_ilocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">todo</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="nf">binder_wakeup_proc_ilocked</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">binder_inner_proc_unlock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//如果binder_thread_read返回小于0，可能处理一半就中断了，需要将bwr拷贝回进程的用户态地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nf">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bwr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bwr</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_READ_WRITE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="s">&#34;%d:%d wrote %lld of %lld, read return %lld of %lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//将内核数据bwr拷贝到用户空间ubuf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nf">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bwr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bwr</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">out</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>流程:</strong></p>
<ol>
<li>用户空间数据ubuf拷贝到内核空间bwr;</li>
<li>当bwr写缓存有数据，则执行binder_thread_write；当写失败则read_consumed设为0，并将bwr数据写回用户空间并退出；</li>
<li>当bwr读缓存有数据，则执行binder_thread_read，读取完后，如果proc-&gt;todo链表不为空，则唤醒在proc-&gt;wait等待队列上的进程;当读失败则再将bwr数据写回用户空间并退出；</li>
<li>把内核数据bwr拷贝到用户空间ubuf。</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://rong05.github.io/learn/android/android_selinux/">
    <span class="title">« Prev</span>
    <br>
    <span></span>
  </a>
  <a class="next" href="https://rong05.github.io/learn/android/mediacodec_learn/">
    <span class="title">Next »</span>
    <br>
    <span></span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on x"
        href="https://x.com/intent/tweet/?text=&amp;url=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fbinder_driver%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z"/>
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fbinder_driver%2f&amp;title=&amp;summary=&amp;source=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fbinder_driver%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fbinder_driver%2f&title=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fbinder_driver%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on whatsapp"
        href="https://api.whatsapp.com/send?text=%20-%20https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fbinder_driver%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on telegram"
        href="https://telegram.me/share/url?text=&amp;url=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fbinder_driver%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on ycombinator"
        href="https://news.ycombinator.com/submitlink?t=&u=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fbinder_driver%2f">
        <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
            xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
            <path
                d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://rong05.github.io/">LEAN</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>

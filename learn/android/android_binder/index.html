<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LEAN</title>
<meta name="keywords" content="">
<meta name="description" content="Binder通讯原理 基于Android 11的源码剖析，笔记记录binder通讯原理的实现过程；
根据网络上的各路大神案例，都是从典型的mediaserver进程开始分析，binder服务的注册注册过程；
mediaserver进程启动的main函数开始分析，至于init.rc的注册启动进程就跳过了；main函数代码如下：
int main(int argc __unused, char **argv __unused) { signal(SIGPIPE, SIG_IGN); //创建与binder驱动交互和binder线程池的管理者 sp&lt;ProcessState&gt; proc(ProcessState::self()); //获取ServiceManager的客户端BpServiceManager sp&lt;IServiceManager&gt; sm(defaultServiceManager()); ALOGI(&#34;ServiceManager: %p&#34;, sm.get()); //创建MediaPlayerService服务，和向ServiceManager注册服务 MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ::android::hardware::configureRpcThreadpool(16, false); //启动binder线程池 ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); ::android::hardware::joinRpcThreadpool(); } Binder线程池的注册 每个采用 Binder 的进程会有一个或多个用于处理接收数据的线程，位于 Binder 线程池。采用 Binder 机制的进程最典型的就是应用程序进程了。那应用程序进程的 Binder 线程池是在什么时候启动的呢？
ProcessState 源码位置：frameworks/native/libs/binder/ProcessState.cpp
ProcessState 是 Binder 机制核心之一，它是 Binder 通信的基础，负责与 Binder 驱动的交互与 Binder 线程池的管理。它实现了单例模式，通过 self() 函数获取实例，每个进程仅有一个。
ProcessState创建 实现了单例模式，通过 self() 函数获取实例。来看看它的构造函数，如下：
ProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver))//访问binder设备，并与binder驱动交互 , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mBinderContextCheckFunc(nullptr) , mBinderContextUserData(nullptr) , mThreadPoolStarted(false) , mThreadPoolSeq(1) , mCallRestriction(CallRestriction::NONE) { // TODO(b/139016109): enforce in build system #if defined(__ANDROID_APEX__) LOG_ALWAYS_FATAL(&#34;Cannot use libbinder in APEX (only system.">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://rong05.github.io/learn/android/android_binder/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0c4fd3725171366f335155acde6fb3c7b7042cd2fd075bebf5023d9b28a701b2.css" integrity="sha256-DE/TclFxNm8zUVWs3m&#43;zx7cELNL9B1vr9QI9myinAbI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://rong05.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rong05.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rong05.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rong05.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rong05.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://rong05.github.io/learn/android/android_binder/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="Binder通讯原理 基于Android 11的源码剖析，笔记记录binder通讯原理的实现过程；
根据网络上的各路大神案例，都是从典型的mediaserver进程开始分析，binder服务的注册注册过程；
mediaserver进程启动的main函数开始分析，至于init.rc的注册启动进程就跳过了；main函数代码如下：
int main(int argc __unused, char **argv __unused) { signal(SIGPIPE, SIG_IGN); //创建与binder驱动交互和binder线程池的管理者 sp&lt;ProcessState&gt; proc(ProcessState::self()); //获取ServiceManager的客户端BpServiceManager sp&lt;IServiceManager&gt; sm(defaultServiceManager()); ALOGI(&#34;ServiceManager: %p&#34;, sm.get()); //创建MediaPlayerService服务，和向ServiceManager注册服务 MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ::android::hardware::configureRpcThreadpool(16, false); //启动binder线程池 ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); ::android::hardware::joinRpcThreadpool(); } Binder线程池的注册 每个采用 Binder 的进程会有一个或多个用于处理接收数据的线程，位于 Binder 线程池。采用 Binder 机制的进程最典型的就是应用程序进程了。那应用程序进程的 Binder 线程池是在什么时候启动的呢？
ProcessState 源码位置：frameworks/native/libs/binder/ProcessState.cpp
ProcessState 是 Binder 机制核心之一，它是 Binder 通信的基础，负责与 Binder 驱动的交互与 Binder 线程池的管理。它实现了单例模式，通过 self() 函数获取实例，每个进程仅有一个。
ProcessState创建 实现了单例模式，通过 self() 函数获取实例。来看看它的构造函数，如下：
ProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver))//访问binder设备，并与binder驱动交互 , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mBinderContextCheckFunc(nullptr) , mBinderContextUserData(nullptr) , mThreadPoolStarted(false) , mThreadPoolSeq(1) , mCallRestriction(CallRestriction::NONE) { // TODO(b/139016109): enforce in build system #if defined(__ANDROID_APEX__) LOG_ALWAYS_FATAL(&#34;Cannot use libbinder in APEX (only system." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rong05.github.io/learn/android/android_binder/" /><meta property="og:image" content="https://rong05.github.io/papermod-cover.png"/><meta property="article:section" content="learn" />



<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://rong05.github.io/papermod-cover.png"/>

<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Binder通讯原理 基于Android 11的源码剖析，笔记记录binder通讯原理的实现过程；
根据网络上的各路大神案例，都是从典型的mediaserver进程开始分析，binder服务的注册注册过程；
mediaserver进程启动的main函数开始分析，至于init.rc的注册启动进程就跳过了；main函数代码如下：
int main(int argc __unused, char **argv __unused) { signal(SIGPIPE, SIG_IGN); //创建与binder驱动交互和binder线程池的管理者 sp&lt;ProcessState&gt; proc(ProcessState::self()); //获取ServiceManager的客户端BpServiceManager sp&lt;IServiceManager&gt; sm(defaultServiceManager()); ALOGI(&#34;ServiceManager: %p&#34;, sm.get()); //创建MediaPlayerService服务，和向ServiceManager注册服务 MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ::android::hardware::configureRpcThreadpool(16, false); //启动binder线程池 ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); ::android::hardware::joinRpcThreadpool(); } Binder线程池的注册 每个采用 Binder 的进程会有一个或多个用于处理接收数据的线程，位于 Binder 线程池。采用 Binder 机制的进程最典型的就是应用程序进程了。那应用程序进程的 Binder 线程池是在什么时候启动的呢？
ProcessState 源码位置：frameworks/native/libs/binder/ProcessState.cpp
ProcessState 是 Binder 机制核心之一，它是 Binder 通信的基础，负责与 Binder 驱动的交互与 Binder 线程池的管理。它实现了单例模式，通过 self() 函数获取实例，每个进程仅有一个。
ProcessState创建 实现了单例模式，通过 self() 函数获取实例。来看看它的构造函数，如下：
ProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver))//访问binder设备，并与binder驱动交互 , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mBinderContextCheckFunc(nullptr) , mBinderContextUserData(nullptr) , mThreadPoolStarted(false) , mThreadPoolSeq(1) , mCallRestriction(CallRestriction::NONE) { // TODO(b/139016109): enforce in build system #if defined(__ANDROID_APEX__) LOG_ALWAYS_FATAL(&#34;Cannot use libbinder in APEX (only system."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Learns",
      "item": "https://rong05.github.io/learn/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://rong05.github.io/learn/android/android_binder/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Binder通讯原理 基于Android 11的源码剖析，笔记记录binder通讯原理的实现过程；\n根据网络上的各路大神案例，都是从典型的mediaserver进程开始分析，binder服务的注册注册过程；\nmediaserver进程启动的main函数开始分析，至于init.rc的注册启动进程就跳过了；main函数代码如下：\nint main(int argc __unused, char **argv __unused) { signal(SIGPIPE, SIG_IGN); //创建与binder驱动交互和binder线程池的管理者 sp\u0026lt;ProcessState\u0026gt; proc(ProcessState::self()); //获取ServiceManager的客户端BpServiceManager sp\u0026lt;IServiceManager\u0026gt; sm(defaultServiceManager()); ALOGI(\u0026#34;ServiceManager: %p\u0026#34;, sm.get()); //创建MediaPlayerService服务，和向ServiceManager注册服务 MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ::android::hardware::configureRpcThreadpool(16, false); //启动binder线程池 ProcessState::self()-\u0026gt;startThreadPool(); IPCThreadState::self()-\u0026gt;joinThreadPool(); ::android::hardware::joinRpcThreadpool(); } Binder线程池的注册 每个采用 Binder 的进程会有一个或多个用于处理接收数据的线程，位于 Binder 线程池。采用 Binder 机制的进程最典型的就是应用程序进程了。那应用程序进程的 Binder 线程池是在什么时候启动的呢？\nProcessState 源码位置：frameworks/native/libs/binder/ProcessState.cpp\nProcessState 是 Binder 机制核心之一，它是 Binder 通信的基础，负责与 Binder 驱动的交互与 Binder 线程池的管理。它实现了单例模式，通过 self() 函数获取实例，每个进程仅有一个。\nProcessState创建 实现了单例模式，通过 self() 函数获取实例。来看看它的构造函数，如下：\nProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver))//访问binder设备，并与binder驱动交互 , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mBinderContextCheckFunc(nullptr) , mBinderContextUserData(nullptr) , mThreadPoolStarted(false) , mThreadPoolSeq(1) , mCallRestriction(CallRestriction::NONE) { // TODO(b/139016109): enforce in build system #if defined(__ANDROID_APEX__) LOG_ALWAYS_FATAL(\u0026#34;Cannot use libbinder in APEX (only system.",
  "keywords": [
    
  ],
  "articleBody": "Binder通讯原理 基于Android 11的源码剖析，笔记记录binder通讯原理的实现过程；\n根据网络上的各路大神案例，都是从典型的mediaserver进程开始分析，binder服务的注册注册过程；\nmediaserver进程启动的main函数开始分析，至于init.rc的注册启动进程就跳过了；main函数代码如下：\nint main(int argc __unused, char **argv __unused) { signal(SIGPIPE, SIG_IGN); //创建与binder驱动交互和binder线程池的管理者 sp\u003cProcessState\u003e proc(ProcessState::self()); //获取ServiceManager的客户端BpServiceManager sp\u003cIServiceManager\u003e sm(defaultServiceManager()); ALOGI(\"ServiceManager: %p\", sm.get()); //创建MediaPlayerService服务，和向ServiceManager注册服务 MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ::android::hardware::configureRpcThreadpool(16, false); //启动binder线程池 ProcessState::self()-\u003estartThreadPool(); IPCThreadState::self()-\u003ejoinThreadPool(); ::android::hardware::joinRpcThreadpool(); } Binder线程池的注册 每个采用 Binder 的进程会有一个或多个用于处理接收数据的线程，位于 Binder 线程池。采用 Binder 机制的进程最典型的就是应用程序进程了。那应用程序进程的 Binder 线程池是在什么时候启动的呢？\nProcessState 源码位置：frameworks/native/libs/binder/ProcessState.cpp\nProcessState 是 Binder 机制核心之一，它是 Binder 通信的基础，负责与 Binder 驱动的交互与 Binder 线程池的管理。它实现了单例模式，通过 self() 函数获取实例，每个进程仅有一个。\nProcessState创建 实现了单例模式，通过 self() 函数获取实例。来看看它的构造函数，如下：\nProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver))//访问binder设备，并与binder驱动交互 , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mBinderContextCheckFunc(nullptr) , mBinderContextUserData(nullptr) , mThreadPoolStarted(false) , mThreadPoolSeq(1) , mCallRestriction(CallRestriction::NONE) { // TODO(b/139016109): enforce in build system #if defined(__ANDROID_APEX__) LOG_ALWAYS_FATAL(\"Cannot use libbinder in APEX (only system.img libbinder) since it is not stable.\"); #endif if (mDriverFD \u003e= 0) { //映射binder驱动，提供通讯的虚拟空间 // mmap the binder, providing a chunk of virtual address space to receive transactions. mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); if (mVMStart == MAP_FAILED) { // *sigh* ALOGE(\"Using %s failed: unable to mmap transaction memory.\\n\", mDriverName.c_str()); close(mDriverFD); mDriverFD = -1; mDriverName.clear(); } } #ifdef __ANDROID__ LOG_ALWAYS_FATAL_IF(mDriverFD \u003c 0, \"Binder driver '%s' could not be opened. Terminating.\", driver); #endif } ProcessState创建是主要步骤是：\n访问binder设备，并与binder驱动交互； 映射binder驱动，提供通讯基础的虚拟空间； 其中提供通讯基础的虚拟空间默认大小是由BINDER_VM_SIZE这个宏来决定的，宏定义如下：\n//binder分配的默认内存大小为1M-8k #define BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2) 下面来主要看看open_driver函数，函数内容如下：\nstatic int open_driver(const char *driver) { int fd = open(driver, O_RDWR | O_CLOEXEC);//访问binder设备 if (fd \u003e= 0) { int vers = 0; status_t result = ioctl(fd, BINDER_VERSION, \u0026vers);//进行版本比对 if (result == -1) { ALOGE(\"Binder ioctl to obtain version failed: %s\", strerror(errno)); close(fd); fd = -1; } if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) { ALOGE(\"Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d\", vers, BINDER_CURRENT_PROTOCOL_VERSION, result); close(fd); fd = -1; } size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, \u0026maxThreads);//设置binder线程池最大线程数 if (result == -1) { ALOGE(\"Binder ioctl to set max threads failed: %s\", strerror(errno)); } } else { ALOGW(\"Opening '%s' failed: %s\\n\", driver, strerror(errno)); } return fd; } 在open_driver函数中主要处理：\n访问binder设备，通过open函数来实现，具体现在不做详细说明；\n通过ioctl进行binder的版本比较\n通知binder驱动binder线程池的默认最大线程数，而这个最大线程数由DEFAULT_MAX_BINDER_THREADS宏来决定；宏定义如下：\n//默认binder线程池的最大线程数,那加上本身binder默认的最大可并发访问的线程数为16 #define DEFAULT_MAX_BINDER_THREADS 15 启动binder线程池 ProcessState 实例后调用其 startThreadPool 函数，以启动进程的 Binder 线程池。\nvoid ProcessState::startThreadPool() { AutoMutex _l(mLock); if (!mThreadPoolStarted) { mThreadPoolStarted = true; spawnPooledThread(true); } } void ProcessState::spawnPooledThread(bool isMain) { if (mThreadPoolStarted) { String8 name = makeBinderThreadName(); ALOGV(\"Spawning new pooled thread, name=%s\\n\", name.string()); sp\u003cThread\u003e t = new PoolThread(isMain);//创建线程 t-\u003erun(name.string());//启动线程 } } mThreadPoolStarted 用于标识线程池是否已经启动过，以确保 Binder 线程池仅初始化一次。spawnPooledThread() 函数启动了一个 Binder 线程，类型为 PoolThread，函数参数表示这是 Binder 线程池中的第一线程。\nclass PoolThread : public Thread { public: explicit PoolThread(bool isMain) : mIsMain(isMain) { } protected: //PoolThread继承Thread类。t-\u003erun()方法最终调用内部类 PoolThread的threadLoop()方法。 virtual bool threadLoop() { IPCThreadState::self()-\u003ejoinThreadPool(mIsMain); return false; } const bool mIsMain; }; PoolThread继承Thread类。t-\u003erun()方法最终调用内部类 PoolThread的threadLoop()方法。在主要创建了IPCThreadState和执行了IPCThreadState的joinThreadPool函数；\n在mediaserver的main函数中后面又执行了一次IPCThreadState的joinThreadPool函数，这两次的区别是一个在子线程执行，一个是在进程主线程执行，**mediaserver默认binder的事件监听线程数是2吗？**这样binder线程池算基本完成！\nIPCThreadState 源码位置：frameworks/native/libs/binder/IPCThreadState.cpp\nIPCThreadState 同样是 Binder 机制的核心之一，它用于管理与 Binder 通信相关线程的状态，每个 Binder 线程都会通过此将自己注册到 Binder 驱动。一个具有多个线程的进程里应该会有多个IPCThreadState对象了，只不过每个线程只需一个IPCThreadState对象而已。所以要放在binder线程池中统一管理。\nIPCThreadState创建 IPCThreadState同样是通过 self() 函数获取实例的。\nIPCThreadState* IPCThreadState::self() { if (gHaveTLS.load(std::memory_order_acquire)) { restart: const pthread_key_t k = gTLS; //获取当前线程是否创建了IPCThreadState，如果创建了直接返回,类似Looper里的ThreadLocal IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); if (st) return st; return new IPCThreadState; } // Racey, heuristic test for simultaneous shutdown. if (gShutdown.load(std::memory_order_relaxed)) { ALOGW(\"Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\\n\"); return nullptr; } pthread_mutex_lock(\u0026gTLSMutex); if (!gHaveTLS.load(std::memory_order_relaxed)) { //创建线程唯一的标签 int key_create_value = pthread_key_create(\u0026gTLS, threadDestructor); if (key_create_value != 0) { pthread_mutex_unlock(\u0026gTLSMutex); ALOGW(\"IPCThreadState::self() unable to create TLS key, expect a crash: %s\\n\", strerror(key_create_value)); return nullptr; } gHaveTLS.store(true, std::memory_order_release); } pthread_mutex_unlock(\u0026gTLSMutex); goto restart;//回到开始根据线程唯一标记创建IPCThreadState } self() 函数是一个工厂函数，用于获取 IPCThreadState 实例。self() 根据 pthread_getspecific() 管理每个参与 Binder 通信线程的实例，类似Looper里的ThreadLocal，每个参与 Binder 通信的线程其 IPCThreadState 对象都是相互独立的，保证了后续操作的线程安全。构造函数内容其实，很简单主要是绑定线程唯一标记和初始化输入输出缓冲区；\nIPCThreadState::IPCThreadState() : mProcess(ProcessState::self()), mServingStackPointer(nullptr), mWorkSource(kUnsetWorkSource), mPropagateWorkSource(false), mStrictModePolicy(0), mLastTransactionBinderFlags(0), mCallRestriction(mProcess-\u003emCallRestriction) { //将线程唯一标签保存的内容设置为自身 pthread_setspecific(gTLS, this); //获取当前进程的pid和uid信息 clearCaller(); //设置输入缓冲区大小，默认256 mIn.setDataCapacity(256); //设置输出缓冲区大小，默认256 mOut.setDataCapacity(256); } IPCThreadState::joinThreadPool函数 joinThreadPool函数就是一个死循环，不断从驱动获取数据;\nvoid IPCThreadState::joinThreadPool(bool isMain) { LOG_THREADPOOL(\"**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\\n\", (void*)pthread_self(), getpid()); mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER); status_t result; do { //清除上一次通讯的输入缓冲区 processPendingDerefs(); //处理下一条信息或者等待 // now get the next command to be processed, waiting if necessary result = getAndExecuteCommand(); if (result \u003c NO_ERROR \u0026\u0026 result != TIMED_OUT \u0026\u0026 result != -ECONNREFUSED \u0026\u0026 result != -EBADF) { LOG_ALWAYS_FATAL(\"getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting\", mProcess-\u003emDriverFD, result); } // Let this thread exit the thread pool if it is no longer // needed and it is not the main process thread. if(result == TIMED_OUT \u0026\u0026 !isMain) { break; } } while (result != -ECONNREFUSED \u0026\u0026 result != -EBADF); LOG_THREADPOOL(\"**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%d\\n\", (void*)pthread_self(), getpid(), result); mOut.writeInt32(BC_EXIT_LOOPER); talkWithDriver(false); } 如此看来IPCThreadState是通过getAndExecuteCommand来不断获取通讯数据的；\nstatus_t IPCThreadState::getAndExecuteCommand() { status_t result; int32_t cmd; //从bender驱动中获取数据 result = talkWithDriver(); if (result \u003e= NO_ERROR) { size_t IN = mIn.dataAvail(); if (IN \u003c sizeof(int32_t)) return result; cmd = mIn.readInt32();//读取命令字段 IF_LOG_COMMANDS() { alog \u003c\u003c \"Processing top-level Command: \" \u003c\u003c getReturnString(cmd) \u003c\u003c endl; } pthread_mutex_lock(\u0026mProcess-\u003emThreadCountLock); mProcess-\u003emExecutingThreadsCount++; if (mProcess-\u003emExecutingThreadsCount \u003e= mProcess-\u003emMaxThreads \u0026\u0026 mProcess-\u003emStarvationStartTimeMs == 0) { mProcess-\u003emStarvationStartTimeMs = uptimeMillis(); } pthread_mutex_unlock(\u0026mProcess-\u003emThreadCountLock); //进行binder命令解析 result = executeCommand(cmd); pthread_mutex_lock(\u0026mProcess-\u003emThreadCountLock); mProcess-\u003emExecutingThreadsCount--; if (mProcess-\u003emExecutingThreadsCount \u003c mProcess-\u003emMaxThreads \u0026\u0026 mProcess-\u003emStarvationStartTimeMs != 0) { int64_t starvationTimeMs = uptimeMillis() - mProcess-\u003emStarvationStartTimeMs; if (starvationTimeMs \u003e 100) { ALOGE(\"binder thread pool (%zu threads) starved for %\" PRId64 \" ms\", mProcess-\u003emMaxThreads, starvationTimeMs); } mProcess-\u003emStarvationStartTimeMs = 0; } pthread_cond_broadcast(\u0026mProcess-\u003emThreadCountDecrement); pthread_mutex_unlock(\u0026mProcess-\u003emThreadCountLock); } return result; } getAndExecuteCommand的执行步骤：\n通过talkWithDriver向binder驱动获取通讯数据； 读取命令字段，并通过executeCommand函数进行不同命令字段的解析和处理 获取ServiceManager 获取Service Manager是通过defaultServiceManager方法来完成，当进程注册服务(addService)或 获取服务(getService)的过程之前，都需要先调用defaultServiceManager()方法来获取gDefaultServiceManager对象。\n大概流程图如下：\ndefaultServiceManager函数代码如下：\nsp\u003cIServiceManager\u003e defaultServiceManager() { std::call_once(gSmOnce, []() { sp\u003cAidlServiceManager\u003e sm = nullptr; //避免ServiceManager未启动完成，重复请求 while (sm == nullptr) { //获取BpServiceManager sm = interface_cast\u003cAidlServiceManager\u003e(ProcessState::self()-\u003egetContextObject(nullptr)); if (sm == nullptr) { ALOGE(\"Waiting 1s on context object on %s.\", ProcessState::self()-\u003egetDriverName().c_str()); sleep(1); } } //创建BpServiceManager代理对象 gDefaultServiceManager = new ServiceManagerShim(sm); }); return gDefaultServiceManager; } ServiceManager的对象获取也采用了一个单例模式，一个进程中只要获取一次即可，对象存储在gDefaultServiceManager中。\n主要流程如下：\n获取ProcessState对象—ProcessState::self()，在上面的流程中可知ProcessState已获取，存入了全局变量中 获取BpBinder对象 –ProcessState::getContextObject(nullptr) 获取BpServiceManager对象—-interface_cast 创建ServiceManagerShim对象对BpServiceManager对象进行接管 在ProcessState::getContextObject(nullptr)函数中，主要调用getStrongProxyForHandle进行处理，传入handle=0，那主要看看getStrongProxyForHandle函数；\nsp\u003cIBinder\u003e ProcessState::getStrongProxyForHandle(int32_t handle) { sp\u003cIBinder\u003e result; AutoMutex _l(mLock); //查找handle对应的资源项 handle_entry* e = lookupHandleLocked(handle); if (e != nullptr) { // We need to create a new BpBinder if there isn't currently one, OR we // are unable to acquire a weak reference on this current one. The // attemptIncWeak() is safe because we know the BpBinder destructor will always // call expungeHandle(), which acquires the same lock we are holding now. // We need to do this because there is a race condition between someone // releasing a reference on this BpBinder, and a new reference on its handle // arriving from the driver. IBinder* b = e-\u003ebinder; if (b == nullptr || !e-\u003erefs-\u003eattemptIncWeak(this)) { if (handle == 0) { // Special case for context manager... // The context manager is the only object for which we create // a BpBinder proxy without already holding a reference. // Perform a dummy transaction to ensure the context manager // is registered before we create the first local reference // to it (which will occur when creating the BpBinder). // If a local reference is created for the BpBinder when the // context manager is not present, the driver will fail to // provide a reference to the context manager, but the // driver API does not return status. // // Note that this is not race-free if the context manager // dies while this code runs. // // TODO: add a driver API to wait for context manager, or // stop special casing handle 0 for context manager and add // a driver API to get a handle to the context manager with // proper reference counting. Parcel data; //测试binder是否准备就绪 status_t status = IPCThreadState::self()-\u003etransact( 0, IBinder::PING_TRANSACTION, data, nullptr, 0); if (status == DEAD_OBJECT) return nullptr; } //当handle值所对应的IBinder不存在或弱引用无效时，创建一个BpBinder，handle=0 //create的实现其实就是 new BpBinder(0,trackedUid) b = BpBinder::create(handle); e-\u003ebinder = b; if (b) e-\u003erefs = b-\u003egetWeakRefs(); result = b; } else { // This little bit of nastyness is to allow us to add a primary // reference to the remote proxy when this team doesn't have one // but another team is sending the handle to us. result.force_set(b); e-\u003erefs-\u003edecWeak(this); } } return result; } getStrongProxyForHandle的过程也很简单，当handle=0所对应的IBinder不存在或弱引用无效时，先看下Binder是否已经准备就绪，即ServiceManager是否已经就绪，准备好后，创建一个BpBinder(0,trackedUid)，创建BpBinder对象中会将handle相对应Binder的弱引用增加1，最终返回一个BpBiner的对象。\n真正获取ServiceManager的代理对象的是 interface_cast 方法。零号引用的 BpBinder 对象传入 interface_cast() 模版函数，会最终通过 IMPLEMENT_META_INTERFACE() 宏，生成 BpServiceManager 对象。该对象被传入 ServiceManagerShim 的构造函数中，成为其成员变量 mTheRealServiceManager。\n#define DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)\\ const ::android::StaticString16 \\ I##INTERFACE##_descriptor_static_str16(__IINTF_CONCAT(u, NAME));\\ const ::android::String16 I##INTERFACE::descriptor( \\ I##INTERFACE##_descriptor_static_str16); \\ const ::android::String16\u0026 \\ I##INTERFACE::getInterfaceDescriptor() const { \\ return I##INTERFACE::descriptor; \\ } \\ ::android::sp I##INTERFACE::asInterface( \\ const ::android::sp\u003c::android::IBinder\u003e\u0026 obj) \\ { \\ ::android::sp intr; \\ if (obj != nullptr) { \\ intr = static_cast( \\ obj-\u003equeryLocalInterface( \\ I##INTERFACE::descriptor).get()); \\ if (intr == nullptr) { \\ intr = new Bp##INTERFACE(obj); \\ } \\ } \\ return intr; \\ } \\ std::unique_ptr I##INTERFACE::default_impl; \\ bool I##INTERFACE::setDefaultImpl(std::unique_ptr impl)\\ { \\ /* Only one user of this interface can use this function */ \\ /* at a time. This is a heuristic to detect if two different */ \\ /* users in the same process use this function. */ \\ assert(!I##INTERFACE::default_impl); \\ if (impl) { \\ I##INTERFACE::default_impl = std::move(impl); \\ return true; \\ } \\ return false; \\ } \\ const std::unique_ptr\u0026 I##INTERFACE::getDefaultImpl() \\ { \\ return I##INTERFACE::default_impl; \\ } \\ I##INTERFACE::I##INTERFACE() { } \\ I##INTERFACE::~I##INTERFACE() { } \\ Android 10在此之后，BpServiceManager 不再通过手动实现，而是采用 AIDL（文件为 IServiceManager.aidl），生成 IServiceManager、BnServiceManager、BpServiceManager 的头文件及具体实现。\n关于通过 AIDL 生成 C++ 代码，详见 Generating C++ Binder Interfaces with aidl-cpp\nBpServiceManager的继承关系图如下：\nBinder 数据传输流程 Binder 数据发送过程 从addService函数来分析Binder的数据传输流程；从获取servicemanage的章节我们得知，servicemanage的Client端是BpServiceManager，那我们直接来看BpServiceManager中的addService函数，如下：\nvirtual status_t addService(const String16\u0026 name, const sp\u003cIBinder\u003e\u0026 service, bool allowIsolated, int dumpsysPriority) { Parcel data, reply; data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); data.writeStrongBinder(service); data.writeInt32(allowIsolated ? 1 : 0); data.writeInt32(dumpsysPriority); status_t err = remote()-\u003etransact(ADD_SERVICE_TRANSACTION, data, \u0026reply); return err == NO_ERROR ? reply.readExceptionCode() : err; } //Parcel status_t Parcel::writeStrongBinder(const sp\u003cIBinder\u003e\u0026 val) { return flattenBinder(val); } status_t Parcel::flattenBinder(const sp\u003cIBinder\u003e\u0026 binder) { flat_binder_object obj; if (IPCThreadState::self()-\u003ebackgroundSchedulingDisabled()) { /* minimum priority for all nodes is nice 0 */ obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS; } else { /* minimum priority for all nodes is MAX_NICE(19) */ obj.flags = 0x13 | FLAT_BINDER_FLAG_ACCEPTS_FDS; } if (binder != nullptr) { BBinder *local = binder-\u003elocalBinder(); if (!local) { BpBinder *proxy = binder-\u003eremoteBinder(); if (proxy == nullptr) { ALOGE(\"null proxy\"); } const int32_t handle = proxy ? proxy-\u003ehandle() : 0; obj.hdr.type = BINDER_TYPE_HANDLE; obj.binder = 0; /* Don't pass uninitialized stack data to a remote process */ obj.handle = handle; obj.cookie = 0; } else { if (local-\u003eisRequestingSid()) { obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX; } obj.hdr.type = BINDER_TYPE_BINDER;//type被赋值为BINDER_TYPE_BINDER，即表示此时的obj是一个Binder实体对象 obj.binder = reinterpret_cast\u003cuintptr_t\u003e(local-\u003egetWeakRefs());//记录Binder弱引用指针地址 obj.cookie = reinterpret_cast\u003cuintptr_t\u003e(local);//记录Binder实体的指针 } } else { obj.hdr.type = BINDER_TYPE_BINDER; obj.binder = 0; obj.cookie = 0; } return finishFlattenBinder(binder, obj); } 从代码分析Parcel通过writeStrongBinder函数把service封装成flat_binder_object结构体，其中保存了service的Binder弱引用指针地址和Binder实体的指针；flat_binder_object结构体定义如下：\nstruct flat_binder_object { struct binder_object_header\thdr; __u32\tflags; /* 8 bytes of data. */ union { binder_uintptr_t\tbinder;\t/* local object *///记录Binder弱引用指针地址 __u32\thandle;\t/* remote object *///这个在binder驱动中查找Binder弱引用指针用的关键key，目前这样理解 }; /* extra data associated with local object */ binder_uintptr_t\tcookie;//记录binder的实体指针 }; remote()-\u003etransact()将传出，从defaultServiceManager分析总结remote对应的是在getStrongProxyForHandle函数中创建的BpBinder;而在BpBinder的transact函数中，主要是执行了status_t status = IPCThreadState::self()-\u003etransact( mHandle, code, data, reply, flags);,接下来我们就分析一下IPCThreadState的transact函数；\nstatus_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel\u0026 data, Parcel* reply, uint32_t flags) { status_t err; flags |= TF_ACCEPT_FDS; IF_LOG_TRANSACTIONS() { TextOutput::Bundle _b(alog); alog \u003c\u003c \"BC_TRANSACTION thr \" \u003c\u003c (void*)pthread_self() \u003c\u003c \" / hand \" \u003c\u003c handle \u003c\u003c \" / code \" \u003c\u003c TypeCode(code) \u003c\u003c \": \" \u003c\u003c indent \u003c\u003c data \u003c\u003c dedent \u003c\u003c endl; } LOG_ONEWAY(\"\u003e\u003e\u003e\u003e SEND from pid %d uid %d %s\", getpid(), getuid(), (flags \u0026 TF_ONE_WAY) == 0 ? \"READ REPLY\" : \"ONE WAY\"); //将数据打包塞到 mOut 里 err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, nullptr); if (err != NO_ERROR) { if (reply) reply-\u003esetError(err); return (mLastError = err); } if ((flags \u0026 TF_ONE_WAY) == 0) { if (UNLIKELY(mCallRestriction != ProcessState::CallRestriction::NONE)) { if (mCallRestriction == ProcessState::CallRestriction::ERROR_IF_NOT_ONEWAY) { ALOGE(\"Process making non-oneway call (code: %u) but is restricted.\", code); CallStack::logStack(\"non-oneway call\", CallStack::getCurrent(10).get(), ANDROID_LOG_ERROR); } else /* FATAL_IF_NOT_ONEWAY */ { LOG_ALWAYS_FATAL(\"Process may not make oneway calls (code: %u).\", code); } } #if 0 if (code == 4) { // relayout ALOGI(\"\u003e\u003e\u003e\u003e\u003e\u003e CALLING transaction 4\"); } else { ALOGI(\"\u003e\u003e\u003e\u003e\u003e\u003e CALLING transaction %d\", code); } #endif if (reply) { //不是 one way 调用，需要等待回复 err = waitForResponse(reply); } else {//one way 调用，不用等待回复 Parcel fakeReply; err = waitForResponse(\u0026fakeReply); } #if 0 if (code == 4) { // relayout ALOGI(\"\u003c\u003c\u003c\u003c\u003c\u003c RETURNING transaction 4\"); } else { ALOGI(\"\u003c\u003c\u003c\u003c\u003c\u003c RETURNING transaction %d\", code); } #endif IF_LOG_TRANSACTIONS() { TextOutput::Bundle _b(alog); alog \u003c\u003c \"BR_REPLY thr \" \u003c\u003c (void*)pthread_self() \u003c\u003c \" / hand \" \u003c\u003c handle \u003c\u003c \": \"; if (reply) alog \u003c\u003c indent \u003c\u003c *reply \u003c\u003c dedent \u003c\u003c endl; else alog \u003c\u003c \"(none requested)\" \u003c\u003c endl; } } else { err = waitForResponse(nullptr, nullptr); } return err; } IPCThreadState 中有 mIn、mOut 两个 Parcel 数据，mIn 用来存放从别处读取而来的数据，mOut 存放要写入到别处的数据，而在transact函数中关键代码只有两行（writeTransactionData和waitForResponse），从命名上来看就是一次请求和接收应答的过程。在 writeTransactionData函数中将一堆参数组装进binder_transaction_data结构体并存放到 mOut，准备写入到 binder 驱动;\nstatus_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel\u0026 data, status_t* statusBuffer) { binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; //检查数据是否有效 const status_t err = data.errorCheck(); if (err == NO_ERROR) { tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); } else if (statusBuffer) { tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast\u003cuintptr_t\u003e(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; } else { return (mLastError = err); } mOut.writeInt32(cmd); mOut.write(\u0026tr, sizeof(tr)); return NO_ERROR; } binder_transaction_data结构体在中组装的Parcel数据：\n​\t图片来源\nbinder_transaction_data结构体定义如下：\nstruct binder_transaction_data { /* The first two are only used for bcTRANSACTION and brTRANSACTION, * identifying the target and contents of the transaction. */ union { /* target descriptor of command transaction */ __u32\thandle; /* target descriptor of return transaction */ binder_uintptr_t ptr; } target; binder_uintptr_t\tcookie;\t/* target object cookie */ __u32\tcode;\t/* transaction command */ /* General information about the transaction. */ __u32\tflags; pid_t\tsender_pid; uid_t\tsender_euid; binder_size_t\tdata_size;\t/* number of bytes of data */ binder_size_t\toffsets_size;\t/* number of bytes of offsets */ /* If this transaction is inline, the data immediately * follows here; otherwise, it ends with a pointer to * the data buffer. */ union { struct { /* transaction data */ binder_uintptr_t\tbuffer; /* offsets from buffer to flat_binder_object structs */ binder_uintptr_t\toffsets; } ptr; __u8\tbuf[8]; } data; }; waitForResponse函数去实际执行写入到 binder 驱动，简化后的 waitForResponse函数代码如下:\nstatus_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult) { uint32_t cmd; int32_t err; while (1) { //进一步调用 talkWithDriver 去执行写入数据到 binder 驱动 if ((err=talkWithDriver()) \u003c NO_ERROR) break; err = mIn.errorCheck();//检查数据有效性 if (err \u003c NO_ERROR) break; if (mIn.dataAvail() == 0) continue;//检查数据有效性 cmd = (uint32_t)mIn.readInt32();//拿到 binder 驱动发过来的命令 switch (cmd) { //处理命令 case BR_TRANSACTION_COMPLETE: if (!reply \u0026\u0026 !acquireResult) goto finish; break; case BR_DEAD_REPLY: err = DEAD_OBJECT; goto finish; case BR_FAILED_REPLY: err = FAILED_TRANSACTION; goto finish; case BR_ACQUIRE_RESULT: { ... } goto finish; case BR_REPLY: { ... } goto finish; default://其他命令在 executeCommand 方法中处理 err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; } } finish: if (err != NO_ERROR) { if (acquireResult) *acquireResult = err; if (reply) reply-\u003esetError(err); mLastError = err; } return err; } 可以看到 waitForResponse中并没有直接执行写入数据到 binder，而是进一步调用 talkWithDriver 去处理，随后 waitForResponse处理了由 binder 驱动发送过来的命令,因为在BpServiceManager传过来的reply不等于空，所以正常的逻辑是收到BR_REPLY才退出循环；\n由 transact到 waitForResponse，已经将要发送的数据准备好，并对后续 binder 驱动的回复也做了处理，但还没看到真正写入数据给 binder 驱动的代码，但已经知道就在 talkWithDriver函数中，此函数中主要做了三个工作：\n将要发送的数据封装成binder_write_read结构体； 通过ioctl把binder_write_read结构体数据写入binder驱动； 处理驱动回复 status_t IPCThreadState::talkWithDriver(bool doReceive) { //binder驱动是否打开 if (mProcess-\u003emDriverFD \u003c 0) { return -EBADF; } //binder 驱动接受的数据格式 binder_write_read bwr; // Is the read buffer empty? const bool needRead = mIn.dataPosition() \u003e= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; //要写入的数据量 bwr.write_buffer = (uintptr_t)mOut.data(); //要写入的数据 // This is what we'll read. if (doReceive \u0026\u0026 needRead) { bwr.read_size = mIn.dataCapacity();//要读取的数据量 bwr.read_buffer = (uintptr_t)mIn.data();//存放读取数据的内存空间 } else { bwr.read_size = 0; bwr.read_buffer = 0; } // Return immediately if there is nothing to do. if ((bwr.write_size == 0) \u0026\u0026 (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do { #if defined(__ANDROID__) //通过ioctl写入binder驱动 if (ioctl(mProcess-\u003emDriverFD, BINDER_WRITE_READ, \u0026bwr) \u003e= 0) err = NO_ERROR; else err = -errno; #else err = INVALID_OPERATION; #endif if (mProcess-\u003emDriverFD \u003c 0) { err = -EBADF; } } while (err == -EINTR); if (err \u003e= NO_ERROR) { if (bwr.write_consumed \u003e 0) { //成功写入了数据 if (bwr.write_consumed \u003c mOut.dataSize()) else { //输出数据已经写入binder驱动，清空输出缓冲区 mOut.setDataSize(0); processPostWriteDerefs(); } } //存在回传数据，重置输入缓冲区的读取下标 if (bwr.read_consumed \u003e 0) {//成功读取到了数据 mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); } return NO_ERROR; } return err; } 在IPCThreadState.h定义talkWithDriver 函数时，doReceive的默认值为true,waitForResponse() 中没有传入参数，所以这里的 doReceive 为 true。\nstatus_t talkWithDriver(bool doReceive=true); binder_write_read 是 binder 驱动与用户态共用的、存储读写操作的结构体，在 binder 驱动内部依赖 binder_write_read 决定是要读取还是写入数据：其内部变量 read_size\u003e0 则代表要读取数据，write_size\u003e0 代表要写入数据，若都大于 0 则先写入，后读取。binder_write_read结构体定义如下：\nstruct binder_write_read { binder_size_t\twrite_size;\t/* bytes to write */ //要写入的字节数,write_buffer的总字节数 binder_size_t\twrite_consumed;\t/* bytes consumed by driver *///驱动程序占用的字节数,write_buffer已消费的字节数 binder_uintptr_t\twrite_buffer;//写缓冲数据的指针 binder_size_t\tread_size;\t/* bytes to read *///要读的字节数,read_buffer的总字节数 binder_size_t\tread_consumed;\t/* bytes consumed by driver *///驱动程序占用的字节数,read_buffer已消费的字节数 binder_uintptr_t\tread_buffer;//读缓存数据的指针 }; 这样基本完成了数据的发送过程，其中主要的数据类型结构体一定要记住，很重要；\nflat_binder_object封装service的结构体，其中重要的参数是binder、handle、cookie binder_transaction_data组装Parcel数据的结构体; binder_write_read 是binder 驱动与用户态共用的、存储读写操作的结构体 Binder 数据接收过程 Binder 线程用于在 Server 中接收处理从 Binder 驱动发送来的数据。startThreadPool提及的函数 IPCThreadState.joinThreadPool 将自己注册到 Binder 线程池，等待接收数据。\n在joinThreadPool 函数中，循环执行getAndExecuteCommand,调用 talkWithDriver 从 mIn 窗口解析出需要执行的命令后，执行 executeCommand。在executeCommand的BR_TRANSACTION分支，其中 the_context_object 为 BBinder 对象，也就是 Server 的 Binder 本体。BBinder.transact 会再调用 BBinder.onTransact 函数，实现 Server 进程 Binder 的调用。\n而在ServiceManager采用了LooperCallback方式监听binder数据，最终也是循环执行getAndExecuteCommand；这部分的分析会在创建ServiceManager进程详细分析；\n接收数据时也在talkWithDriver中ioctl读写获取一个binder_write_read结构体，在executeCommand的BR_TRANSACTION分支中在把数据进一步解析binder_transaction_data结构体并将相应的输入数据转换buffer，buffer是Parcel对象，在 BBinder 的onTransact函数会在BnServiceManager重载onTransact函数；\nstatus_t BnServiceManager::onTransact( uint32_t code, const Parcel\u0026 data, Parcel* reply, uint32_t flags) { //printf(\"ServiceManager received: \"); data.print(); switch(code) { case GET_SERVICE_TRANSACTION: { CHECK_INTERFACE(IServiceManager, data, reply); String16 which = data.readString16(); sp\u003cIBinder\u003e b = const_cast\u003cBnServiceManager*\u003e(this)-\u003egetService(which); reply-\u003ewriteStrongBinder(b); return NO_ERROR; } break; case CHECK_SERVICE_TRANSACTION: { CHECK_INTERFACE(IServiceManager, data, reply); String16 which = data.readString16(); sp\u003cIBinder\u003e b = const_cast\u003cBnServiceManager*\u003e(this)-\u003echeckService(which); reply-\u003ewriteStrongBinder(b); return NO_ERROR; } break; case ADD_SERVICE_TRANSACTION: { CHECK_INTERFACE(IServiceManager, data, reply); String16 which = data.readString16(); sp\u003cIBinder\u003e b = data.readStrongBinder(); status_t err = addService(which, b); reply-\u003ewriteInt32(err); return NO_ERROR; } break; case LIST_SERVICES_TRANSACTION: { CHECK_INTERFACE(IServiceManager, data, reply); Vector\u003cString16\u003e list = listServices(); const size_t N = list.size(); reply-\u003ewriteInt32(N); for (size_t i=0; i\u003cN; i++) { reply-\u003ewriteString16(list[i]); } return NO_ERROR; } break; default: return BBinder::onTransact(code, data, reply, flags); } } 在ADD_SERVICE_TRANSACTION分支，会通过Parcel的readStrongBinder函数将数据读取flat_binder_object结构体，再获取IBinder弱引用指针地址；其中主要执行的函数是unflattenBinder;\nstatus_t Parcel::unflattenBinder(sp\u003cIBinder\u003e* out) const { const flat_binder_object* flat = readObject(false); if (flat) { switch (flat-\u003ehdr.type) { case BINDER_TYPE_BINDER: { sp\u003cIBinder\u003e binder = reinterpret_cast\u003cIBinder*\u003e(flat-\u003ecookie); return finishUnflattenBinder(binder, out); } case BINDER_TYPE_HANDLE: { sp\u003cIBinder\u003e binder = ProcessState::self()-\u003egetStrongProxyForHandle(flat-\u003ehandle); return finishUnflattenBinder(binder, out); } } } return BAD_TYPE; } 最后会调用ServiceManager的addService函数；\nStatus ServiceManager::addService(const std::string\u0026 name, const sp\u003cIBinder\u003e\u0026 binder, bool allowIsolated, int32_t dumpPriority) { auto ctx = mAccess-\u003egetCallingContext(); // apps cannot add services if (multiuser_get_app_id(ctx.uid) \u003e= AID_APP) { return Status::fromExceptionCode(Status::EX_SECURITY); } if (!mAccess-\u003ecanAdd(ctx, name)) { return Status::fromExceptionCode(Status::EX_SECURITY); } if (binder == nullptr) { return Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT); } if (!isValidServiceName(name)) { LOG(ERROR) \u003c\u003c \"Invalid service name: \" \u003c\u003c name; return Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT); } // implicitly unlinked when the binder is removed if (binder-\u003eremoteBinder() != nullptr \u0026\u0026 binder-\u003elinkToDeath(this) != OK) { LOG(ERROR) \u003c\u003c \"Could not linkToDeath when adding \" \u003c\u003c name; return Status::fromExceptionCode(Status::EX_ILLEGAL_STATE); } auto entry = mNameToService.emplace(name, Service { .binder = binder, .allowIsolated = allowIsolated, .dumpPriority = dumpPriority, .debugPid = ctx.debugPid, }); auto it = mNameToRegistrationCallback.find(name); if (it != mNameToRegistrationCallback.end()) { for (const sp\u003cIServiceCallback\u003e\u0026 cb : it-\u003esecond) { entry.first-\u003esecond.guaranteeClient = true; // permission checked in registerForNotifications cb-\u003eonRegistration(name, binder); } } return Status::ok(); } addService函数中主要执行的是将Ibinder对象封装成Service结构体，并于name为key插入mNameToService中，而mNameToService是一个std::map；这样addService在除了内核部分的代码算是基本完成;binder驱动中的数据传递会在binder驱动分析中进行解析；\n数据传递过程如下：\nServiceManager进程创建 启动的main函数在frameworks/native/cmds/servicemanager/main.cpp中，其中关键步骤和media进行类型；\n创建ProcessState,ServiceManager进程没有调用self，而是通过initWithDriver 创建，其实关键代码还是一样的，实现了单例模式，通过initWithDriver 获取实例；并通过setThreadPoolMaxThreadCount设置最大线程数为0； 创建ServiceManager实例，同样使用addService函数同样把ServiceManager插入mNameToService中；并创建IPCThreadState实通过setTheContextObject设置the_context_object为ServiceManager ; 通过ProcessState的becomeContextManager函数设置ServiceManager进程为binder驱动的上下文管理者； 通过Looper::prepare创建Looper,Looper也是和IPCThreadState一样线程单例，这里可以理解成是java中handle事件中的looper,后续会再对native层的Looper进行详细分析；并BinderCallback的setupTo注册Looper的事件监听和ClientCallbackCallback的setupTo注册Looper的事件； 进入死循环，调用 looper-\u003epollAll函数，实则是在epoll_wait等待消息; int main(int argc, char** argv) { if (argc \u003e 2) { LOG(FATAL) \u003c\u003c \"usage: \" \u003c\u003c argv[0] \u003c\u003c \" [binder driver]\"; } const char* driver = argc == 2 ? argv[1] : \"/dev/binder\"; //创建ProcessState，并打开binder驱动 sp\u003cProcessState\u003e ps = ProcessState::initWithDriver(driver); //设置最大线程数为了0 ps-\u003esetThreadPoolMaxThreadCount(0); ps-\u003esetCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY); //创建ServiceManager实例 sp\u003cServiceManager\u003e manager = new ServiceManager(std::make_unique\u003cAccess\u003e()); if (!manager-\u003eaddService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) { LOG(ERROR) \u003c\u003c \"Could not self register servicemanager\"; } //创建IPCThreadState实例和设置IPCThreadState的上下文管理者 IPCThreadState::self()-\u003esetTheContextObject(manager); //设置ServiceManager进程为binder的上下文管理者 ps-\u003ebecomeContextManager(nullptr, nullptr); //创建looper sp\u003cLooper\u003e looper = Looper::prepare(false /*allowNonCallbacks*/); //创建looper事件监听回调 BinderCallback::setupTo(looper); //把ClientCallbackCallback作为回调，注册进入Lopper，其中创建了一个定时器对象，5秒跑一次 ClientCallbackCallback::setupTo(looper, manager); while(true) { //循环等待驱动是否有事件返回 looper-\u003epollAll(-1); } // should not be reached return EXIT_FAILURE; } 再BinderCallback中如果有事件返回会回调handleEvent，然后执行IPCThreadState::handlePolledCommands;再看看handlePolledCommands函数中执行了getAndExecuteCommand;getAndExecuteCommand在IPCThreadState::joinThreadPool函数中已经提到过了，是用于读取binder驱动的数据和命令字段的解析处理；\nstatus_t IPCThreadState::handlePolledCommands() { status_t result; //读取binder驱动数据，命令字段解析和处理 do { result = getAndExecuteCommand(); } while (mIn.dataPosition() \u003c mIn.dataSize()); //清空输入缓冲区 processPendingDerefs(); //执行完成指令，并把Client需要应答的参数写入binder驱动中 flushCommands(); return result; } 这样ServiceManager进程的启动和消息监听也就分析完成了！\n那我们要想想\nbinder驱动是如果把Client端的数据进行一次拷贝到ServiceManager进程中来读取的呢？ ServiceManager进程又是如何成为binder驱动的上下文管理者？ binder驱动如何管理每个进程的binder服务呢？ ",
  "wordCount" : "3018",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://rong05.github.io/learn/android/android_binder/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "LEAN",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rong05.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rong05.github.io/" accesskey="h" title="LEAN (Alt + H)">LEAN</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://rong05.github.io/fr/" title="French"
                            aria-label=":fr:">🇫🇷</a>
                    </li>
                    <li>
                        <a href="https://rong05.github.io/fa/" title="Fa"
                            aria-label="Fa">Fa</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rong05.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://rong05.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://rong05.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://discord.gg/ahpmTvhVmp" title="Discord">
                    <span>Discord</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://rong05.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://rong05.github.io/learn/">Learns</a></div>
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">15 min&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/learn/android/android_binder.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#binder%e9%80%9a%e8%ae%af%e5%8e%9f%e7%90%86" aria-label="Binder通讯原理">Binder通讯原理</a><ul>
                        
                <li>
                    <a href="#binder%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e6%b3%a8%e5%86%8c" aria-label="Binder线程池的注册">Binder线程池的注册</a><ul>
                        
                <li>
                    <a href="#processstate" aria-label="ProcessState"><code>ProcessState</code></a><ul>
                        
                <li>
                    <a href="#processstate%e5%88%9b%e5%bb%ba" aria-label="ProcessState创建"><code>ProcessState</code>创建</a></li>
                <li>
                    <a href="#%e5%90%af%e5%8a%a8binder%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="启动binder线程池">启动binder线程池</a></li></ul>
                </li>
                <li>
                    <a href="#ipcthreadstate" aria-label="IPCThreadState"><code>IPCThreadState</code></a><ul>
                        
                <li>
                    <a href="#ipcthreadstate%e5%88%9b%e5%bb%ba" aria-label="IPCThreadState创建"><code>IPCThreadState</code>创建</a></li>
                <li>
                    <a href="#ipcthreadstatejointhreadpool%e5%87%bd%e6%95%b0" aria-label="IPCThreadState::joinThreadPool函数"><code>IPCThreadState::joinThreadPool</code>函数</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96servicemanager" aria-label="获取ServiceManager">获取<code>ServiceManager</code></a></li>
                <li>
                    <a href="#binder-%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e6%b5%81%e7%a8%8b" aria-label="Binder 数据传输流程">Binder 数据传输流程</a><ul>
                        
                <li>
                    <a href="#binder-%e6%95%b0%e6%8d%ae%e5%8f%91%e9%80%81%e8%bf%87%e7%a8%8b" aria-label="Binder 数据发送过程">Binder 数据发送过程</a></li>
                <li>
                    <a href="#binder-%e6%95%b0%e6%8d%ae%e6%8e%a5%e6%94%b6%e8%bf%87%e7%a8%8b" aria-label="Binder 数据接收过程">Binder 数据接收过程</a></li></ul>
                </li>
                <li>
                    <a href="#servicemanager%e8%bf%9b%e7%a8%8b%e5%88%9b%e5%bb%ba" aria-label="ServiceManager进程创建"><code>ServiceManager</code>进程创建</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="binder通讯原理">Binder通讯原理<a hidden class="anchor" aria-hidden="true" href="#binder通讯原理">#</a></h1>
<p><em>基于Android 11的源码剖析，笔记记录binder通讯原理的实现过程</em>；</p>
<p>根据网络上的各路大神案例，都是从典型的mediaserver进程开始分析，binder服务的注册注册过程；</p>
<p>mediaserver进程启动的main函数开始分析，至于init.rc的注册启动进程就跳过了；main函数代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span> <span class="n">__unused</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="n">__unused</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//创建与binder驱动交互和binder线程池的管理者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sp</span><span class="o">&lt;</span><span class="n">ProcessState</span><span class="o">&gt;</span> <span class="nf">proc</span><span class="p">(</span><span class="n">ProcessState</span><span class="o">::</span><span class="nf">self</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//获取ServiceManager的客户端BpServiceManager
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="nf">sm</span><span class="p">(</span><span class="nf">defaultServiceManager</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ALOGI</span><span class="p">(</span><span class="s">&#34;ServiceManager: %p&#34;</span><span class="p">,</span> <span class="n">sm</span><span class="p">.</span><span class="nf">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//创建MediaPlayerService服务，和向ServiceManager注册服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">MediaPlayerService</span><span class="o">::</span><span class="nf">instantiate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">ResourceManagerService</span><span class="o">::</span><span class="nf">instantiate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">registerExtensions</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">hardware</span><span class="o">::</span><span class="nf">configureRpcThreadpool</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//启动binder线程池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ProcessState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">startThreadPool</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">joinThreadPool</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">hardware</span><span class="o">::</span><span class="nf">joinRpcThreadpool</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="binder线程池的注册">Binder线程池的注册<a hidden class="anchor" aria-hidden="true" href="#binder线程池的注册">#</a></h2>
<p>每个采用 Binder 的进程会有一个或多个用于处理接收数据的线程，位于 Binder 线程池。采用 Binder 机制的进程最典型的就是应用程序进程了。那应用程序进程的 Binder 线程池是在什么时候启动的呢？</p>
<h3 id="processstate"><code>ProcessState</code><a hidden class="anchor" aria-hidden="true" href="#processstate">#</a></h3>
<p>源码位置：frameworks/native/libs/binder/ProcessState.cpp</p>
<p><strong><code>ProcessState</code> 是 Binder 机制核心之一</strong>，它是 Binder 通信的基础，负责与 Binder 驱动的交互与 Binder 线程池的管理。它实现了单例模式，通过 <code>self()</code> 函数获取实例，每个进程仅有一个。</p>
<h4 id="processstate创建"><code>ProcessState</code>创建<a hidden class="anchor" aria-hidden="true" href="#processstate创建">#</a></h4>
<p>实现了单例模式，通过 <code>self()</code> 函数获取实例。来看看它的构造函数，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">ProcessState</span><span class="o">::</span><span class="nf">ProcessState</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="nf">mDriverName</span><span class="p">(</span><span class="nf">String8</span><span class="p">(</span><span class="n">driver</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mDriverFD</span><span class="p">(</span><span class="nf">open_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">))</span><span class="c1">//访问binder设备，并与binder驱动交互
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">,</span> <span class="nf">mVMStart</span><span class="p">(</span><span class="n">MAP_FAILED</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mThreadCountLock</span><span class="p">(</span><span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mThreadCountDecrement</span><span class="p">(</span><span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mExecutingThreadsCount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mMaxThreads</span><span class="p">(</span><span class="n">DEFAULT_MAX_BINDER_THREADS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mStarvationStartTimeMs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mBinderContextCheckFunc</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mBinderContextUserData</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mThreadPoolStarted</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mThreadPoolSeq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="nf">mCallRestriction</span><span class="p">(</span><span class="n">CallRestriction</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// TODO(b/139016109): enforce in build system
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#if defined(__ANDROID_APEX__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="nf">LOG_ALWAYS_FATAL</span><span class="p">(</span><span class="s">&#34;Cannot use libbinder in APEX (only system.img libbinder) since it is not stable.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mDriverFD</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//映射binder驱动，提供通讯的虚拟空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// mmap the binder, providing a chunk of virtual address space to receive transactions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">mVMStart</span> <span class="o">=</span> <span class="nf">mmap</span><span class="p">(</span><span class="n">nullptr</span><span class="p">,</span> <span class="n">BINDER_VM_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_NORESERVE</span><span class="p">,</span> <span class="n">mDriverFD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">mVMStart</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// *sigh*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">ALOGE</span><span class="p">(</span><span class="s">&#34;Using %s failed: unable to mmap transaction memory.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">mDriverName</span><span class="p">.</span><span class="nf">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">mDriverFD</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">mDriverFD</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">mDriverName</span><span class="p">.</span><span class="nf">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef __ANDROID__
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="nf">LOG_ALWAYS_FATAL_IF</span><span class="p">(</span><span class="n">mDriverFD</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;Binder driver &#39;%s&#39; could not be opened.  Terminating.&#34;</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span></code></pre></div><p>ProcessState创建是主要步骤是：</p>
<ol>
<li>访问binder设备，并与binder驱动交互；</li>
<li>映射binder驱动，提供通讯基础的虚拟空间；</li>
</ol>
<p><strong>其中提供通讯基础的虚拟空间默认大小是由<code>BINDER_VM_SIZE</code>这个宏来决定的，宏定义如下：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//binder分配的默认内存大小为1M-8k
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)
</span></span></span></code></pre></div><p>下面来主要看看<code>open_driver</code>函数，函数内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">open_driver</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CLOEXEC</span><span class="p">);</span><span class="c1">//访问binder设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">vers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">status_t</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">BINDER_VERSION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vers</span><span class="p">);</span><span class="c1">//进行版本比对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">ALOGE</span><span class="p">(</span><span class="s">&#34;Binder ioctl to obtain version failed: %s&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vers</span> <span class="o">!=</span> <span class="n">BINDER_CURRENT_PROTOCOL_VERSION</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nf">ALOGE</span><span class="p">(</span><span class="s">&#34;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">vers</span><span class="p">,</span> <span class="n">BINDER_CURRENT_PROTOCOL_VERSION</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">size_t</span> <span class="n">maxThreads</span> <span class="o">=</span> <span class="n">DEFAULT_MAX_BINDER_THREADS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="nf">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">BINDER_SET_MAX_THREADS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maxThreads</span><span class="p">);</span><span class="c1">//设置binder线程池最大线程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">ALOGE</span><span class="p">(</span><span class="s">&#34;Binder ioctl to set max threads failed: %s&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ALOGW</span><span class="p">(</span><span class="s">&#34;Opening &#39;%s&#39; failed: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在<code>open_driver</code>函数中主要处理：</p>
<ol>
<li>
<p>访问binder设备，通过open函数来实现，具体现在不做详细说明；</p>
</li>
<li>
<p>通过ioctl进行binder的版本比较</p>
</li>
<li>
<p>通知binder驱动binder线程池的默认最大线程数，而这个最大线程数由<code>DEFAULT_MAX_BINDER_THREADS</code>宏来决定；宏定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//默认binder线程池的最大线程数,那加上本身binder默认的最大可并发访问的线程数为16
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define DEFAULT_MAX_BINDER_THREADS 15
</span></span></span></code></pre></div></li>
</ol>
<h4 id="启动binder线程池">启动binder线程池<a hidden class="anchor" aria-hidden="true" href="#启动binder线程池">#</a></h4>
<p><code>ProcessState</code> 实例后调用其 <code>startThreadPool</code> 函数，以启动进程的 Binder 线程池。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">ProcessState</span><span class="o">::</span><span class="nf">startThreadPool</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">AutoMutex</span> <span class="nf">_l</span><span class="p">(</span><span class="n">mLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mThreadPoolStarted</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mThreadPoolStarted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">spawnPooledThread</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">ProcessState</span><span class="o">::</span><span class="nf">spawnPooledThread</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mThreadPoolStarted</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String8</span> <span class="n">name</span> <span class="o">=</span> <span class="nf">makeBinderThreadName</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ALOGV</span><span class="p">(</span><span class="s">&#34;Spawning new pooled thread, name=%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">name</span><span class="p">.</span><span class="nf">string</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">sp</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">new</span> <span class="nf">PoolThread</span><span class="p">(</span><span class="n">isMain</span><span class="p">);</span><span class="c1">//创建线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">t</span><span class="o">-&gt;</span><span class="nf">run</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="nf">string</span><span class="p">());</span><span class="c1">//启动线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>mThreadPoolStarted</code> 用于标识线程池是否已经启动过，以确保 Binder 线程池仅初始化一次。<code>spawnPooledThread()</code> 函数启动了一个 Binder 线程，类型为 <code>PoolThread</code>，函数参数表示这是 Binder 线程池中的第一线程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">class</span> <span class="nl">PoolThread</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Thread</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">explicit</span> <span class="nf">PoolThread</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="nf">mIsMain</span><span class="p">(</span><span class="n">isMain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">protected</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//PoolThread继承Thread类。t-&gt;run()方法最终调用内部类 PoolThread的threadLoop()方法。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">virtual</span> <span class="kt">bool</span> <span class="nf">threadLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">joinThreadPool</span><span class="p">(</span><span class="n">mIsMain</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">bool</span> <span class="n">mIsMain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><code>PoolThread</code>继承<code>Thread</code>类。<code>t-&gt;run()</code>方法最终调用内部类 <code>PoolThread</code>的<code>threadLoop</code>()方法。在主要创建了<code>IPCThreadState</code>和执行了<code>IPCThreadState</code>的<code>joinThreadPool</code>函数；</p>
<p>在mediaserver的main函数中后面又执行了一次<code>IPCThreadState</code>的<code>joinThreadPool</code>函数，这两次的区别是一个在子线程执行，一个是在进程主线程执行，**mediaserver默认binder的事件监听线程数是2吗？**这样binder线程池算基本完成！</p>
<h3 id="ipcthreadstate"><code>IPCThreadState</code><a hidden class="anchor" aria-hidden="true" href="#ipcthreadstate">#</a></h3>
<p>源码位置：frameworks/native/libs/binder/IPCThreadState.cpp</p>
<p><code>IPCThreadState</code> 同样是 Binder 机制的核心之一，它用于管理与 Binder 通信相关线程的状态，每个 Binder 线程都会通过此将自己注册到 Binder 驱动。一个具有多个线程的进程里应该会有多个IPCThreadState对象了，只不过每个线程只需一个IPCThreadState对象而已。所以要放在binder线程池中统一管理。</p>
<h4 id="ipcthreadstate创建"><code>IPCThreadState</code>创建<a hidden class="anchor" aria-hidden="true" href="#ipcthreadstate创建">#</a></h4>
<p><code>IPCThreadState</code>同样是通过 <code>self()</code> 函数获取实例的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">IPCThreadState</span><span class="o">*</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">gHaveTLS</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">restart</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">pthread_key_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">gTLS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//获取当前线程是否创建了IPCThreadState，如果创建了直接返回,类似Looper里的ThreadLocal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">IPCThreadState</span><span class="o">*</span> <span class="n">st</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPCThreadState</span><span class="o">*</span><span class="p">)</span><span class="nf">pthread_getspecific</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="k">return</span> <span class="n">st</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">new</span> <span class="n">IPCThreadState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Racey, heuristic test for simultaneous shutdown.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">gShutdown</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ALOGW</span><span class="p">(</span><span class="s">&#34;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gTLSMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gHaveTLS</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//创建线程唯一的标签
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">key_create_value</span> <span class="o">=</span> <span class="nf">pthread_key_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gTLS</span><span class="p">,</span> <span class="n">threadDestructor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">key_create_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gTLSMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">ALOGW</span><span class="p">(</span><span class="s">&#34;IPCThreadState::self() unable to create TLS key, expect a crash: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">strerror</span><span class="p">(</span><span class="n">key_create_value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">gHaveTLS</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gTLSMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">restart</span><span class="p">;</span><span class="c1">//回到开始根据线程唯一标记创建IPCThreadState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><code>self()</code> 函数是一个工厂函数，用于获取 <code>IPCThreadState</code> 实例。<code>self()</code> 根据 <code>pthread_getspecific()</code> 管理每个参与 Binder 通信线程的实例，类似<code>Looper</code>里的<code>ThreadLocal</code>，每个参与 Binder 通信的线程其 <code>IPCThreadState</code> 对象都是相互独立的，保证了后续操作的线程安全。构造函数内容其实，很简单主要是绑定线程唯一标记和初始化输入输出缓冲区；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">IPCThreadState</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="nf">mProcess</span><span class="p">(</span><span class="n">ProcessState</span><span class="o">::</span><span class="nf">self</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">      <span class="nf">mServingStackPointer</span><span class="p">(</span><span class="n">nullptr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nf">mWorkSource</span><span class="p">(</span><span class="n">kUnsetWorkSource</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nf">mPropagateWorkSource</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nf">mStrictModePolicy</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nf">mLastTransactionBinderFlags</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nf">mCallRestriction</span><span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mCallRestriction</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//将线程唯一标签保存的内容设置为自身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_setspecific</span><span class="p">(</span><span class="n">gTLS</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//获取当前进程的pid和uid信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">clearCaller</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置输入缓冲区大小，默认256
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mIn</span><span class="p">.</span><span class="nf">setDataCapacity</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置输出缓冲区大小，默认256
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mOut</span><span class="p">.</span><span class="nf">setDataCapacity</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="ipcthreadstatejointhreadpool函数"><code>IPCThreadState::joinThreadPool</code>函数<a hidden class="anchor" aria-hidden="true" href="#ipcthreadstatejointhreadpool函数">#</a></h4>
<p><code>joinThreadPool</code>函数就是一个死循环，不断从驱动获取数据;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">joinThreadPool</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">LOG_THREADPOOL</span><span class="p">(</span><span class="s">&#34;**** THREAD %p (PID %d) IS JOINING THE THREAD POOL</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nf">pthread_self</span><span class="p">(),</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mOut</span><span class="p">.</span><span class="nf">writeInt32</span><span class="p">(</span><span class="n">isMain</span> <span class="o">?</span> <span class="nl">BC_ENTER_LOOPER</span> <span class="p">:</span> <span class="n">BC_REGISTER_LOOPER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">status_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//清除上一次通讯的输入缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">processPendingDerefs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//处理下一条信息或者等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// now get the next command to be processed, waiting if necessary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">result</span> <span class="o">=</span> <span class="nf">getAndExecuteCommand</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">NO_ERROR</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="n">TIMED_OUT</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">LOG_ALWAYS_FATAL</span><span class="p">(</span><span class="s">&#34;getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mDriverFD</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Let this thread exit the thread pool if it is no longer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// needed and it is not the main process thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">TIMED_OUT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isMain</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">LOG_THREADPOOL</span><span class="p">(</span><span class="s">&#34;**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nf">pthread_self</span><span class="p">(),</span> <span class="nf">getpid</span><span class="p">(),</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mOut</span><span class="p">.</span><span class="nf">writeInt32</span><span class="p">(</span><span class="n">BC_EXIT_LOOPER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">talkWithDriver</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如此看来<code>IPCThreadState</code>是通过<code>getAndExecuteCommand</code>来不断获取通讯数据的；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">getAndExecuteCommand</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">status_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//从bender驱动中获取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">result</span> <span class="o">=</span> <span class="nf">talkWithDriver</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">size_t</span> <span class="n">IN</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="nf">dataAvail</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">IN</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int32_t</span><span class="p">))</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="nf">readInt32</span><span class="p">();</span><span class="c1">//读取命令字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">IF_LOG_COMMANDS</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">alog</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Processing top-level Command: &#34;</span>
</span></span><span class="line"><span class="cl">                 <span class="o">&lt;&lt;</span> <span class="nf">getReturnString</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mExecutingThreadsCount</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mExecutingThreadsCount</span> <span class="o">&gt;=</span> <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mMaxThreads</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mStarvationStartTimeMs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mStarvationStartTimeMs</span> <span class="o">=</span> <span class="nf">uptimeMillis</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//进行binder命令解析
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">result</span> <span class="o">=</span> <span class="nf">executeCommand</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mExecutingThreadsCount</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mExecutingThreadsCount</span> <span class="o">&lt;</span> <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mMaxThreads</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mStarvationStartTimeMs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int64_t</span> <span class="n">starvationTimeMs</span> <span class="o">=</span> <span class="nf">uptimeMillis</span><span class="p">()</span> <span class="o">-</span> <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mStarvationStartTimeMs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">starvationTimeMs</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">ALOGE</span><span class="p">(</span><span class="s">&#34;binder thread pool (%zu threads) starved for %&#34;</span> <span class="n">PRId64</span> <span class="s">&#34; ms&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mMaxThreads</span><span class="p">,</span> <span class="n">starvationTimeMs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mStarvationStartTimeMs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountDecrement</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>getAndExecuteCommand</code>的执行步骤：</p>
<ol>
<li>通过<code>talkWithDriver</code>向binder驱动获取通讯数据；</li>
<li>读取命令字段，并通过<code>executeCommand</code>函数进行不同命令字段的解析和处理</li>
</ol>
<h2 id="获取servicemanager">获取<code>ServiceManager</code><a hidden class="anchor" aria-hidden="true" href="#获取servicemanager">#</a></h2>
<p>获取Service Manager是通过<code>defaultServiceManager</code>方法来完成，当进程注册服务(addService)或 获取服务(getService)的过程之前，都需要先调用defaultServiceManager()方法来获取<code>gDefaultServiceManager</code>对象。</p>
<p>大概流程图如下：</p>
<img src="img/defaultServiceManager.png" style="zoom:50%;" />
<p><code>defaultServiceManager</code>函数代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="nf">defaultServiceManager</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="nf">call_once</span><span class="p">(</span><span class="n">gSmOnce</span><span class="p">,</span> <span class="p">[]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sp</span><span class="o">&lt;</span><span class="n">AidlServiceManager</span><span class="o">&gt;</span> <span class="n">sm</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//避免ServiceManager未启动完成，重复请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">sm</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//获取BpServiceManager
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">sm</span> <span class="o">=</span> <span class="n">interface_cast</span><span class="o">&lt;</span><span class="n">AidlServiceManager</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ProcessState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">getContextObject</span><span class="p">(</span><span class="n">nullptr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">sm</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">ALOGE</span><span class="p">(</span><span class="s">&#34;Waiting 1s on context object on %s.&#34;</span><span class="p">,</span> <span class="n">ProcessState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">getDriverName</span><span class="p">().</span><span class="nf">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">                <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//创建BpServiceManager代理对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">gDefaultServiceManager</span> <span class="o">=</span> <span class="n">new</span> <span class="nf">ServiceManagerShim</span><span class="p">(</span><span class="n">sm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">gDefaultServiceManager</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>ServiceManager</code>的对象获取也采用了一个单例模式，一个进程中只要获取一次即可，对象存储在<code>gDefaultServiceManager</code>中。</p>
<p>主要流程如下：</p>
<ol>
<li>获取<code>ProcessState</code>对象&mdash;<code>ProcessState::self()</code>，在上面的流程中可知<code>ProcessState</code>已获取，存入了全局变量中</li>
<li>获取<code>BpBinder</code>对象 &ndash;<code>ProcessState::getContextObject(nullptr)</code></li>
<li>获取<code>BpServiceManager</code>对象&mdash;-<code>interface_cast&lt;IServiceManager&gt;</code></li>
<li>创建<code>ServiceManagerShim</code>对象对<code>BpServiceManager</code>对象进行接管</li>
</ol>
<p>在<code>ProcessState::getContextObject(nullptr)</code>函数中，主要调用<code>getStrongProxyForHandle</code>进行处理，传入handle=0，那主要看看<code>getStrongProxyForHandle</code>函数；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">ProcessState</span><span class="o">::</span><span class="nf">getStrongProxyForHandle</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">handle</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">AutoMutex</span> <span class="nf">_l</span><span class="p">(</span><span class="n">mLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//查找handle对应的资源项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">handle_entry</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="nf">lookupHandleLocked</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// We need to create a new BpBinder if there isn&#39;t currently one, OR we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// are unable to acquire a weak reference on this current one.  The
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// attemptIncWeak() is safe because we know the BpBinder destructor will always
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// call expungeHandle(), which acquires the same lock we are holding now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// We need to do this because there is a race condition between someone
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// releasing a reference on this BpBinder, and a new reference on its handle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// arriving from the driver.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">IBinder</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">binder</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span><span class="o">-&gt;</span><span class="nf">attemptIncWeak</span><span class="p">(</span><span class="n">this</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Special case for context manager...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// The context manager is the only object for which we create
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// a BpBinder proxy without already holding a reference.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// Perform a dummy transaction to ensure the context manager
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// is registered before we create the first local reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// to it (which will occur when creating the BpBinder).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// If a local reference is created for the BpBinder when the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// context manager is not present, the driver will fail to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// provide a reference to the context manager, but the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// driver API does not return status.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// Note that this is not race-free if the context manager
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// dies while this code runs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// TODO: add a driver API to wait for context manager, or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// stop special casing handle 0 for context manager and add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// a driver API to get a handle to the context manager with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// proper reference counting.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">                <span class="n">Parcel</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//测试binder是否准备就绪
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kt">status_t</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">transact</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                        <span class="mi">0</span><span class="p">,</span> <span class="n">IBinder</span><span class="o">::</span><span class="n">PING_TRANSACTION</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">DEAD_OBJECT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                   <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//当handle值所对应的IBinder不存在或弱引用无效时，创建一个BpBinder，handle=0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">//create的实现其实就是  new BpBinder(0,trackedUid)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">b</span> <span class="o">=</span> <span class="n">BpBinder</span><span class="o">::</span><span class="nf">create</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">e</span><span class="o">-&gt;</span><span class="n">binder</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="nf">getWeakRefs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// This little bit of nastyness is to allow us to add a primary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// reference to the remote proxy when this team doesn&#39;t have one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// but another team is sending the handle to us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">.</span><span class="nf">force_set</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span><span class="o">-&gt;</span><span class="nf">decWeak</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>getStrongProxyForHandle</code>的过程也很简单，当<code>handle=0</code>所对应的<code>IBinder</code>不存在或弱引用无效时，先看下Binder是否已经准备就绪，即<code>ServiceManager</code>是否已经就绪，准备好后，创建一个<code>BpBinder(0,trackedUid)</code>，创建<code>BpBinder</code>对象中会将<code>handle</code>相对应<code>Binder</code>的弱引用增加1，最终返回一个<code>BpBiner</code>的对象。</p>
<p>真正获取<code>ServiceManager</code>的代理对象的是 <code>interface_cast&lt;AidlServiceManager&gt;</code> 方法。零号引用的 <code>BpBinder</code> 对象传入 <code>interface_cast()</code> 模版函数，会最终通过 <code>IMPLEMENT_META_INTERFACE()</code> 宏，生成 <code>BpServiceManager</code> 对象。该对象被传入 <code>ServiceManagerShim</code> 的构造函数中，成为其成员变量 <code>mTheRealServiceManager</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)\
</span></span></span><span class="line"><span class="cl"><span class="cp">    const ::android::StaticString16                                     \
</span></span></span><span class="line"><span class="cl"><span class="cp">        I##INTERFACE##_descriptor_static_str16(__IINTF_CONCAT(u, NAME));\
</span></span></span><span class="line"><span class="cl"><span class="cp">    const ::android::String16 I##INTERFACE::descriptor(                 \
</span></span></span><span class="line"><span class="cl"><span class="cp">        I##INTERFACE##_descriptor_static_str16);                        \
</span></span></span><span class="line"><span class="cl"><span class="cp">    const ::android::String16&amp;                                          \
</span></span></span><span class="line"><span class="cl"><span class="cp">            I##INTERFACE::getInterfaceDescriptor() const {              \
</span></span></span><span class="line"><span class="cl"><span class="cp">        return I##INTERFACE::descriptor;                                \
</span></span></span><span class="line"><span class="cl"><span class="cp">    }                                                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">    ::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(              \
</span></span></span><span class="line"><span class="cl"><span class="cp">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \
</span></span></span><span class="line"><span class="cl"><span class="cp">    {                                                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">        ::android::sp&lt;I##INTERFACE&gt; intr;                               \
</span></span></span><span class="line"><span class="cl"><span class="cp">        if (obj != nullptr) {                                           \
</span></span></span><span class="line"><span class="cl"><span class="cp">            intr = static_cast&lt;I##INTERFACE*&gt;(                          \
</span></span></span><span class="line"><span class="cl"><span class="cp">                obj-&gt;queryLocalInterface(                               \
</span></span></span><span class="line"><span class="cl"><span class="cp">                        I##INTERFACE::descriptor).get());               \
</span></span></span><span class="line"><span class="cl"><span class="cp">            if (intr == nullptr) {                                      \
</span></span></span><span class="line"><span class="cl"><span class="cp">                intr = new Bp##INTERFACE(obj);                          \
</span></span></span><span class="line"><span class="cl"><span class="cp">            }                                                           \
</span></span></span><span class="line"><span class="cl"><span class="cp">        }                                                               \
</span></span></span><span class="line"><span class="cl"><span class="cp">        return intr;                                                    \
</span></span></span><span class="line"><span class="cl"><span class="cp">    }                                                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">    std::unique_ptr&lt;I##INTERFACE&gt; I##INTERFACE::default_impl;           \
</span></span></span><span class="line"><span class="cl"><span class="cp">    bool I##INTERFACE::setDefaultImpl(std::unique_ptr&lt;I##INTERFACE&gt; impl)\
</span></span></span><span class="line"><span class="cl"><span class="cp">    {                                                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">        </span><span class="cm">/* Only one user of this interface can use this function     */</span><span class="cp"> \
</span></span></span><span class="line"><span class="cl"><span class="cp">        </span><span class="cm">/* at a time. This is a heuristic to detect if two different */</span><span class="cp"> \
</span></span></span><span class="line"><span class="cl"><span class="cp">        </span><span class="cm">/* users in the same process use this function.              */</span><span class="cp"> \
</span></span></span><span class="line"><span class="cl"><span class="cp">        assert(!I##INTERFACE::default_impl);                            \
</span></span></span><span class="line"><span class="cl"><span class="cp">        if (impl) {                                                     \
</span></span></span><span class="line"><span class="cl"><span class="cp">            I##INTERFACE::default_impl = std::move(impl);               \
</span></span></span><span class="line"><span class="cl"><span class="cp">            return true;                                                \
</span></span></span><span class="line"><span class="cl"><span class="cp">        }                                                               \
</span></span></span><span class="line"><span class="cl"><span class="cp">        return false;                                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">    }                                                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">    const std::unique_ptr&lt;I##INTERFACE&gt;&amp; I##INTERFACE::getDefaultImpl() \
</span></span></span><span class="line"><span class="cl"><span class="cp">    {                                                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">        return I##INTERFACE::default_impl;                              \
</span></span></span><span class="line"><span class="cl"><span class="cp">    }                                                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">    I##INTERFACE::I##INTERFACE() { }                                    \
</span></span></span><span class="line"><span class="cl"><span class="cp">    I##INTERFACE::~I##INTERFACE() { }                                   \
</span></span></span></code></pre></div><p>Android 10在此之后，<code>BpServiceManager</code> 不再通过手动实现，而是采用 AIDL（文件为 <code>IServiceManager.aidl</code>），生成 <code>IServiceManager</code>、<code>BnServiceManager</code>、<code>BpServiceManager</code> 的头文件及具体实现。</p>
<p>关于通过 AIDL 生成 C++ 代码，详见 <a href="https://android.googlesource.com/platform/system/tools/aidl/+/brillo-m10-dev/docs/aidl-cpp.md">Generating C++ Binder Interfaces with aidl-cpp</a></p>
<p><code>BpServiceManager</code>的继承关系图如下：</p>
<img src="img/BpServiceManager.png" style="zoom:40%;" />
<h2 id="binder-数据传输流程">Binder 数据传输流程<a hidden class="anchor" aria-hidden="true" href="#binder-数据传输流程">#</a></h2>
<h3 id="binder-数据发送过程">Binder 数据发送过程<a hidden class="anchor" aria-hidden="true" href="#binder-数据发送过程">#</a></h3>
<p>从<code>addService</code>函数来分析Binder的数据传输流程；从获取servicemanage的章节我们得知，servicemanage的Client端是<code>BpServiceManager</code>，那我们直接来看<code>BpServiceManager</code>中的<code>addService</code>函数，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="n">virtual</span> <span class="kt">status_t</span> <span class="nf">addService</span><span class="p">(</span><span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">service</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="kt">bool</span> <span class="n">allowIsolated</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dumpsysPriority</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Parcel</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">.</span><span class="nf">writeInterfaceToken</span><span class="p">(</span><span class="n">IServiceManager</span><span class="o">::</span><span class="nf">getInterfaceDescriptor</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">.</span><span class="nf">writeString16</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">.</span><span class="nf">writeStrongBinder</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">.</span><span class="nf">writeInt32</span><span class="p">(</span><span class="n">allowIsolated</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">.</span><span class="nf">writeInt32</span><span class="p">(</span><span class="n">dumpsysPriority</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">transact</span><span class="p">(</span><span class="n">ADD_SERVICE_TRANSACTION</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reply</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">err</span> <span class="o">==</span> <span class="n">NO_ERROR</span> <span class="o">?</span> <span class="n">reply</span><span class="p">.</span><span class="nf">readExceptionCode</span><span class="p">()</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//Parcel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">status_t</span> <span class="n">Parcel</span><span class="o">::</span><span class="nf">writeStrongBinder</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">flattenBinder</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">status_t</span> <span class="n">Parcel</span><span class="o">::</span><span class="nf">flattenBinder</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">binder</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">flat_binder_object</span> <span class="n">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">backgroundSchedulingDisabled</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* minimum priority for all nodes is nice 0 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">obj</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FLAT_BINDER_FLAG_ACCEPTS_FDS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* minimum priority for all nodes is MAX_NICE(19) */</span>
</span></span><span class="line"><span class="cl">        <span class="n">obj</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mh">0x13</span> <span class="o">|</span> <span class="n">FLAT_BINDER_FLAG_ACCEPTS_FDS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">binder</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">BBinder</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">binder</span><span class="o">-&gt;</span><span class="nf">localBinder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">BpBinder</span> <span class="o">*</span><span class="n">proxy</span> <span class="o">=</span> <span class="n">binder</span><span class="o">-&gt;</span><span class="nf">remoteBinder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">proxy</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">ALOGE</span><span class="p">(</span><span class="s">&#34;null proxy&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="kt">int32_t</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">proxy</span> <span class="o">?</span> <span class="n">proxy</span><span class="o">-&gt;</span><span class="nf">handle</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">obj</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BINDER_TYPE_HANDLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">obj</span><span class="p">.</span><span class="n">binder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Don&#39;t pass uninitialized stack data to a remote process */</span>
</span></span><span class="line"><span class="cl">            <span class="n">obj</span><span class="p">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">obj</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="nf">isRequestingSid</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">obj</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAT_BINDER_FLAG_TXN_SECURITY_CTX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">obj</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BINDER_TYPE_BINDER</span><span class="p">;</span><span class="c1">//type被赋值为BINDER_TYPE_BINDER，即表示此时的obj是一个Binder实体对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">obj</span><span class="p">.</span><span class="n">binder</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="nf">getWeakRefs</span><span class="p">());</span><span class="c1">//记录Binder弱引用指针地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">obj</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">local</span><span class="p">);</span><span class="c1">//记录Binder实体的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">obj</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BINDER_TYPE_BINDER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">obj</span><span class="p">.</span><span class="n">binder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">obj</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">finishFlattenBinder</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从代码分析<code>Parcel</code>通过<code>writeStrongBinder</code>函数把<code>service</code>封装成<code>flat_binder_object</code>结构体，其中保存了<code>service</code>的Binder弱引用指针地址和Binder实体的指针；<code>flat_binder_object</code>结构体定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">flat_binder_object</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">binder_object_header</span>	<span class="n">hdr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">__u32</span>				<span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* 8 bytes of data. */</span>
</span></span><span class="line"><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">binder_uintptr_t</span>	<span class="n">binder</span><span class="p">;</span>	<span class="cm">/* local object */</span><span class="c1">//记录Binder弱引用指针地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">__u32</span>			<span class="n">handle</span><span class="p">;</span>	<span class="cm">/* remote object */</span><span class="c1">//这个在binder驱动中查找Binder弱引用指针用的关键key，目前这样理解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* extra data associated with local object */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">binder_uintptr_t</span>	<span class="n">cookie</span><span class="p">;</span><span class="c1">//记录binder的实体指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p><code>remote()-&gt;transact()</code>将传出，从<code>defaultServiceManager</code>分析总结<code>remote</code>对应的是在<code>getStrongProxyForHandle</code>函数中创建的<code>BpBinder</code>;而在<code>BpBinder</code>的<code>transact</code>函数中，主要是执行了<code>status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags);</code>,接下来我们就分析一下<code>IPCThreadState</code>的<code>transact</code>函数；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">transact</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">handle</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="kt">uint32_t</span> <span class="n">code</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parcel</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="n">Parcel</span><span class="o">*</span> <span class="n">reply</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">status_t</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">flags</span> <span class="o">|=</span> <span class="n">TF_ACCEPT_FDS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">IF_LOG_TRANSACTIONS</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">TextOutput</span><span class="o">::</span><span class="n">Bundle</span> <span class="nf">_b</span><span class="p">(</span><span class="n">alog</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">alog</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;BC_TRANSACTION thr &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nf">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; / hand &#34;</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">handle</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; / code &#34;</span> <span class="o">&lt;&lt;</span> <span class="nf">TypeCode</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: &#34;</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">indent</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">dedent</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">LOG_ONEWAY</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">(),</span> <span class="nf">getuid</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TF_ONE_WAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&#34;READ REPLY&#34;</span> <span class="o">:</span> <span class="s">&#34;ONE WAY&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//将数据打包塞到 mOut 里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="nf">writeTransactionData</span><span class="p">(</span><span class="n">BC_TRANSACTION</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="nf">setError</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">mLastError</span> <span class="o">=</span> <span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TF_ONE_WAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">UNLIKELY</span><span class="p">(</span><span class="n">mCallRestriction</span> <span class="o">!=</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">CallRestriction</span><span class="o">::</span><span class="n">NONE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">mCallRestriction</span> <span class="o">==</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">CallRestriction</span><span class="o">::</span><span class="n">ERROR_IF_NOT_ONEWAY</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">ALOGE</span><span class="p">(</span><span class="s">&#34;Process making non-oneway call (code: %u) but is restricted.&#34;</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">CallStack</span><span class="o">::</span><span class="nf">logStack</span><span class="p">(</span><span class="s">&#34;non-oneway call&#34;</span><span class="p">,</span> <span class="n">CallStack</span><span class="o">::</span><span class="nf">getCurrent</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">get</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ANDROID_LOG_ERROR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="cm">/* FATAL_IF_NOT_ONEWAY */</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">LOG_ALWAYS_FATAL</span><span class="p">(</span><span class="s">&#34;Process may not make oneway calls (code: %u).&#34;</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cp">#if 0</span><span class="c">
</span></span></span><span class="line"><span class="cl"><span class="c">        if (code == 4) { // relayout
</span></span></span><span class="line"><span class="cl"><span class="c">            ALOGI(&#34;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c">        } else {
</span></span></span><span class="line"><span class="cl"><span class="c">            ALOGI(&#34;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d&#34;, code);
</span></span></span><span class="line"><span class="cl"><span class="c">        }
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="cp">        #endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//不是 one way 调用，需要等待回复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">err</span> <span class="o">=</span> <span class="nf">waitForResponse</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//one way 调用，不用等待回复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">Parcel</span> <span class="n">fakeReply</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">err</span> <span class="o">=</span> <span class="nf">waitForResponse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fakeReply</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#if 0</span><span class="c">
</span></span></span><span class="line"><span class="cl"><span class="c">        if (code == 4) { // relayout
</span></span></span><span class="line"><span class="cl"><span class="c">            ALOGI(&#34;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c">        } else {
</span></span></span><span class="line"><span class="cl"><span class="c">            ALOGI(&#34;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d&#34;, code);
</span></span></span><span class="line"><span class="cl"><span class="c">        }
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="cp">        #endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">        <span class="nf">IF_LOG_TRANSACTIONS</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">TextOutput</span><span class="o">::</span><span class="n">Bundle</span> <span class="nf">_b</span><span class="p">(</span><span class="n">alog</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">alog</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;BR_REPLY thr &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nf">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; / hand &#34;</span>
</span></span><span class="line"><span class="cl">                <span class="o">&lt;&lt;</span> <span class="n">handle</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span> <span class="n">alog</span> <span class="o">&lt;&lt;</span> <span class="n">indent</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">reply</span> <span class="o">&lt;&lt;</span> <span class="n">dedent</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="n">alog</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;(none requested)&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">err</span> <span class="o">=</span> <span class="nf">waitForResponse</span><span class="p">(</span><span class="n">nullptr</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>IPCThreadState</code> 中有 mIn、mOut 两个 <code>Parcel</code> 数据，mIn 用来存放从别处读取而来的数据，mOut 存放要写入到别处的数据，而在<code>transact</code>函数中关键代码只有两行（<code>writeTransactionData</code>和<code>waitForResponse</code>），从命名上来看就是一次请求和接收应答的过程。在 <code>writeTransactionData</code>函数中将一堆参数组装进<code>binder_transaction_data</code>结构体并存放到 mOut，准备写入到 binder 驱动;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">writeTransactionData</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">binderFlags</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">code</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parcel</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="kt">status_t</span><span class="o">*</span> <span class="n">statusBuffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">binder_transaction_data</span> <span class="n">tr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tr</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Don&#39;t pass uninitialized stack data to a remote process */</span>
</span></span><span class="line"><span class="cl">    <span class="n">tr</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tr</span><span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tr</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">binderFlags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tr</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tr</span><span class="p">.</span><span class="n">sender_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tr</span><span class="p">.</span><span class="n">sender_euid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//检查数据是否有效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">errorCheck</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tr</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">ipcDataSize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">ipcData</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">tr</span><span class="p">.</span><span class="n">offsets_size</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">ipcObjectsCount</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">binder_size_t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">ipcObjects</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">statusBuffer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tr</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TF_STATUS_CODE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">statusBuffer</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tr</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">status_t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">statusBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">tr</span><span class="p">.</span><span class="n">offsets_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">mLastError</span> <span class="o">=</span> <span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mOut</span><span class="p">.</span><span class="nf">writeInt32</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mOut</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>binder_transaction_data</code>结构体在中组装的<code>Parcel</code>数据：</p>
<img src="img/binder_transaction_data.png" style="zoom:30%;" />
<p>​															<a href="http://palanceli.com/2016/05/08/2016/0514BinderLearning3/">图片来源</a></p>
<p><code>binder_transaction_data</code>结构体定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">binder_transaction_data</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/* The first two are only used for bcTRANSACTION and brTRANSACTION,
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * identifying the target and contents of the transaction.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/* target descriptor of command transaction */</span>
</span></span><span class="line"><span class="cl">		<span class="n">__u32</span>	<span class="n">handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/* target descriptor of return transaction */</span>
</span></span><span class="line"><span class="cl">		<span class="kt">binder_uintptr_t</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="n">target</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">binder_uintptr_t</span>	<span class="n">cookie</span><span class="p">;</span>	<span class="cm">/* target object cookie */</span>
</span></span><span class="line"><span class="cl">	<span class="n">__u32</span>		<span class="n">code</span><span class="p">;</span>		<span class="cm">/* transaction command */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* General information about the transaction. */</span>
</span></span><span class="line"><span class="cl">	<span class="n">__u32</span>	        <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pid_t</span>		<span class="n">sender_pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uid_t</span>		<span class="n">sender_euid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">binder_size_t</span>	<span class="n">data_size</span><span class="p">;</span>	<span class="cm">/* number of bytes of data */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">binder_size_t</span>	<span class="n">offsets_size</span><span class="p">;</span>	<span class="cm">/* number of bytes of offsets */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* If this transaction is inline, the data immediately
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * follows here; otherwise, it ends with a pointer to
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * the data buffer.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* transaction data */</span>
</span></span><span class="line"><span class="cl">			<span class="kt">binder_uintptr_t</span>	<span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* offsets from buffer to flat_binder_object structs */</span>
</span></span><span class="line"><span class="cl">			<span class="kt">binder_uintptr_t</span>	<span class="n">offsets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">__u8</span>	<span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><code>waitForResponse</code>函数去实际执行写入到 binder 驱动，简化后的 <code>waitForResponse</code>函数代码如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">waitForResponse</span><span class="p">(</span><span class="n">Parcel</span> <span class="o">*</span><span class="n">reply</span><span class="p">,</span> <span class="kt">status_t</span> <span class="o">*</span><span class="n">acquireResult</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//进一步调用 talkWithDriver 去执行写入数据到 binder 驱动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">((</span><span class="n">err</span><span class="o">=</span><span class="nf">talkWithDriver</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">err</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="nf">errorCheck</span><span class="p">();</span><span class="c1">//检查数据有效性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">mIn</span><span class="p">.</span><span class="nf">dataAvail</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span><span class="c1">//检查数据有效性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">mIn</span><span class="p">.</span><span class="nf">readInt32</span><span class="p">();</span><span class="c1">//拿到 binder 驱动发过来的命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//处理命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nl">BR_TRANSACTION_COMPLETE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">acquireResult</span><span class="p">)</span> <span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BR_DEAD_REPLY</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">err</span> <span class="o">=</span> <span class="n">DEAD_OBJECT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BR_FAILED_REPLY</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">err</span> <span class="o">=</span> <span class="n">FAILED_TRANSACTION</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BR_ACQUIRE_RESULT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="p">...</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BR_REPLY</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="p">...</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span><span class="o">:</span><span class="c1">//其他命令在 executeCommand 方法中处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">err</span> <span class="o">=</span> <span class="nf">executeCommand</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">finish</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">acquireResult</span><span class="p">)</span> <span class="o">*</span><span class="n">acquireResult</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="nf">setError</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">mLastError</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到 <code>waitForResponse</code>中并没有直接执行写入数据到 binder，而是进一步调用 <code>talkWithDriver</code> 去处理，随后 <code>waitForResponse</code>处理了由 binder 驱动发送过来的命令,因为在<code>BpServiceManager</code>传过来的reply不等于空，所以正常的逻辑是收到BR_REPLY才退出循环；</p>
<p>由 <code>transact</code>到 <code>waitForResponse</code>，已经将要发送的数据准备好，并对后续 binder 驱动的回复也做了处理，但还没看到真正写入数据给 binder 驱动的代码，但已经知道就在 <code>talkWithDriver</code>函数中，此函数中主要做了三个工作：</p>
<ol>
<li>将要发送的数据封装成<code>binder_write_read</code>结构体；</li>
<li>通过ioctl把<code>binder_write_read</code>结构体数据写入binder驱动；</li>
<li>处理驱动回复</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">talkWithDriver</span><span class="p">(</span><span class="kt">bool</span> <span class="n">doReceive</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//binder驱动是否打开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mDriverFD</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//binder 驱动接受的数据格式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">binder_write_read</span> <span class="n">bwr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Is the read buffer empty?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">bool</span> <span class="n">needRead</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="nf">dataPosition</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">mIn</span><span class="p">.</span><span class="nf">dataSize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">outAvail</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">doReceive</span> <span class="o">||</span> <span class="n">needRead</span><span class="p">)</span> <span class="o">?</span> <span class="n">mOut</span><span class="p">.</span><span class="nf">dataSize</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">bwr</span><span class="p">.</span><span class="n">write_size</span> <span class="o">=</span> <span class="n">outAvail</span><span class="p">;</span> <span class="c1">//要写入的数据量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">bwr</span><span class="p">.</span><span class="n">write_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">mOut</span><span class="p">.</span><span class="nf">data</span><span class="p">();</span> <span class="c1">//要写入的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// This is what we&#39;ll read.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">doReceive</span> <span class="o">&amp;&amp;</span> <span class="n">needRead</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="nf">dataCapacity</span><span class="p">();</span><span class="c1">//要读取的数据量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">bwr</span><span class="p">.</span><span class="n">read_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">mIn</span><span class="p">.</span><span class="nf">data</span><span class="p">();</span><span class="c1">//存放读取数据的内存空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">bwr</span><span class="p">.</span><span class="n">read_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Return immediately if there is nothing to do.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">status_t</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(__ANDROID__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="c1">//通过ioctl写入binder驱动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nf">ioctl</span><span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mDriverFD</span><span class="p">,</span> <span class="n">BINDER_WRITE_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bwr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">            <span class="n">err</span> <span class="o">=</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="n">err</span> <span class="o">=</span> <span class="n">INVALID_OPERATION</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mDriverFD</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//成功写入了数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span> <span class="o">&lt;</span> <span class="n">mOut</span><span class="p">.</span><span class="nf">dataSize</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//输出数据已经写入binder驱动，清空输出缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">mOut</span><span class="p">.</span><span class="nf">setDataSize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">processPostWriteDerefs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//存在回传数据，重置输入缓冲区的读取下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">//成功读取到了数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">mIn</span><span class="p">.</span><span class="nf">setDataSize</span><span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">mIn</span><span class="p">.</span><span class="nf">setDataPosition</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在IPCThreadState.h定义<code>talkWithDriver</code> 函数时，<code>doReceive</code>的默认值为<code>true</code>,waitForResponse() 中没有传入参数，所以这里的 doReceive 为 true。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="kt">status_t</span>            <span class="nf">talkWithDriver</span><span class="p">(</span><span class="kt">bool</span> <span class="n">doReceive</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
</span></span></code></pre></div><p><code>binder_write_read</code> 是 binder 驱动与用户态共用的、存储读写操作的结构体，在 binder 驱动内部依赖 <code>binder_write_read</code> 决定是要读取还是写入数据：其内部变量 <code>read_size&gt;0</code> 则代表要读取数据，<code>write_size&gt;0</code> 代表要写入数据，若都大于 0 则先写入，后读取。<code>binder_write_read</code>结构体定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">binder_write_read</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">binder_size_t</span>		<span class="n">write_size</span><span class="p">;</span>	<span class="cm">/* bytes to write */</span> <span class="c1">//要写入的字节数,write_buffer的总字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">binder_size_t</span>		<span class="n">write_consumed</span><span class="p">;</span>	<span class="cm">/* bytes consumed by driver */</span><span class="c1">//驱动程序占用的字节数,write_buffer已消费的字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">binder_uintptr_t</span>	<span class="n">write_buffer</span><span class="p">;</span><span class="c1">//写缓冲数据的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">binder_size_t</span>		<span class="n">read_size</span><span class="p">;</span>	<span class="cm">/* bytes to read */</span><span class="c1">//要读的字节数,read_buffer的总字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">binder_size_t</span>		<span class="n">read_consumed</span><span class="p">;</span>	<span class="cm">/* bytes consumed by driver */</span><span class="c1">//驱动程序占用的字节数,read_buffer已消费的字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">binder_uintptr_t</span>	<span class="n">read_buffer</span><span class="p">;</span><span class="c1">//读缓存数据的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>这样基本完成了数据的发送过程，其中主要的数据类型结构体一定要记住，很重要；</p>
<ol>
<li><code>flat_binder_object</code>封装<code>service</code>的结构体，其中重要的参数是binder、handle、cookie</li>
<li><code>binder_transaction_data</code>组装<code>Parcel</code>数据的结构体;</li>
<li><code>binder_write_read</code> 是binder 驱动与用户态共用的、存储读写操作的结构体</li>
</ol>
<h3 id="binder-数据接收过程">Binder 数据接收过程<a hidden class="anchor" aria-hidden="true" href="#binder-数据接收过程">#</a></h3>
<p>Binder 线程用于在 Server 中接收处理从 Binder 驱动发送来的数据。<code>startThreadPool</code>提及的函数 <code>IPCThreadState.joinThreadPool</code> 将自己注册到 Binder 线程池，等待接收数据。</p>
<p>在<code>joinThreadPool</code> 函数中，循环执行<code>getAndExecuteCommand</code>,调用 <code>talkWithDriver</code> 从 <code>mIn</code> 窗口解析出需要执行的命令后，执行 <code>executeCommand</code>。在<code>executeCommand</code>的<code>BR_TRANSACTION</code>分支，其中 <code>the_context_object</code> 为 <code>BBinder</code> 对象，也就是 Server 的 Binder 本体。<code>BBinder.transact</code> 会再调用 <code>BBinder.onTransact</code> 函数，实现 Server 进程 Binder 的调用。</p>
<p>而在<code>ServiceManager</code>采用了<code>LooperCallback</code>方式监听binder数据，最终也是循环执行<code>getAndExecuteCommand</code>；这部分的分析会在创建<code>ServiceManager</code>进程详细分析；</p>
<p>接收数据时也在<code>talkWithDriver</code>中ioctl读写获取一个<code>binder_write_read</code>结构体，在<code>executeCommand</code>的<code>BR_TRANSACTION</code>分支中在把数据进一步解析<code>binder_transaction_data</code>结构体并将相应的输入数据转换<code>buffer</code>，<code>buffer</code>是<code>Parcel</code>对象，在 <code>BBinder</code> 的<code>onTransact</code>函数会在<code>BnServiceManager</code>重载<code>onTransact</code>函数；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">status_t</span> <span class="n">BnServiceManager</span><span class="o">::</span><span class="nf">onTransact</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">code</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parcel</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">Parcel</span><span class="o">*</span> <span class="n">reply</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//printf(&#34;ServiceManager received: &#34;); data.print();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">GET_SERVICE_TRANSACTION</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IServiceManager</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">String16</span> <span class="n">which</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">readString16</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">BnServiceManager</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">getService</span><span class="p">(</span><span class="n">which</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">reply</span><span class="o">-&gt;</span><span class="nf">writeStrongBinder</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">CHECK_SERVICE_TRANSACTION</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IServiceManager</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">String16</span> <span class="n">which</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">readString16</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">BnServiceManager</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">checkService</span><span class="p">(</span><span class="n">which</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">reply</span><span class="o">-&gt;</span><span class="nf">writeStrongBinder</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">ADD_SERVICE_TRANSACTION</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IServiceManager</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">String16</span> <span class="n">which</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">readString16</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">readStrongBinder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="kt">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="nf">addService</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">reply</span><span class="o">-&gt;</span><span class="nf">writeInt32</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">LIST_SERVICES_TRANSACTION</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IServiceManager</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">Vector</span><span class="o">&lt;</span><span class="n">String16</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nf">listServices</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="kt">size_t</span> <span class="n">N</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="nf">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">reply</span><span class="o">-&gt;</span><span class="nf">writeInt32</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">reply</span><span class="o">-&gt;</span><span class="nf">writeString16</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">BBinder</span><span class="o">::</span><span class="nf">onTransact</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在<code>ADD_SERVICE_TRANSACTION</code>分支，会通过<code>Parcel</code>的<code>readStrongBinder</code>函数将数据读取<code>flat_binder_object</code>结构体，再获取IBinder弱引用指针地址；其中主要执行的函数是<code>unflattenBinder</code>;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">status_t</span> <span class="n">Parcel</span><span class="o">::</span><span class="nf">unflattenBinder</span><span class="p">(</span><span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;*</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">flat_binder_object</span><span class="o">*</span> <span class="n">flat</span> <span class="o">=</span> <span class="nf">readObject</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">flat</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="p">(</span><span class="n">flat</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nl">BINDER_TYPE_BINDER</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">binder</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">flat</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nf">finishUnflattenBinder</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nl">BINDER_TYPE_HANDLE</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">binder</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ProcessState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">getStrongProxyForHandle</span><span class="p">(</span><span class="n">flat</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nf">finishUnflattenBinder</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">BAD_TYPE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最后会调用<code>ServiceManager</code>的<code>addService</code>函数；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Status</span> <span class="n">ServiceManager</span><span class="o">::</span><span class="nf">addService</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">binder</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">allowIsolated</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">dumpPriority</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">mAccess</span><span class="o">-&gt;</span><span class="nf">getCallingContext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// apps cannot add services
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">multiuser_get_app_id</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">AID_APP</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="nf">fromExceptionCode</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">EX_SECURITY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mAccess</span><span class="o">-&gt;</span><span class="nf">canAdd</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="nf">fromExceptionCode</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">EX_SECURITY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">binder</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="nf">fromExceptionCode</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">EX_ILLEGAL_ARGUMENT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">isValidServiceName</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Invalid service name: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="nf">fromExceptionCode</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">EX_ILLEGAL_ARGUMENT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// implicitly unlinked when the binder is removed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">binder</span><span class="o">-&gt;</span><span class="nf">remoteBinder</span><span class="p">()</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">binder</span><span class="o">-&gt;</span><span class="nf">linkToDeath</span><span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="o">!=</span> <span class="n">OK</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Could not linkToDeath when adding &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="nf">fromExceptionCode</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">EX_ILLEGAL_STATE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">mNameToService</span><span class="p">.</span><span class="nf">emplace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Service</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">binder</span> <span class="o">=</span> <span class="n">binder</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">allowIsolated</span> <span class="o">=</span> <span class="n">allowIsolated</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">dumpPriority</span> <span class="o">=</span> <span class="n">dumpPriority</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">debugPid</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">debugPid</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">mNameToRegistrationCallback</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">mNameToRegistrationCallback</span><span class="p">.</span><span class="nf">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceCallback</span><span class="o">&gt;&amp;</span> <span class="nl">cb</span> <span class="p">:</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">entry</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">guaranteeClient</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// permission checked in registerForNotifications
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cb</span><span class="o">-&gt;</span><span class="nf">onRegistration</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">binder</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="nf">ok</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>addService</code>函数中主要执行的是将Ibinder对象封装成<code>Service</code>结构体，并于<code>name</code>为key插入<code>mNameToService</code>中，而<code>mNameToService</code>是一个<code>std::map&lt;std::string, Service&gt;</code>；这样<code>addService</code>在除了内核部分的代码算是基本完成;binder驱动中的数据传递会在binder驱动分析中进行解析；</p>
<p>数据传递过程如下：</p>
<p><img loading="lazy" src="img/binder_write_read.png" alt="binder数据传递"  />
</p>
<h2 id="servicemanager进程创建"><code>ServiceManager</code>进程创建<a hidden class="anchor" aria-hidden="true" href="#servicemanager进程创建">#</a></h2>
<p>启动的<code>main</code>函数在<code>frameworks/native/cmds/servicemanager/main.cpp</code>中，其中关键步骤和media进行类型；</p>
<ol>
<li>创建<code>ProcessState</code>,<code>ServiceManager</code>进程没有调用<code>self</code>，而是通过<code>initWithDriver</code> 创建，其实关键代码还是一样的，实现了单例模式，通过<code>initWithDriver</code> 获取实例；并通过<code>setThreadPoolMaxThreadCount</code>设置最大线程数为0；</li>
<li>创建<code>ServiceManager</code>实例，同样使用<code>addService</code>函数同样把<code>ServiceManager</code>插入<code>mNameToService</code>中；并创建<code>IPCThreadState</code>实通过<code>setTheContextObject</code>设置the_context_object为<code>ServiceManager</code> ;</li>
<li>通过<code>ProcessState</code>的<code>becomeContextManager</code>函数设置<code>ServiceManager</code>进程为binder驱动的上下文管理者；</li>
<li>通过<code>Looper::prepare</code>创建<code>Looper</code>,<code>Looper</code>也是和<code>IPCThreadState</code>一样线程单例，这里可以理解成是java中<code>handle</code>事件中的<code>looper</code>,后续会再对native层的<code>Looper</code>进行详细分析；并<code>BinderCallback</code>的<code>setupTo</code>注册<code>Looper</code>的事件监听和<code>ClientCallbackCallback</code>的<code>setupTo</code>注册<code>Looper</code>的事件；</li>
<li>进入死循环，调用 <code>looper-&gt;pollAll</code>函数，实则是在<code>epoll_wait</code>等待消息;</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">LOG</span><span class="p">(</span><span class="n">FATAL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;usage: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; [binder driver]&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">driver</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="s">&#34;/dev/binder&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  	<span class="c1">//创建ProcessState，并打开binder驱动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sp</span><span class="o">&lt;</span><span class="n">ProcessState</span><span class="o">&gt;</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">ProcessState</span><span class="o">::</span><span class="nf">initWithDriver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  	<span class="c1">//设置最大线程数为了0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ps</span><span class="o">-&gt;</span><span class="nf">setThreadPoolMaxThreadCount</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ps</span><span class="o">-&gt;</span><span class="nf">setCallRestriction</span><span class="p">(</span><span class="n">ProcessState</span><span class="o">::</span><span class="n">CallRestriction</span><span class="o">::</span><span class="n">FATAL_IF_NOT_ONEWAY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//创建ServiceManager实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sp</span><span class="o">&lt;</span><span class="n">ServiceManager</span><span class="o">&gt;</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">new</span> <span class="nf">ServiceManager</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Access</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">manager</span><span class="o">-&gt;</span><span class="nf">addService</span><span class="p">(</span><span class="s">&#34;manager&#34;</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="nb">false</span> <span class="cm">/*allowIsolated*/</span><span class="p">,</span> <span class="n">IServiceManager</span><span class="o">::</span><span class="n">DUMP_FLAG_PRIORITY_DEFAULT</span><span class="p">).</span><span class="nf">isOk</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Could not self register servicemanager&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  	<span class="c1">//创建IPCThreadState实例和设置IPCThreadState的上下文管理者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">setTheContextObject</span><span class="p">(</span><span class="n">manager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  	<span class="c1">//设置ServiceManager进程为binder的上下文管理者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ps</span><span class="o">-&gt;</span><span class="nf">becomeContextManager</span><span class="p">(</span><span class="n">nullptr</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  	<span class="c1">//创建looper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sp</span><span class="o">&lt;</span><span class="n">Looper</span><span class="o">&gt;</span> <span class="n">looper</span> <span class="o">=</span> <span class="n">Looper</span><span class="o">::</span><span class="nf">prepare</span><span class="p">(</span><span class="nb">false</span> <span class="cm">/*allowNonCallbacks*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//创建looper事件监听回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">BinderCallback</span><span class="o">::</span><span class="nf">setupTo</span><span class="p">(</span><span class="n">looper</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  	<span class="c1">//把ClientCallbackCallback作为回调，注册进入Lopper，其中创建了一个定时器对象，5秒跑一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ClientCallbackCallback</span><span class="o">::</span><span class="nf">setupTo</span><span class="p">(</span><span class="n">looper</span><span class="p">,</span> <span class="n">manager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      	<span class="c1">//循环等待驱动是否有事件返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">looper</span><span class="o">-&gt;</span><span class="nf">pollAll</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// should not be reached
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>再<code>BinderCallback</code>中如果有事件返回会回调<code>handleEvent</code>，然后执行<code>IPCThreadState::handlePolledCommands</code>;再看看<code>handlePolledCommands</code>函数中执行了<code>getAndExecuteCommand</code>;<code>getAndExecuteCommand</code>在<code>IPCThreadState::joinThreadPool</code>函数中已经提到过了，是用于读取binder驱动的数据和命令字段的解析处理；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="nf">handlePolledCommands</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">status_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//读取binder驱动数据，命令字段解析和处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="nf">getAndExecuteCommand</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mIn</span><span class="p">.</span><span class="nf">dataPosition</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">mIn</span><span class="p">.</span><span class="nf">dataSize</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//清空输入缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">processPendingDerefs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//执行完成指令，并把Client需要应答的参数写入binder驱动中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">flushCommands</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样<code>ServiceManager</code>进程的启动和消息监听也就分析完成了！</p>
<p>那我们要想想</p>
<ol>
<li>binder驱动是如果把Client端的数据进行一次拷贝到<code>ServiceManager</code>进程中来读取的呢？</li>
<li><code>ServiceManager</code>进程又是如何成为binder驱动的上下文管理者？</li>
<li>binder驱动如何管理每个进程的binder服务呢？</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://rong05.github.io/learn/android/android_selinux/">
    <span class="title">Next »</span>
    <br>
    <span></span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on x"
        href="https://x.com/intent/tweet/?text=&amp;url=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fandroid_binder%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z"/>
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fandroid_binder%2f&amp;title=&amp;summary=&amp;source=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fandroid_binder%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fandroid_binder%2f&title=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fandroid_binder%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on whatsapp"
        href="https://api.whatsapp.com/send?text=%20-%20https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fandroid_binder%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on telegram"
        href="https://telegram.me/share/url?text=&amp;url=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fandroid_binder%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on ycombinator"
        href="https://news.ycombinator.com/submitlink?t=&u=https%3a%2f%2frong05.github.io%2flearn%2fandroid%2fandroid_binder%2f">
        <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
            xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
            <path
                d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://rong05.github.io/">LEAN</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>

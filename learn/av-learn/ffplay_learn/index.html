<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LEAN</title>
<meta name="keywords" content="">
<meta name="description" content="[TOC]
ffplay源码分析 熟悉FFmpeg项目从源码看起，以下是我阅读FFplay的源代码的总结；FFplay是FFmpeg项目提供的播放器示例，它的源代码的量也是不少的，其中很多知识点是我们可以学习和借鉴的。
总结构图 参照雷神（雷霄骅）的FFplay的总体函数调用结构图，自己总结了一个最新版本的结构，其中还有诸多不足，以后有机会慢慢完善；如下图所示。
这就不对主要函数分别解析，我来学习一下其中关键性的思想和ffplay的体系结构。
视频部分 ffplay video的线程模式 ffplay选择了sdl作为显示SDK，以实现跨平台支持；因为使用了SDL，而video的显示也依赖SDL的窗口显示系统，所以先从main函数的SDL初始化看起：
int main(int argc, char **argv) { ... /* register all codecs, demux and protocols */ #if CONFIG_AVDEVICE avdevice_register_all(); //注册所有解码器 #endif avformat_network_init(); init_opts(); signal(SIGINT, sigterm_handler); /* Interrupt (ANSI). */ signal(SIGTERM, sigterm_handler); /* Termination (ANSI). */ show_banner(argc, argv, options); //打印ffmpag库版本信息，编译时间，编译选项，类库信息等 parse_options(NULL, argc, argv, options, opt_input_file); //解析输入的命令。 ... if (SDL_Init(flags)) { //初始化sdl av_log(NULL, AV_LOG_FATAL, &#34;Could not initialize SDL - %s\n&#34;, SDL_GetError()); av_log(NULL, AV_LOG_FATAL, &#34;(Did you set the DISPLAY variable?">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://rong05.github.io/learn/av-learn/ffplay_learn/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0c4fd3725171366f335155acde6fb3c7b7042cd2fd075bebf5023d9b28a701b2.css" integrity="sha256-DE/TclFxNm8zUVWs3m&#43;zx7cELNL9B1vr9QI9myinAbI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://rong05.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rong05.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rong05.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rong05.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rong05.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://rong05.github.io/learn/av-learn/ffplay_learn/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="[TOC]
ffplay源码分析 熟悉FFmpeg项目从源码看起，以下是我阅读FFplay的源代码的总结；FFplay是FFmpeg项目提供的播放器示例，它的源代码的量也是不少的，其中很多知识点是我们可以学习和借鉴的。
总结构图 参照雷神（雷霄骅）的FFplay的总体函数调用结构图，自己总结了一个最新版本的结构，其中还有诸多不足，以后有机会慢慢完善；如下图所示。
这就不对主要函数分别解析，我来学习一下其中关键性的思想和ffplay的体系结构。
视频部分 ffplay video的线程模式 ffplay选择了sdl作为显示SDK，以实现跨平台支持；因为使用了SDL，而video的显示也依赖SDL的窗口显示系统，所以先从main函数的SDL初始化看起：
int main(int argc, char **argv) { ... /* register all codecs, demux and protocols */ #if CONFIG_AVDEVICE avdevice_register_all(); //注册所有解码器 #endif avformat_network_init(); init_opts(); signal(SIGINT, sigterm_handler); /* Interrupt (ANSI). */ signal(SIGTERM, sigterm_handler); /* Termination (ANSI). */ show_banner(argc, argv, options); //打印ffmpag库版本信息，编译时间，编译选项，类库信息等 parse_options(NULL, argc, argv, options, opt_input_file); //解析输入的命令。 ... if (SDL_Init(flags)) { //初始化sdl av_log(NULL, AV_LOG_FATAL, &#34;Could not initialize SDL - %s\n&#34;, SDL_GetError()); av_log(NULL, AV_LOG_FATAL, &#34;(Did you set the DISPLAY variable?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rong05.github.io/learn/av-learn/ffplay_learn/" /><meta property="og:image" content="https://rong05.github.io/papermod-cover.png"/><meta property="article:section" content="learn" />



<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://rong05.github.io/papermod-cover.png"/>

<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="[TOC]
ffplay源码分析 熟悉FFmpeg项目从源码看起，以下是我阅读FFplay的源代码的总结；FFplay是FFmpeg项目提供的播放器示例，它的源代码的量也是不少的，其中很多知识点是我们可以学习和借鉴的。
总结构图 参照雷神（雷霄骅）的FFplay的总体函数调用结构图，自己总结了一个最新版本的结构，其中还有诸多不足，以后有机会慢慢完善；如下图所示。
这就不对主要函数分别解析，我来学习一下其中关键性的思想和ffplay的体系结构。
视频部分 ffplay video的线程模式 ffplay选择了sdl作为显示SDK，以实现跨平台支持；因为使用了SDL，而video的显示也依赖SDL的窗口显示系统，所以先从main函数的SDL初始化看起：
int main(int argc, char **argv) { ... /* register all codecs, demux and protocols */ #if CONFIG_AVDEVICE avdevice_register_all(); //注册所有解码器 #endif avformat_network_init(); init_opts(); signal(SIGINT, sigterm_handler); /* Interrupt (ANSI). */ signal(SIGTERM, sigterm_handler); /* Termination (ANSI). */ show_banner(argc, argv, options); //打印ffmpag库版本信息，编译时间，编译选项，类库信息等 parse_options(NULL, argc, argv, options, opt_input_file); //解析输入的命令。 ... if (SDL_Init(flags)) { //初始化sdl av_log(NULL, AV_LOG_FATAL, &#34;Could not initialize SDL - %s\n&#34;, SDL_GetError()); av_log(NULL, AV_LOG_FATAL, &#34;(Did you set the DISPLAY variable?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Learns",
      "item": "https://rong05.github.io/learn/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://rong05.github.io/learn/av-learn/ffplay_learn/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "[TOC]\nffplay源码分析 熟悉FFmpeg项目从源码看起，以下是我阅读FFplay的源代码的总结；FFplay是FFmpeg项目提供的播放器示例，它的源代码的量也是不少的，其中很多知识点是我们可以学习和借鉴的。\n总结构图 参照雷神（雷霄骅）的FFplay的总体函数调用结构图，自己总结了一个最新版本的结构，其中还有诸多不足，以后有机会慢慢完善；如下图所示。\n这就不对主要函数分别解析，我来学习一下其中关键性的思想和ffplay的体系结构。\n视频部分 ffplay video的线程模式 ffplay选择了sdl作为显示SDK，以实现跨平台支持；因为使用了SDL，而video的显示也依赖SDL的窗口显示系统，所以先从main函数的SDL初始化看起：\nint main(int argc, char **argv) { ... /* register all codecs, demux and protocols */ #if CONFIG_AVDEVICE avdevice_register_all(); //注册所有解码器 #endif avformat_network_init(); init_opts(); signal(SIGINT, sigterm_handler); /* Interrupt (ANSI). */ signal(SIGTERM, sigterm_handler); /* Termination (ANSI). */ show_banner(argc, argv, options); //打印ffmpag库版本信息，编译时间，编译选项，类库信息等 parse_options(NULL, argc, argv, options, opt_input_file); //解析输入的命令。 ... if (SDL_Init(flags)) { //初始化sdl av_log(NULL, AV_LOG_FATAL, \u0026#34;Could not initialize SDL - %s\\n\u0026#34;, SDL_GetError()); av_log(NULL, AV_LOG_FATAL, \u0026#34;(Did you set the DISPLAY variable?",
  "keywords": [
    
  ],
  "articleBody": "[TOC]\nffplay源码分析 熟悉FFmpeg项目从源码看起，以下是我阅读FFplay的源代码的总结；FFplay是FFmpeg项目提供的播放器示例，它的源代码的量也是不少的，其中很多知识点是我们可以学习和借鉴的。\n总结构图 参照雷神（雷霄骅）的FFplay的总体函数调用结构图，自己总结了一个最新版本的结构，其中还有诸多不足，以后有机会慢慢完善；如下图所示。\n这就不对主要函数分别解析，我来学习一下其中关键性的思想和ffplay的体系结构。\n视频部分 ffplay video的线程模式 ffplay选择了sdl作为显示SDK，以实现跨平台支持；因为使用了SDL，而video的显示也依赖SDL的窗口显示系统，所以先从main函数的SDL初始化看起：\nint main(int argc, char **argv) { ... /* register all codecs, demux and protocols */ #if CONFIG_AVDEVICE avdevice_register_all(); //注册所有解码器 #endif avformat_network_init(); init_opts(); signal(SIGINT, sigterm_handler); /* Interrupt (ANSI). */ signal(SIGTERM, sigterm_handler); /* Termination (ANSI). */ show_banner(argc, argv, options); //打印ffmpag库版本信息，编译时间，编译选项，类库信息等 parse_options(NULL, argc, argv, options, opt_input_file); //解析输入的命令。 ... if (SDL_Init(flags)) { //初始化sdl av_log(NULL, AV_LOG_FATAL, \"Could not initialize SDL - %s\\n\", SDL_GetError()); av_log(NULL, AV_LOG_FATAL, \"(Did you set the DISPLAY variable?)\\n\"); exit(1); } SDL_EventState(SDL_SYSWMEVENT, SDL_IGNORE); SDL_EventState(SDL_USEREVENT, SDL_IGNORE); //注册flush packet 只是一个标记作用，用于packet队列中，在对packet队列分析时有说明 av_init_packet(\u0026flush_pkt); flush_pkt.data = (uint8_t *)\u0026flush_pkt; ... if (!display_disable) { int flags = SDL_WINDOW_HIDDEN; if (alwaysontop) #if SDL_VERSION_ATLEAST(2, 0, 5) flags |= SDL_WINDOW_ALWAYS_ON_TOP; #else av_log(NULL, AV_LOG_WARNING, \"Your SDL version doesn't support SDL_WINDOW_ALWAYS_ON_TOP. Feature will be inactive.\\n\"); #endif if (borderless) flags |= SDL_WINDOW_BORDERLESS; else flags |= SDL_WINDOW_RESIZABLE; //创建sdl 窗口 window = SDL_CreateWindow(program_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, default_width, default_height, flags); SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"linear\"); if (window) { //创建sdl 窗口的渲染器 renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC); if (!renderer) { av_log(NULL, AV_LOG_WARNING, \"Failed to initialize a hardware accelerated renderer: %s\\n\", SDL_GetError()); renderer = SDL_CreateRenderer(window, -1, 0); } if (renderer) { if (!SDL_GetRendererInfo(renderer, \u0026renderer_info)) av_log(NULL, AV_LOG_VERBOSE, \"Initialized %s renderer.\\n\", renderer_info.name); } } if (!window || !renderer || !renderer_info.num_texture_formats) { av_log(NULL, AV_LOG_FATAL, \"Failed to create window or renderer: %s\", SDL_GetError()); do_exit(NULL); } } is = stream_open(input_filename, file_iformat); //创建read_thread if (!is) { av_log(NULL, AV_LOG_FATAL, \"Failed to initialize VideoState!\\n\"); do_exit(NULL); } event_loop(is); //主线程 ，sdl——event事件监听和处理 } 而这里我们主要的两个函数是stream_open和event_loop；stream_open函数的作用是创建read_thread，read_thread会打开文件，解析封装，获取AVStream信息，启动解码器（创建解码线程），并开始读取文件；event_loop函数的作用是处理SDL事件队列中的事件和刷新显示数据，下面会针对这两个函数视频部分的内容进行详细说明。\nstream_open 其实在stream_open函数里的关键内容都是初始化一些参数，主要的处理逻辑在read_thread中进行。\nstatic VideoState *stream_open(const char *filename, AVInputFormat *iformat) { VideoState *is; is = av_mallocz(sizeof(VideoState)); //创建VideoState 这个很重要，它贯穿整个ffplay ... /* start video display */ //初始化解码后的帧队列 if (frame_queue_init(\u0026is-\u003epictq, \u0026is-\u003evideoq, VIDEO_PICTURE_QUEUE_SIZE, 1) \u003c 0) goto fail; ... //初始化解码前的帧队列 if (packet_queue_init(\u0026is-\u003evideoq) \u003c 0 || ... //创建读线程的条件信号 if (!(is-\u003econtinue_read_thread = SDL_CreateCond())) { av_log(NULL, AV_LOG_FATAL, \"SDL_CreateCond(): %s\\n\", SDL_GetError()); goto fail; } //初始化时钟 init_clock(\u0026is-\u003evidclk, \u0026is-\u003evideoq.serial); ... is-\u003eread_tid = SDL_CreateThread(read_thread, \"read_thread\", is); //创建读线程 ... fail: stream_close(is);//出错free一些初始化参数 return NULL; } **VideoState**结构的参数详细说明：\n/*视频状态器，贯穿整个ffplay的结构*/ typedef struct VideoState { SDL_Thread *read_tid; //解复用（或读）线程 AVInputFormat *iformat; //输入格式 int abort_request; //中止请求 int force_refresh; //强制刷新 int paused; //暂停 int last_paused; //最后一次暂停状态 int queue_attachments_req; //队列附件请求 int seek_req; //快进请求 int seek_flags; //快进标志 int64_t seek_pos; //快进位置 int64_t seek_rel; int read_pause_return; //读暂停 AVFormatContext *ic; //解码格式上下文 int realtime; //是否实时码流 Clock audclk; //音频时钟 Clock vidclk; //视频时钟 Clock extclk; //外部时钟 FrameQueue pictq; //视频队列 FrameQueue subpq; //字幕队列 FrameQueue sampq; //pcm流队列 Decoder auddec; //音频解码器 Decoder viddec; //视频解码器 Decoder subdec; //字幕解码器 int audio_stream; //音频码流id int av_sync_type; //时钟同步类型 double audio_clock; int audio_clock_serial; //音频时钟序号 double audio_diff_cum; // 用于音频差分计算 /* used for AV difference average computation */ double audio_diff_avg_coef; double audio_diff_threshold; //音频差分阈值 int audio_diff_avg_count; // 平均差分数量 AVStream *audio_st; // 音频码流 PacketQueue audioq; // 音频源包队列 int audio_hw_buf_size; // 硬件缓冲大小 uint8_t *audio_buf; // 音频缓冲区 uint8_t *audio_buf1; // 音频缓冲区1 unsigned int audio_buf_size; // 音频缓冲大小 /* in bytes */ unsigned int audio_buf1_size; // 音频缓冲大小 1 int audio_buf_index; /* in bytes */ // 音频缓冲索引 int audio_write_buf_size; // 音频写入缓冲大小 int audio_volume; // 音量 int muted; // 是否静音 struct AudioParams audio_src; // 音频参数 #if CONFIG_AVFILTER struct AudioParams audio_filter_src; // 音频过滤器 #endif struct AudioParams audio_tgt; // 音频参数 struct SwrContext *swr_ctx; // 音频转码上下文 int frame_drops_early; int frame_drops_late; enum ShowMode { // 显示类型 SHOW_MODE_NONE = -1, SHOW_MODE_VIDEO = 0, SHOW_MODE_WAVES, SHOW_MODE_RDFT, SHOW_MODE_NB } show_mode; int16_t sample_array[SAMPLE_ARRAY_SIZE]; // 采样数组 int sample_array_index; // 采样索引 int last_i_start; // 上一开始 RDFTContext *rdft; // 自适应滤波器上下文 int rdft_bits; // 自使用比特率 FFTSample *rdft_data; // 快速傅里叶采样 int xpos; double last_vis_time; SDL_Texture *vis_texture; // 音频Texture SDL_Texture *sub_texture; // 字幕Texture SDL_Texture *vid_texture; // 视频Texture int subtitle_stream; // 字幕码流Id AVStream *subtitle_st; // 字幕码流 PacketQueue subtitleq; // 字幕源包队列 double frame_timer; // 帧计时器 double frame_last_returned_time; // 上一次返回时间 double frame_last_filter_delay; // 上一个过滤器延时 int video_stream; // 视频码流Id AVStream *video_st; // 视频码流 PacketQueue videoq; // 视频包队列 double max_frame_duration; // 最大帧间显示时间 // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity struct SwsContext *img_convert_ctx; // 视频转码上下文 struct SwsContext *sub_convert_ctx; // 字幕转码上下文 int eof; // 结束标志 char *filename; // 文件名 int width, height, xleft, ytop; // 宽高，其实坐标 int step; #if CONFIG_AVFILTER int vfilter_idx; // 过滤器索引 AVFilterContext *in_video_filter; // the first filter in the video chain AVFilterContext *out_video_filter; // the last filter in the video chain AVFilterContext *in_audio_filter; // the first filter in the audio chain AVFilterContext *out_audio_filter; // the last filter in the audio chain AVFilterGraph *agraph; // audio filter graph #endif int last_video_stream, last_audio_stream, last_subtitle_stream; SDL_cond *continue_read_thread; } VideoState; 读取线程(read_thread) read_thread主要按以下步骤执行：\n准备阶段：打开文件，检测Stream信息，打开解码器 主循环读数据，解封装：读取Packet，存入PacketQueue read_thread的函数比较长，这里不贴完整代码，直接根据其功能分步分析。\n准备阶段 主要执行一下几个步骤的函数：\navformat_open_input avformat_find_stream_info av_find_best_stream stream_component_open avformat_open_input 该函数用于打开输入流（这个包括文件和网络流，在ffmpeg内部会把每一个协议封装成URLProtocol，文件对于ffmpeg也是一种协议“file”）\nic = avformat_alloc_context(); //创建 AVformatContext if (!ic) { av_log(NULL, AV_LOG_FATAL, \"Could not allocate context.\\n\"); ret = AVERROR(ENOMEM); goto fail; } //设置解码中断回调方法 ，这很重要，在网络中断的时候，发生调用；不设置很容易造成阻塞 ic-\u003einterrupt_callback.callback = decode_interrupt_cb; ic-\u003einterrupt_callback.opaque = is; if (!av_dict_get(format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE)) { av_dict_set(\u0026format_opts, \"scan_all_pmts\", \"1\", AV_DICT_DONT_OVERWRITE); scan_all_pmts_set = 1; } err = avformat_open_input(\u0026ic, is-\u003efilename, is-\u003eiformat, \u0026format_opts); //打开文件或网络流 if (err \u003c 0) { print_error(is-\u003efilename, err); ret = -1; goto fail; } 重点强调：**interrupt_callback**用于ffmpeg内部在执行耗时操作时检查是否有退出请求，并提前中断，避免用户退出请求没有及时响应；\navformat_find_stream_info 该函数是通过读取媒体文件的部分数据来分析流信息；在一些缺少头信息的封装下特别有用，如注释：\nRead packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat rame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing. av_find_best_stream 该函数选择对应的媒体流，ffplay主要通过下述注释中的3个参数找到“最佳流”；\nint av_find_best_stream(AVFormatContext *ic, enum AVMediaType type,//要选择的流类型 int wanted_stream_nb,//目标流索引 int related_stream,//参考流索引 AVCodec **decoder_ret, int flags); stream_component_open 该函数是根据目标流打开对应的解码器；stream_component_open的函数内容比较长，接下来就逐步分析一下ffplay是如何打开解码器的：\n创建和初始化AVCodecContex，然后通过avcodec_parameters_to_context把所选流的解码参数赋给avctx，最后设了time_base.代码如下： //创建编解码器上下文 avctx = avcodec_alloc_context3(NULL); if (!avctx) return AVERROR(ENOMEM); //从找到对应的流中的codecpar，codecpar其实是avcodec_parameters， // 然后将它完全复制到创建的AVCodecContext ret = avcodec_parameters_to_context(avctx, ic-\u003estreams[stream_index]-\u003ecodecpar); if (ret \u003c 0) goto fail; avctx-\u003epkt_timebase = ic-\u003estreams[stream_index]-\u003etime_base; 通过avcodec_find_decoder找到对应的解码器（AVCodec）,如果用户设置了forced_codec_name，则通过avcodec_find_decoder_by_name找到对应的解码器；在找到解码器后通过avcodec_open2是否能打开解码器\ncodec = avcodec_find_decoder(avctx-\u003ecodec_id); //找到对应的解码器 switch (avctx-\u003ecodec_type) { case AVMEDIA_TYPE_AUDIO: is-\u003elast_audio_stream = stream_index; forced_codec_name = audio_codec_name; break; case AVMEDIA_TYPE_SUBTITLE: is-\u003elast_subtitle_stream = stream_index; forced_codec_name = subtitle_codec_name; break; case AVMEDIA_TYPE_VIDEO: is-\u003elast_video_stream = stream_index; forced_codec_name = video_codec_name; break; } //通过编码器的名字，来打开对应的解码器 if (forced_codec_name) codec = avcodec_find_decoder_by_name(forced_codec_name); if (!codec) { if (forced_codec_name) av_log(NULL, AV_LOG_WARNING, \"No codec could be found with name '%s'\\n\", forced_codec_name); else av_log(NULL, AV_LOG_WARNING, \"No decoder could be found for codec %s\\n\", avcodec_get_name(avctx-\u003ecodec_id)); ret = AVERROR(EINVAL); goto fail; } ... //打开解码器 if ((ret = avcodec_open2(avctx, codec, \u0026opts)) \u003c 0) { goto fail; } 对于解码器特定参数的初始化和创建对应流的解码线程；（节选自AVMEDIA_TYPE_VIDEO分支）\nis-\u003evideo_stream = stream_index; is-\u003evideo_st = ic-\u003estreams[stream_index]; decoder_init(\u0026is-\u003eviddec, avctx, \u0026is-\u003evideoq, is-\u003econtinue_read_thread); if ((ret = decoder_start(\u0026is-\u003eviddec, video_thread, \"video_decoder\", is)) \u003c 0) goto out; is-\u003equeue_attachments_req = 1; 看看decoder_init和decoder_start两个函数的定义：\nstatic void decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond) { memset(d, 0, sizeof(Decoder)); d-\u003eavctx = avctx; d-\u003equeue = queue; d-\u003eempty_queue_cond = empty_queue_cond; d-\u003estart_pts = AV_NOPTS_VALUE; d-\u003epkt_serial = -1; } static int decoder_start(Decoder *d, int (*fn)(void *), const char *thread_name, void *arg) { packet_queue_start(d-\u003equeue); d-\u003edecoder_tid = SDL_CreateThread(fn, thread_name, arg); if (!d-\u003edecoder_tid) { av_log(NULL, AV_LOG_ERROR, \"SDL_CreateThread(): %s\\n\", SDL_GetError()); return AVERROR(ENOMEM); } return 0; } decoder_init比较简单，看decoder_start。decoder_start中“启动”了PacketQueue，并创建了一个名为\"decoder\"的线程专门用于解码，具体的解码流程由传入参数fn决定。比如对于视频，是video_thread。\n主循环读数据 在读线程中的主循环读数据阶段，主要的代码就av_read_frame和packet_queue_put，av_read_frame从文件中读取视频数据，并获取一个AVPacket，packet_queue_put把它放入到对应的PacketQueue中。\nfor (;;) { if (is-\u003eabort_request) //中断，结束播放 break; if (is-\u003epaused != is-\u003elast_paused)//暂停/恢复的处理 { ... } if (is-\u003eseek_req) { //跳帧请求 ... } /* if the queue are full, no need to read more */ //数据队列满的情况 if (infinite_buffer \u003c 1 \u0026\u0026 (is-\u003eaudioq.size + is-\u003evideoq.size + is-\u003esubtitleq.size \u003e MAX_QUEUE_SIZE || (stream_has_enough_packets(is-\u003eaudio_st, is-\u003eaudio_stream, \u0026is-\u003eaudioq) \u0026\u0026 stream_has_enough_packets(is-\u003evideo_st, is-\u003evideo_stream, \u0026is-\u003evideoq) \u0026\u0026 stream_has_enough_packets(is-\u003esubtitle_st, is-\u003esubtitle_stream, \u0026is-\u003esubtitleq)))) { /* wait 10 ms */ SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is-\u003econtinue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } //循环播放处理 if (!is-\u003epaused \u0026\u0026 (!is-\u003eaudio_st || (is-\u003eauddec.finished == is-\u003eaudioq.serial \u0026\u0026 frame_queue_nb_remaining(\u0026is-\u003esampq) == 0)) \u0026\u0026 (!is-\u003evideo_st || (is-\u003eviddec.finished == is-\u003evideoq.serial \u0026\u0026 frame_queue_nb_remaining(\u0026is-\u003epictq) == 0))) { if (loop != 1 \u0026\u0026 (!loop || --loop)) { stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0); } else if (autoexit) { ret = AVERROR_EOF; goto fail; } } ret = av_read_frame(ic, pkt); //将数据读取出，送入队列 if (ret \u003c 0) { if ((ret == AVERROR_EOF || avio_feof(ic-\u003epb)) \u0026\u0026 !is-\u003eeof) { if (is-\u003evideo_stream \u003e= 0) packet_queue_put_nullpacket(\u0026is-\u003evideoq, is-\u003evideo_stream); if (is-\u003eaudio_stream \u003e= 0) packet_queue_put_nullpacket(\u0026is-\u003eaudioq, is-\u003eaudio_stream); if (is-\u003esubtitle_stream \u003e= 0) packet_queue_put_nullpacket(\u0026is-\u003esubtitleq, is-\u003esubtitle_stream); is-\u003eeof = 1; } if (ic-\u003epb \u0026\u0026 ic-\u003epb-\u003eerror) { if (autoexit) goto fail; else break; } /*读取失败的话，读取失败的原因有很多，其他地方可能会重新Signal这个锁condition。如果没有singal这个condition的话，就会等待10ms之后， 再释放，重新循环读取. 那这个continue_read_thread 到底是锁了哪呢？*/ SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is-\u003econtinue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } else { is-\u003eeof = 0; } /* check if packet is in play range specified by user, then queue, otherwise discard */ //记录stream_start_time stream_start_time = ic-\u003estreams[pkt-\u003estream_index]-\u003estart_time; //如果没有pts, 就用dts pkt_ts = pkt-\u003epts == AV_NOPTS_VALUE ? pkt-\u003edts : pkt-\u003epts; /*判断是否在范围内。如果duration还没被定义的话，通过 或者在定义的duration内才可以，用当前的pts-start_time . duration 会在解码器打开之后，才会被初始化*/ pkt_in_play_range = duration == AV_NOPTS_VALUE || (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) * av_q2d(ic-\u003estreams[pkt-\u003estream_index]-\u003etime_base) - (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000 \u003c= ((double)duration / 1000000); // 将解复用得到的数据包添加到对应的待解码队列中 if (pkt-\u003estream_index == is-\u003eaudio_stream \u0026\u0026 pkt_in_play_range) { packet_queue_put(\u0026is-\u003eaudioq, pkt); } else if (pkt-\u003estream_index == is-\u003evideo_stream \u0026\u0026 pkt_in_play_range \u0026\u0026 !(is-\u003evideo_st-\u003edisposition \u0026 AV_DISPOSITION_ATTACHED_PIC)) { packet_queue_put(\u0026is-\u003evideoq, pkt); } else if (pkt-\u003estream_index == is-\u003esubtitle_stream \u0026\u0026 pkt_in_play_range) { packet_queue_put(\u0026is-\u003esubtitleq, pkt); } else { av_packet_unref(pkt); } } 暂停/恢复处理： if (is-\u003epaused != is-\u003elast_paused) {//如果paused变量改变，说明暂停状态改变 is-\u003elast_paused = is-\u003epaused; if (is-\u003epaused)//如果暂停调用av_read_pause is-\u003eread_pause_return = av_read_pause(ic); else//如果恢复播放调用av_read_play av_read_play(ic); } ffmpeg有专门针对暂停和恢复的函数，所以直接调用就可以了。\nseek的处理： 主要的seek操作通过avformat_seek_file完成。根据avformat_seek_file的返回值，如果seek成功，需要：\n清除PacketQueue的缓存，并放入一个flush_pkt。放入的flush_pkt可以让PacketQueue的serial增1，以区分seek前后的数据;(在分析PacketQueue会详细说明) 同步外部时钟；（在音视频同步部分会详细说明） 最后清理一些变量，通过step_to_next_frame完成 ret = avformat_seek_file(is-\u003eic, -1, seek_min, seek_target, seek_max, is-\u003eseek_flags); if (ret \u003c 0) { av_log(NULL, AV_LOG_ERROR, \"%s: error while seeking\\n\", is-\u003eic-\u003eurl); } else { //清空缓冲队列，向解码线程传入flush事件 if (is-\u003eaudio_stream \u003e= 0) { packet_queue_flush(\u0026is-\u003eaudioq); packet_queue_put(\u0026is-\u003eaudioq, \u0026flush_pkt); } if (is-\u003esubtitle_stream \u003e= 0) { packet_queue_flush(\u0026is-\u003esubtitleq); packet_queue_put(\u0026is-\u003esubtitleq, \u0026flush_pkt); } if (is-\u003evideo_stream \u003e= 0) { packet_queue_flush(\u0026is-\u003evideoq); packet_queue_put(\u0026is-\u003evideoq, \u0026flush_pkt); } //同步外部时钟信号 if (is-\u003eseek_flags \u0026 AVSEEK_FLAG_BYTE) { set_clock(\u0026is-\u003eextclk, NAN, 0); } else { set_clock(\u0026is-\u003eextclk, seek_target / (double)AV_TIME_BASE, 0); } } is-\u003eseek_req = 0; is-\u003equeue_attachments_req = 1; is-\u003eeof = 0; if (is-\u003epaused) step_to_next_frame(is); 缓冲区大小判断： 缓冲区大小满的情况判断有两种：\n所有流队列缓冲大小总和大于MAX_QUEUE_SIZE（15M）时； 各种流的队列都已有够用的包； /* if the queue are full, no need to read more */ //数据队列满的情况 if (infinite_buffer \u003c 1 \u0026\u0026 (is-\u003eaudioq.size + is-\u003evideoq.size + is-\u003esubtitleq.size \u003e MAX_QUEUE_SIZE //所有流队列缓冲大小总和大于MAX_QUEUE_SIZE（15M）时 || (stream_has_enough_packets(is-\u003eaudio_st, is-\u003eaudio_stream, \u0026is-\u003eaudioq) //各种流都已有够用的包 \u0026\u0026stream_has_enough_packets(is-\u003evideo_st, is-\u003evideo_stream, \u0026is-\u003evideoq) \u0026\u0026stream_has_enough_packets(is-\u003esubtitle_st, is-\u003esubtitle_stream, \u0026is-\u003esubtitleq)))) { /* wait 10 ms */ SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is-\u003econtinue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } 在看看函数stream_has_enough_packets是如何判断流队列都已有够用的包\nstatic int stream_has_enough_packets(AVStream *st, int stream_id, PacketQueue *queue) { return stream_id \u003c 0 || queue-\u003eabort_request || (st-\u003edisposition \u0026 AV_DISPOSITION_ATTACHED_PIC) || queue-\u003enb_packets \u003e MIN_FRAMES \u0026\u0026 (!queue-\u003eduration || av_q2d(st-\u003etime_base) * queue-\u003eduration \u003e 1.0); } 从函数内部结构可以看出，在满足PacketQueue总时长为0，或总时长超过1s的前提下：\n有这么几种情况包是够用的：\n流没有打开（stream_id \u003c 0） 有退出请求（queue-\u003eabort_request） 配置了AV_DISPOSITION_ATTACHED_PIC，流以附件图片/“封面图片”的形式存储在文件； 队列内包个数大于MIN_FRAMES（=25） 在播放完的情况下处理： if (!is-\u003epaused \u0026\u0026 (!is-\u003eaudio_st || (is-\u003eauddec.finished == is-\u003eaudioq.serial \u0026\u0026 frame_queue_nb_remaining(\u0026is-\u003esampq) == 0)) \u0026\u0026(!is-\u003evideo_st || (is-\u003eviddec.finished == is-\u003evideoq.serial \u0026\u0026 frame_queue_nb_remaining(\u0026is-\u003epictq) == 0))) { if (loop != 1 \u0026\u0026 (!loop || --loop)) { stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0); } else if (autoexit) { ret = AVERROR_EOF; goto fail; } } 判断播放已完成的条件，需要满足：\n不在暂停状态 音频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了 视频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了 在确认已结束的情况下，用户有两个变量可以控制播放器行为：\nloop: 控制播放次数（当前这次也算在内，也就是最小就是1次了），0表示无限次 autoexit：自动退出，也就是播放完成后自动退出。 读（解复用）处理： 解复用处理的步骤如下：\n通过av_read_frame读取一个包（AVPacket） 返回值处理，一些出错处理过程 pkt_ts重计算过程 packet_queue_put放入各自队列，或者丢弃 ret = av_read_frame(ic, pkt); //将数据读取出，送入队列 if (ret \u003c 0) { //文件读取完了，调用packet_queue_put_nullpacket通知解码线程 if ((ret == AVERROR_EOF || avio_feof(ic-\u003epb)) \u0026\u0026 !is-\u003eeof) { if (is-\u003evideo_stream \u003e= 0) packet_queue_put_nullpacket(\u0026is-\u003evideoq, is-\u003evideo_stream); if (is-\u003eaudio_stream \u003e= 0) packet_queue_put_nullpacket(\u0026is-\u003eaudioq, is-\u003eaudio_stream); if (is-\u003esubtitle_stream \u003e= 0) packet_queue_put_nullpacket(\u0026is-\u003esubtitleq, is-\u003esubtitle_stream); is-\u003eeof = 1; } //发生错误了，退出主循环 if (ic-\u003epb \u0026\u0026 ic-\u003epb-\u003eerror) { if (autoexit) goto fail; else break; } /*读取失败的话，读取失败的原因有很多，其他地方可能会重新Signal这个锁condition。 如果没有singal这个condition的话，就会等待10ms之后， 再释放，重新循环读取. 那这个continue_read_thread 到底是锁了哪呢？*/ SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is-\u003econtinue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } else { is-\u003eeof = 0; } /* check if packet is in play range specified by user, then queue, otherwise discard */ //记录stream_start_time stream_start_time = ic-\u003estreams[pkt-\u003estream_index]-\u003estart_time; //如果没有pts, 就用dts pkt_ts = pkt-\u003epts == AV_NOPTS_VALUE ? pkt-\u003edts : pkt-\u003epts; /*判断是否在范围内。如果duration还没被定义的话，通过 或者在定义的duration内才可以，用当前的pts-start_time . duration 会在解码器打开之后，才会被初始化*/ pkt_in_play_range = duration == AV_NOPTS_VALUE || (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) * av_q2d(ic-\u003estreams[pkt-\u003estream_index]-\u003etime_base) - (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000 \u003c= ((double)duration / 1000000); // 将解复用得到的数据包添加到对应的待解码队列中 if (pkt-\u003estream_index == is-\u003eaudio_stream \u0026\u0026 pkt_in_play_range) { packet_queue_put(\u0026is-\u003eaudioq, pkt); } else if (pkt-\u003estream_index == is-\u003evideo_stream \u0026\u0026 pkt_in_play_range \u0026\u0026 !(is-\u003evideo_st-\u003edisposition \u0026 AV_DISPOSITION_ATTACHED_PIC)) { packet_queue_put(\u0026is-\u003evideoq, pkt); } else if (pkt-\u003estream_index == is-\u003esubtitle_stream \u0026\u0026 pkt_in_play_range) { packet_queue_put(\u0026is-\u003esubtitleq, pkt); } else { av_packet_unref(pkt); } 视频解码线程(video_thread) 在read_thread中已经创建了对应需要的解码器(AVCodec)；而在video_thread中需要创建AVFrame,来接收解码后的数据；确定视频帧率，开启循环解码；\n参数初始化 创建AVFrame和得到大致的视频帧率\nVideoState *is = arg; AVFrame *frame = av_frame_alloc(); //创建AVFrame double pts; double duration; int ret; AVRational tb = is-\u003evideo_st-\u003etime_base; //猜测视频帧率 AVRational frame_rate = av_guess_frame_rate(is-\u003eic, is-\u003evideo_st, NULL); if (!frame) return AVERROR(ENOMEM); 循环解码 循环解码的总流：\nget_video_frame获取解码后的一帧图像 “计算”时长和pts 调用queue_picture将一帧图像放入FrameQueue for (;;) { ret = get_video_frame(is, frame); if (ret \u003c 0) goto the_end; if (!ret) continue; //获取当前帧播放时长 duration = (frame_rate.num \u0026\u0026 frame_rate.den ? av_q2d((AVRational){frame_rate.den, frame_rate.num}) : 0); //当前帧显示时间戳 pts = (frame-\u003epts == AV_NOPTS_VALUE) ? NAN : frame-\u003epts * av_q2d(tb); // 将当前帧压入frame_queue ret = queue_picture(is, frame, pts, duration, frame-\u003epkt_pos, is-\u003eviddec.pkt_serial); av_frame_unref(frame); //释放frame if (ret \u003c 0) goto the_end; } get_video_frame ​\t调用decoder_decode_frame解码,获取成功后主要做丢帧处理，丢帧的主要条件是diff - is-\u003eframe_last_filter_delay \u003c 0，frame_last_filter_delay与滤镜有关，可以先忽略，也就是diff \u003c 0的时候丢帧——pts \u003c get_master_clock(is)的时候丢帧。decoder_decode_frame真正解码函数；\nstatic int get_video_frame(VideoState *is, AVFrame *frame) { int got_picture; if ((got_picture = decoder_decode_frame(\u0026is-\u003eviddec, frame, NULL)) \u003c 0) return -1; if (got_picture)//解码是否成功，主要做丢帧处理 { double dpts = NAN; if (frame-\u003epts != AV_NOPTS_VALUE)//通过 pts*av_q2d(timebase)可以得到准确的时间 dpts = av_q2d(is-\u003evideo_st-\u003etime_base) * frame-\u003epts; //重新得到视频的比例 frame-\u003esample_aspect_ratio = av_guess_sample_aspect_ratio(is-\u003eic, is-\u003evideo_st, frame); if (framedrop \u003e 0 || (framedrop \u0026\u0026 get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) { if (frame-\u003epts != AV_NOPTS_VALUE) { //得到的是当前的时间和时间钟之间的差值。 double diff = dpts - get_master_clock(is); if (!isnan(diff) \u0026\u0026 fabs(diff) \u003c AV_NOSYNC_THRESHOLD \u0026\u0026 diff - is-\u003eframe_last_filter_delay \u003c 0 \u0026\u0026 is-\u003eviddec.pkt_serial == is-\u003evidclk.serial \u0026\u0026 is-\u003evideoq.nb_packets) { is-\u003eframe_drops_early++; av_frame_unref(frame); got_picture = 0; } } } } return got_picture; } decoder_decode_frame decoder_decode_frame的主干代码是一个循环，要拿到一帧解码数据，或解码出错、文件结束，才会返回。\n循环总共3个步骤：\n流连续的情况下，不断调用avcodec_receive_frame获取解码后的frame 取一个packet，顺带过滤“过时”的packet 将packet送入解码器 有一个packet_pending的概念，用于在send失败时重新发送；当收到flush_pkt时进行相应的flush事件处理，PacketQueue发生改变时第一个pkt将是flush_pkt，根据ffmpeg的API要求，需要调用avcodec_flush_buffers。\nstatic int decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *sub) { int ret = AVERROR(EAGAIN); for (;;) { AVPacket pkt; //1. 流连续的情况下，不断调用avcodec_receive_frame获取解码后的frame if (d-\u003equeue-\u003eserial == d-\u003epkt_serial) { do { if (d-\u003equeue-\u003eabort_request) return -1; switch (d-\u003eavctx-\u003ecodec_type) { case AVMEDIA_TYPE_VIDEO: ret = avcodec_receive_frame(d-\u003eavctx, frame); if (ret \u003e= 0) { if (decoder_reorder_pts == -1) { frame-\u003epts = frame-\u003ebest_effort_timestamp; } else if (!decoder_reorder_pts) { frame-\u003epts = frame-\u003epkt_dts; } } break; if (ret == AVERROR_EOF) { d-\u003efinished = d-\u003epkt_serial; avcodec_flush_buffers(d-\u003eavctx); return 0; } if (ret \u003e= 0) return 1; } while (ret != AVERROR(EAGAIN)); } //2. 取一个packet，顺带过滤“过时”的packet do { // 队列为空 if (d-\u003equeue-\u003enb_packets == 0) SDL_CondSignal(d-\u003eempty_queue_cond); //如果有待重发的pkt，则先取待重发的pkt，否则从队列中取一个pkt if (d-\u003epacket_pending) { av_packet_move_ref(\u0026pkt, \u0026d-\u003epkt); d-\u003epacket_pending = 0; } else { //取出下一帧 if (packet_queue_get(d-\u003equeue, \u0026pkt, 1, \u0026d-\u003epkt_serial) \u003c 0) return -1; } //队列的序列不相同时 if (d-\u003equeue-\u003eserial == d-\u003epkt_serial) break; av_packet_unref(\u0026pkt); } while (1); //针对flush_pkt的处理 if (pkt.data == flush_pkt.data) { avcodec_flush_buffers(d-\u003eavctx); d-\u003efinished = 0; d-\u003enext_pts = d-\u003estart_pts; d-\u003enext_pts_tb = d-\u003estart_pts_tb; } else { //3. 将packet送入解码器 if (avcodec_send_packet(d-\u003eavctx, \u0026pkt) == AVERROR(EAGAIN)) { av_log(d-\u003eavctx, AV_LOG_ERROR, \"Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n\"); d-\u003epacket_pending = 1; av_packet_move_ref(\u0026d-\u003epkt, \u0026pkt); } av_packet_unref(\u0026pkt); } } } queue_picture queue_picture主要用于把get_video_frame函数取到正确解码后的一帧数据放入FrameQueue；\nframe_queue_peek_writable取FrameQueue的当前写节点； 把该解码后的帧数据拷贝给节点(struct Frame)保存 frame_queue_push，“push”节点到队列中 AVFrame的拷贝是通过av_frame_move_ref实现的，所以拷贝后src_frame就是无效的；\nstatic int queue_picture(VideoState *is, AVFrame *src_frame, double pts, double duration, int64_t pos, int serial) { Frame *vp; #if defined(DEBUG_SYNC) printf(\"frame_type=%c pts=%0.3f\\n\", av_get_picture_type_char(src_frame-\u003epict_type), pts); #endif if (!(vp = frame_queue_peek_writable(\u0026is-\u003epictq))) //判断是否有空间可以写入，并取FrameQueue的当前写节点 return -1; vp-\u003esar = src_frame-\u003esample_aspect_ratio; vp-\u003euploaded = 0; vp-\u003ewidth = src_frame-\u003ewidth; vp-\u003eheight = src_frame-\u003eheight; vp-\u003eformat = src_frame-\u003eformat; vp-\u003epts = pts; vp-\u003eduration = duration; vp-\u003epos = pos; vp-\u003eserial = serial; //修改窗口大小 set_default_window_size(vp-\u003ewidth, vp-\u003eheight, vp-\u003esar); av_frame_move_ref(vp-\u003eframe, src_frame); //将src_frame的内存空间指向vp-\u003eframe frame_queue_push(\u0026is-\u003epictq); //重新推入 return 0; } ffplay audio输出的线程分析 ffplay audio的解码过程与video的一样，都在decoder_decode_frame函数中执行，在 video已经进行分析，这里就不做单独分析了，主要分析audio的输出；ffplay的audio输出同样也是通过SDL实现的;audio输出相关内容，且尽量不涉及音视频同步知识，音视频同步将专门一个章节分析。\naudio的输出在SDL下是被动输出，即在开启SDL会在需要输出时，回调通知，在回调函数中，SDL会告知要发送多少的数据。\nsdl通过sdl_audio_callback函数向ffplay要音频数据，ffplay将sampq中的数据通过audio_decode_frame函数取出，放入is-\u003eaudio_buf，然后送出给sdl。在后续回调时先找audio_buf要数据，数据不足的情况下，再调用audio_decode_frame补充audio_buf\nsdl打开音频输出 在stream_component_open中的audio分支进行调用audio_open打开sdl音频输出；代码如下：\ncase AVMEDIA_TYPE_AUDIO: //音频相关 #if CONFIG_AVFILTER //过滤器 { AVFilterContext *sink; //从avctx(即AVCodecContext)中获取音频格式参数 is-\u003eaudio_filter_src.freq = avctx-\u003esample_rate; is-\u003eaudio_filter_src.channels = avctx-\u003echannels; is-\u003eaudio_filter_src.channel_layout = get_valid_channel_layout(avctx-\u003echannel_layout, avctx-\u003echannels); is-\u003eaudio_filter_src.fmt = avctx-\u003esample_fmt; if ((ret = configure_audio_filters(is, afilters, 0)) \u003c 0) goto fail; sink = is-\u003eout_audio_filter; sample_rate = av_buffersink_get_sample_rate(sink); nb_channels = av_buffersink_get_channels(sink); channel_layout = av_buffersink_get_channel_layout(sink); } #else sample_rate = avctx-\u003esample_rate; nb_channels = avctx-\u003echannels; channel_layout = avctx-\u003echannel_layout; #endif /* prepare audio output */ //打开音频输出通道 /*调用audio_open打开sdl音频输出，实际打开的设备参数保存在audio_tgt，返回值表示输出设备的缓冲区大小*/ if ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, \u0026is-\u003eaudio_tgt)) \u003c 0) goto fail; is-\u003eaudio_hw_buf_size = ret; is-\u003eaudio_src = is-\u003eaudio_tgt; //初始化audio_buf相关参数 is-\u003eaudio_buf_size = 0; is-\u003eaudio_buf_index = 0; /* init averaging filter */ is-\u003eaudio_diff_avg_coef = exp(log(0.01) / AUDIO_DIFF_AVG_NB); is-\u003eaudio_diff_avg_count = 0; /* since we do not have a precise anough audio FIFO fullness, we correct audio sync only if larger than this threshold */ is-\u003eaudio_diff_threshold = (double)(is-\u003eaudio_hw_buf_size) / is-\u003eaudio_tgt.bytes_per_sec; is-\u003eaudio_stream = stream_index; is-\u003eaudio_st = ic-\u003estreams[stream_index]; decoder_init(\u0026is-\u003eauddec, avctx, \u0026is-\u003eaudioq, is-\u003econtinue_read_thread); //初始化对应的解码线程 if ((is-\u003eic-\u003eiformat-\u003eflags \u0026 (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) \u0026\u0026 !is-\u003eic-\u003eiformat-\u003eread_seek) { is-\u003eauddec.start_pts = is-\u003eaudio_st-\u003estart_time; is-\u003eauddec.start_pts_tb = is-\u003eaudio_st-\u003etime_base; } if ((ret = decoder_start(\u0026is-\u003eauddec, audio_thread, \"audio_decoder\", is)) \u003c 0) // 正式开启解码线程。 goto out; SDL_PauseAudioDevice(audio_dev, 0); break; 由于不同的音频输出设备支持的参数不同，音轨的参数不一定能被输出设备支持（此时就需要重采样了），audio_tgt就保存了输出设备参数。\n介绍下audio_buf相关的几个变量：\naudio_buf: 从要输出的AVFrame中取出的音频数据（PCM），如果有必要，则对该数据重采样。 audio_buf_size: audio_buf的总大小 audio_buf_index: 下一次可读的audio_buf的index位置。 audio_write_buf_size：audio_buf已经输出的大小，即audio_buf_size - audio_buf_index 音频输出逻辑 在audio_open函数内，通过通过SDL_OpenAudioDevice注册sdl_audio_callback函数为音频输出的回调函数。那么，主要的音频输出的逻辑就在sdl_audio_callback函数内了。\n/* prepare a new audio buffer */ static void sdl_audio_callback(void *opaque, Uint8 *stream, int len) { VideoState *is = opaque; int audio_size, len1; audio_callback_time = av_gettime_relative(); while (len \u003e 0)//循环发送，直到发够所需数据长度 { //如果audio_buf消耗完了，就调用audio_decode_frame重新填充audio_buf if (is-\u003eaudio_buf_index \u003e= is-\u003eaudio_buf_size) { audio_size = audio_decode_frame(is);//填充audio_buf if (audio_size \u003c 0) { /* if error, just output silence */ is-\u003eaudio_buf = NULL; is-\u003eaudio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / is-\u003eaudio_tgt.frame_size * is-\u003eaudio_tgt.frame_size; } else { if (is-\u003eshow_mode != SHOW_MODE_VIDEO) update_sample_display(is, (int16_t *)is-\u003eaudio_buf, audio_size); is-\u003eaudio_buf_size = audio_size; } is-\u003eaudio_buf_index = 0; } //根据缓冲区剩余大小量力而行 len1 = is-\u003eaudio_buf_size - is-\u003eaudio_buf_index; if (len1 \u003e len) len1 = len; //根据audio_volume决定如何输出audio_buf if (!is-\u003emuted \u0026\u0026 is-\u003eaudio_buf \u0026\u0026 is-\u003eaudio_volume == SDL_MIX_MAXVOLUME) memcpy(stream, (uint8_t *)is-\u003eaudio_buf + is-\u003eaudio_buf_index, len1); else { memset(stream, 0, len1); if (!is-\u003emuted \u0026\u0026 is-\u003eaudio_buf) SDL_MixAudioFormat(stream, (uint8_t *)is-\u003eaudio_buf + is-\u003eaudio_buf_index, AUDIO_S16SYS, len1, is-\u003eaudio_volume); } //调整各buffer len -= len1; stream += len1; is-\u003eaudio_buf_index += len1; } is-\u003eaudio_write_buf_size = is-\u003eaudio_buf_size - is-\u003eaudio_buf_index; /* Let's assume the audio driver that is used by SDL has two periods. */ if (!isnan(is-\u003eaudio_clock))//更新audclk { set_clock_at(\u0026is-\u003eaudclk, is-\u003eaudio_clock - (double)(2 * is-\u003eaudio_hw_buf_size + is-\u003eaudio_write_buf_size) / is-\u003eaudio_tgt.bytes_per_sec, is-\u003eaudio_clock_serial, audio_callback_time / 1000000.0); sync_clock_to_slave(\u0026is-\u003eextclk, \u0026is-\u003eaudclk); } } sdl_audio_callback的缓冲区输出过程:\n输出audio_buf到stream，如果audio_volume为最大音量，则只需memcpy复制给stream即可。否则，可以利用SDL_MixAudioFormat进行音量调整和混音 如果audio_buf消耗完了，就调用audio_decode_frame重新填充audio_buf set_clock_at更新audclk时，完整的帧包含的时间戳-实际写入的帧数+2个硬件buffer的延迟，audio_clock是当前audio_buf的显示结束时间(pts+duration)，由于audio driver本身会持有一小块缓冲区，典型地，会是两块交替使用，所以有2 * is-\u003eaudio_hw_buf_size. 因为我们的写入的时候，还需要考虑传入的buffer的大小，预期情况下，如果buffer相同，则这里就是原来的pts-硬件延迟的时间。 填充audio_buf 调用audio_decode_frame重新填充audio_buf，audio_decode_frame并没有真正意义上的decode代码，最多是进行了重采样。主流程有以下步骤：\n从sampq取一帧，必要时丢帧。如发生了seek，此时serial会不连续，就需要丢帧处理 计算这一帧的字节数。通过av_samples_get_buffer_size可以方便计算出结果 获取这一帧的数据。对于frame格式和输出设备不同的，需要重采样；如果格式相同，则直接拷贝指针输出即可。总之，需要在audio_buf中保存与输出设备格式相同的音频数据 更新audio_clock，audio_clock_serial。用于设置audclk. /** * Decode one audio frame and return its uncompressed size. * * The processed audio frame is decoded, converted if required, and * stored in is-\u003eaudio_buf, with size in bytes given by the return * value. */ static int audio_decode_frame(VideoState *is) { int data_size, resampled_data_size; int64_t dec_channel_layout; av_unused double audio_clock0; int wanted_nb_samples; Frame *af; if (is-\u003epaused)//暂停状态，返回-1，sdl_audio_callback会处理为输出静音 return -1; do { #if defined(_WIN32) while (frame_queue_nb_remaining(\u0026is-\u003esampq) == 0) { if ((av_gettime_relative() - audio_callback_time) \u003e 1000000LL * is-\u003eaudio_hw_buf_size / is-\u003eaudio_tgt.bytes_per_sec / 2) return -1; av_usleep(1000); } #endif if (!(af = frame_queue_peek_readable(\u0026is-\u003esampq)))//1. 从sampq取一帧，必要时丢帧 return -1; frame_queue_next(\u0026is-\u003esampq); } while (af-\u003eserial != is-\u003eaudioq.serial); //2. 计算这一帧的字节数 data_size = av_samples_get_buffer_size(NULL, af-\u003eframe-\u003echannels, af-\u003eframe-\u003enb_samples, af-\u003eframe-\u003eformat, 1); //[]计算dec_channel_layout，用于确认是否需要重新初始化重采样 dec_channel_layout = (af-\u003eframe-\u003echannel_layout \u0026\u0026 af-\u003eframe-\u003echannels == av_get_channel_layout_nb_channels(af-\u003eframe-\u003echannel_layout)) ? af-\u003eframe-\u003echannel_layout : av_get_default_channel_layout(af-\u003eframe-\u003echannels); wanted_nb_samples = synchronize_audio(is, af-\u003eframe-\u003enb_samples); //[]判断是否需要重新初始化重采样 if (af-\u003eframe-\u003eformat != is-\u003eaudio_src.fmt || dec_channel_layout != is-\u003eaudio_src.channel_layout || af-\u003eframe-\u003esample_rate != is-\u003eaudio_src.freq || (wanted_nb_samples != af-\u003eframe-\u003enb_samples \u0026\u0026 !is-\u003eswr_ctx)) { swr_free(\u0026is-\u003eswr_ctx); //创建和设置swr is-\u003eswr_ctx = swr_alloc_set_opts(NULL, is-\u003eaudio_tgt.channel_layout, is-\u003eaudio_tgt.fmt, is-\u003eaudio_tgt.freq, dec_channel_layout, af-\u003eframe-\u003eformat, af-\u003eframe-\u003esample_rate, 0, NULL); if (!is-\u003eswr_ctx || swr_init(is-\u003eswr_ctx) \u003c 0) { av_log(NULL, AV_LOG_ERROR, \"Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\\n\", af-\u003eframe-\u003esample_rate, av_get_sample_fmt_name(af-\u003eframe-\u003eformat), af-\u003eframe-\u003echannels, is-\u003eaudio_tgt.freq, av_get_sample_fmt_name(is-\u003eaudio_tgt.fmt), is-\u003eaudio_tgt.channels); swr_free(\u0026is-\u003eswr_ctx); return -1; } is-\u003eaudio_src.channel_layout = dec_channel_layout; is-\u003eaudio_src.channels = af-\u003eframe-\u003echannels; is-\u003eaudio_src.freq = af-\u003eframe-\u003esample_rate; is-\u003eaudio_src.fmt = af-\u003eframe-\u003eformat; } //3. 获取这一帧的数据 if (is-\u003eswr_ctx)//[]如果初始化了重采样，则对这一帧数据重采样输出 { const uint8_t **in = (const uint8_t **)af-\u003eframe-\u003eextended_data; uint8_t **out = \u0026is-\u003eaudio_buf1; int out_count = (int64_t)wanted_nb_samples * is-\u003eaudio_tgt.freq / af-\u003eframe-\u003esample_rate + 256; int out_size = av_samples_get_buffer_size(NULL, is-\u003eaudio_tgt.channels, out_count, is-\u003eaudio_tgt.fmt, 0); int len2; if (out_size \u003c 0) { av_log(NULL, AV_LOG_ERROR, \"av_samples_get_buffer_size() failed\\n\"); return -1; } if (wanted_nb_samples != af-\u003eframe-\u003enb_samples) { if (swr_set_compensation(is-\u003eswr_ctx, (wanted_nb_samples - af-\u003eframe-\u003enb_samples) * is-\u003eaudio_tgt.freq / af-\u003eframe-\u003esample_rate, wanted_nb_samples * is-\u003eaudio_tgt.freq / af-\u003eframe-\u003esample_rate) \u003c 0) { av_log(NULL, AV_LOG_ERROR, \"swr_set_compensation() failed\\n\"); return -1; } } av_fast_malloc(\u0026is-\u003eaudio_buf1, \u0026is-\u003eaudio_buf1_size, out_size); if (!is-\u003eaudio_buf1) return AVERROR(ENOMEM); //进行转换 len2 = swr_convert(is-\u003eswr_ctx, out, out_count, in, af-\u003eframe-\u003enb_samples); if (len2 \u003c 0) { av_log(NULL, AV_LOG_ERROR, \"swr_convert() failed\\n\"); return -1; } if (len2 == out_count) { av_log(NULL, AV_LOG_WARNING, \"audio buffer is probably too small\\n\"); if (swr_init(is-\u003eswr_ctx) \u003c 0) swr_free(\u0026is-\u003eswr_ctx); } is-\u003eaudio_buf = is-\u003eaudio_buf1; //重新计算采样的数据大小，并返回 resampled_data_size = len2 * is-\u003eaudio_tgt.channels * av_get_bytes_per_sample(is-\u003eaudio_tgt.fmt); } else { is-\u003eaudio_buf = af-\u003eframe-\u003edata[0]; resampled_data_size = data_size; } //audio_clock0用于打印调试信息 audio_clock0 = is-\u003eaudio_clock; /* update the audio clock with the pts */ //4. 更新audio_clock，audio_clock_serial,更新pts 这个pts 等于当前的帧包含的所有帧数 if (!isnan(af-\u003epts)) is-\u003eaudio_clock = af-\u003epts + (double)af-\u003eframe-\u003enb_samples / af-\u003eframe-\u003esample_rate; else is-\u003eaudio_clock = NAN; is-\u003eaudio_clock_serial = af-\u003eserial; #ifdef DEBUG { static double last_clock; printf(\"audio: delay=%0.3f clock=%0.3f clock0=%0.3f\\n\", is-\u003eaudio_clock - last_clock, is-\u003eaudio_clock, audio_clock0); last_clock = is-\u003eaudio_clock; } #endif return resampled_data_size;//返回audio_buf的数据大小 } ffplay时间同步 由于音频和视频的输出不在同一个线程，而且，也不一定会同时解出同一个pts的音频帧和视频帧。因此，在进行音频和视频的播放时，需要对音频和视频的播放速度、播放时刻进行控制，以实现音频和视频保持同步，即所谓的音视频同步。\n在ffplay中，音频（audio）和视频（video）有各自的输出线程，其中音频的输出线程是sdl的音频输出回调线程，video的输出线程是程序的主线程。\n音视频的同步策略，一般有如下几种：\n视频同步到音频，即音频为主时钟 音频同步到视频，即视频为主时钟 视频、音频同步到外部时钟，即外部时钟（系统时间）为主时钟 视频和音频各自输出，即不作同步处理，或称之为各自为主时钟 由于人耳对于声音变化的敏感度比视觉高，因此，一般采样的策略是将视频同步到音频，即对画面进行适当的丢帧或重复以追赶或等待音频。\nDTS和PTS 在音视频流中的包都含有DTS和PTS，我们以此作为选择基准，到底是播放快了还是慢了，或者正以同步的速度播放。\nDTS：Decoding Time Stamp 解码时间戳——告诉解码器packet解码顺序 PTS：Presenting Time Stamp 显示时间戳——指示从packet中解码出来的数据的显示顺序 计算视频Frame的显示时间 要想知道ffmpeg如果计算视频一帧的显示时间，就需先了解ffmpeg的timebase；因为pts的单位就是timebase；\ntimebase的类型是结构体AVRational（用于表示分数），如下：\ntypedef struct AVRational{ int num; ///\u003c Numerator int den; ///\u003c Denominator } AVRational; 如timebase={1, 1000}表示千分之一秒，那么pts=1000，即为1秒，那么这一帧就需要在第一秒的时候呈现在ffplay中，将pts转化为秒，一般做法是：pts * av_q2d(timebase)\n“时钟\"的概念，ffplay定义的结构体是Clock：\ntypedef struct Clock { double pts; /* clock base */// 时钟基准 double pts_drift; /* clock base minus time at which we updated the clock */// 更新时钟的差值 double last_updated;// 上一次更新的时间 double speed;// 速度 int serial; // 时钟基于使用该序列的包 /* clock is based on a packet with this serial */ int paused;// 停止标志 int *queue_serial; // 指向当前数据包队列序列的指针，用于过时的时钟检测 /* pointer to the current packet queue serial, used for obsolete clock detection */ } Clock; 时钟的工作原理：\n通过set_clock_at不断对时； 获取的时间是一个估算值。估算是通过对时时记录的pts_drift估算的 /** * 更新视频的pts * @param is [description] * @param pts [description] * @param pos [description] * @param serial [description] */ static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) { /* update current video pts */ set_clock(\u0026is-\u003evidclk, pts, serial); //将尾部的时间钟，用视频的时机钟来进行同步 sync_clock_to_slave(\u0026is-\u003eextclk, \u0026is-\u003evidclk); } static void set_clock(Clock *c, double pts, int serial) { double time = av_gettime_relative() / 1000000.0; set_clock_at(c, pts, serial, time); } //使用当前的事来计算这几个值。也就是这一帧送显之前的操作的时间。 static void set_clock_at(Clock *c, double pts, int serial, double time) { c-\u003epts = pts; c-\u003elast_updated = time; c-\u003epts_drift = c-\u003epts - time; c-\u003eserial = serial; } 以一个时间轴，从左往右看。首先我们调用set_clock_at进行一次对时，假设这时的pts是落后系统时间time的，那么计算pts_drift = pts - time。\n接着，过了一会儿，且在下次对时前，通过get_clock来查询时间，因为这时的pts已经过时，不能直接拿pts当做这个时钟的时间。不过我们前面计算过pts_drift，也就是pts和time的差值，所以我们可以通过当前时刻的系统时间来估算这个时刻的pts：pts = time + pts_drift.\n当然，由于pts_drift是一直在变动的(drift与漂移、抖动的意思)，所以get_clock是估算值，真实的pts可能落在比如图示虚线圆的位置。\nstatic double get_clock(Clock *c) { if (*c-\u003equeue_serial != c-\u003eserial) return NAN; if (c-\u003epaused) { return c-\u003epts; } else { //pts_drift 是更新的时间钟的差值？ //最后的时间是 更新的差值+ 当前的时间-当前的时间和上一次更新的时间之间的差值*速度 //默认的情况下，根据上一次的drift计算下一次要出现的时间。 double time = av_gettime_relative() / 1000000.0; return c-\u003epts_drift + time - (time - c-\u003elast_updated) * (1.0 - c-\u003espeed); } } 以音频为主时钟同步 接下来主要讲以音频为主时钟的部分，大致流程如下：\n在这个流程中，“计算上一帧显示时长”这一步骤至关重要。代码如下：\n/* called to display each frame */ static void video_refresh(void *opaque, double *remaining_time) { if (is-\u003evideo_st) { retry: if (frame_queue_nb_remaining(\u0026is-\u003epictq) == 0) { //判断队列是否有数据 // nothing to do, no picture to display in the queue } else { double last_duration, duration, delay; Frame *vp, *lastvp; //lastvp上一帧，vp当前帧 ，nextvp下一帧 /* dequeue the picture */ //出队 lastvp = frame_queue_peek_last(\u0026is-\u003epictq); vp = frame_queue_peek(\u0026is-\u003epictq); /* 1、刚开始的时候（第一帧）lastvp == vp ，因为还没有调用frame_queue_next f-\u003erindex_shown还未为1 2、调用frame_queue_next，将f-\u003erindex_shown置1，还没有增加f-\u003erindex 3、第二帧开始lastvp上一帧，vp 将要显示的一帧 */ /*如果将要显示的一帧的序列与现在解码的不同就直接抛弃*/ if (vp-\u003eserial != is-\u003evideoq.serial) { frame_queue_next(\u0026is-\u003epictq);//移动读索引 goto retry;//重新获取 } //如果上一帧序号不等于将要显示的一帧序号，表示将要显示的一帧是新的播放序列 /* 新的播放序列重置当前时间，这样就会走到正常显示将要显示的一帧（新序的第一帧） */ if (lastvp-\u003eserial != vp-\u003eserial) is-\u003eframe_timer = av_gettime_relative() / 1000000.0; //获取当前时间，用于帧间对比 if (is-\u003epaused) //暂停后重新开 goto display; /* compute nominal last_duration */ last_duration = vp_duration(is, lastvp, vp);//计算上一帧的持续时长 delay = compute_target_delay(last_duration, is); //音视频同步信息，参考audio clock计算上一帧真正的持续时 time = av_gettime_relative() / 1000000.0;//取系统时刻 /*delay ： 是上一帧要持续显示的时长，也就是将要显示的一帧的开始显示时间 is-\u003eframe_timer ： 上一帧显示的时间 is-\u003eframe_timer + delay ： 将要显示这一帧的时间 如果time 还没达到显示这一帧的时间，就计算等待时间用于上一层等待，继续显示上一帧 如果seek后，delay = 0 ，time 就会大于is-\u003eframe_timer + delay，就往下走显示 */ if (time \u003c is-\u003eframe_timer + delay)//如果上一帧显示时长未满，重复显示上一帧 { //进入视频显示，计算一个等待时间返回上一层，现在视频快了，让视频继续显示上一帧等待 *remaining_time = FFMIN(is-\u003eframe_timer + delay - time, *remaining_time); goto display; } /*第一帧数据时is-\u003eframe_timer = 0，会执行到time - is-\u003eframe_timer \u003e AV_SYNC_THRESHOLD_MAX 如果与系统时间的偏离太大，则修正为系统时间*/ is-\u003eframe_timer += delay;//frame_timer更新为上一帧结束时刻，也是当前帧开始时刻 if (delay \u003e 0 \u0026\u0026 time - is-\u003eframe_timer \u003e AV_SYNC_THRESHOLD_MAX) is-\u003eframe_timer = time;//如果与系统时间的偏离太大，则修正为系统时间 SDL_LockMutex(is-\u003epictq.mutex); /*更新视频时钟 注意：这个更新视频时钟在丢帧之前，那么如果这帧pts设置视频时钟后 下面又将这帧丢弃，视频时钟就是被丢弃的这一帧*/ if (!isnan(vp-\u003epts)) update_video_pts(is, vp-\u003epts, vp-\u003epos, vp-\u003eserial); //更新视频时钟检测 SDL_UnlockMutex(is-\u003epictq.mutex); /*drop帧处理 队列要有将要显示这一帧的下一帧 第一帧，队列内有2帧 后面就是，队列内有3帧，因为保留了上一帧（显示帧）*/ //丢帧逻辑 if (frame_queue_nb_remaining(\u0026is-\u003epictq) \u003e 1) { Frame *nextvp = frame_queue_peek_next(\u0026is-\u003epictq);//获取将要显示帧的下一帧 duration = vp_duration(is, vp, nextvp);//当前帧显示时长 //如果系统时间已经大于当前帧，则丢弃当前帧 if (!is-\u003estep //非逐帧模式播放情况下 \u0026\u0026 (framedrop \u003e 0 //允许drop帧处理 || (framedrop \u0026\u0026 get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) //主时钟不是视频 \u0026\u0026 time \u003e is-\u003eframe_timer + duration)//当前时间已经到了nextvp的播放时间， { //此时is-\u003eframe_timer就是将要显示这一帧vp的播放时间了 is-\u003eframe_drops_late++;//丢帧统计 frame_queue_next(\u0026is-\u003epictq);//丢弃将要显示这一帧，移动读索引读到下一帧 goto retry;//回到函数开始位置，继续重试(这里不能直接while丢帧，因为很可能audio clock重新对时了，这样delay值需要重新计算) } } /*上一帧与将要显示这一帧之间的duration用来计算将要显示这一帧的播放时间 将要显示这一帧与上一帧之间的duration用来计算是否丢弃将要显示这一帧*/ ... frame_queue_next(\u0026is-\u003epictq); is-\u003eforce_refresh = 1;//刷新画面 if (is-\u003estep \u0026\u0026 !is-\u003epaused) stream_toggle_pause(is); } display: /* display picture */ if (!display_disable \u0026\u0026 is-\u003eforce_refresh \u0026\u0026 is-\u003eshow_mode == SHOW_MODE_VIDEO \u0026\u0026 is-\u003epictq.rindex_shown) video_display(is);//显示视频 } } 如果视频播放过快，则重复播放上一帧，以等待音频；如果视频播放过慢，则丢帧追赶音频。实现的方式是，参考audio clock，计算上一帧（在屏幕上的那个画面）还应显示多久（含帧本身时长），然后与系统时刻对比，是否该显示下一帧了。\nframe_timer frame_timer:可以理解为帧显示时刻，如更新前，是上一帧的显示时刻；对于更新后（is-\u003eframe_timer += delay），则为当前帧显示时刻。\n上一帧显示时刻加上delay（还应显示多久（含帧本身时长））即为上一帧应结束显示的时刻。具体原理看如下示意图：\n这里给出了3种情况的示意图：\ntime1：系统时刻小于lastvp结束显示的时刻（frame_timer+dealy），即虚线圆圈位置。此时应该继续显示lastvp time2：系统时刻大于lastvp的结束显示时刻，但小于vp的结束显示时刻（vp的显示时间开始于虚线圆圈，结束于黑色圆圈）。此时既不重复显示lastvp，也不丢弃vp，即应显示vp time3：系统时刻大于vp结束显示时刻（黑色圆圈位置，也是nextvp预计的开始显示时刻）。此时应该丢弃vp。 dealy计算 lastvp的显示时长delay是如何计算的，主要在compute_target_delay中实现，代码如下：\nstatic double compute_target_delay(double delay, VideoState *is) { double sync_threshold, diff = 0; /* update delay to follow master synchronisation source */ //只有同步时钟不是视频时钟时才计算， if (get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER) { // 判断同步类型， /* if video is slave, we try to correct big delays by duplicating or deleting a frame */ /* get_clock(\u0026is-\u003evidclk) ：返回经过从上次设置时钟到现在数据时间到了什么时间位置 get_master_clock(is) ： 返回主时钟到了什么时间位置（音频时钟或者外部时钟） diff ： 就是当前视频播放的位置与主时钟之前的差值 \u003c0 ： 视频慢了 \u003e0 ：视频快了 */ diff = get_clock(\u0026is-\u003evidclk) - get_master_clock(is); /* skip or repeat frame. We take into account the delay to compute the threshold. I still don't know if it is the best guess */ /*AV_SYNC_THRESHOLD_MIN 同步阀值最小范围：0.04 （秒） 1/25帧的时间 AV_SYNC_THRESHOLD_MAX 同步阀值最大范围：0.1 （秒） 1/10帧的时间 delay ： 理论上的两帧之间的时间 返回一个同步阀值在同步阀值范围内，使用delay设置 因为delay上层传来是两帧之间的时间，那只要在阀值范围内，这个时间就是sync_threshold*/ sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, FFMIN(AV_SYNC_THRESHOLD_MAX, delay)); if (!isnan(diff) \u0026\u0026 fabs(diff) \u003c is-\u003emax_frame_duration) { //根据阀值判断是快了还是慢了 if (diff \u003c= -sync_threshold)//差值已经超出阀值最小，视频慢了 delay = FFMAX(0, delay + diff);/*上一帧需要加快，delay + -diff，这样算出来的delay基本都是0，上一帧还要显示delay时间*/ else if (diff \u003e= sync_threshold \u0026\u0026 delay \u003e AV_SYNC_FRAMEDUP_THRESHOLD) delay = delay + diff;/*视频快了，上一帧就要减慢，delay+diff，AV_SYNC_FRAMEDUP_THRESHOLD 0.1秒，如果帧持续时间超过这个值，它将不会被成倍来补偿进行同步*/ else if (diff \u003e= sync_threshold) delay = 2 * delay;/*视频快了，delay 相当上一帧显示两次，因为diff == sync_threshold也是快了一帧*/ } } av_log(NULL, AV_LOG_TRACE, \"video: delay=%0.3f A-V=%f\\n\", delay, -diff); return delay; } sync_threshold理解： 从图上可以看出来sync_threshold是建立一块区域，在这块区域内无需调整lastvp的显示时长，直接返回delay即可。也就是在这块区域内认为是准同步的。\n如果小于-sync_threshold，那就是视频播放较慢，需要适当丢帧。具体是返回一个最大为0的值。根据前面frame_timer的图，至少应更新画面为vp。\n如果大于sync_threshold，那么视频播放太快，需要适当重复显示lastvp。具体是返回2倍的delay，也就是2倍的lastvp显示时长，也就是让lastvp再显示一帧。\n总结 基本策略是：如果视频播放过快，则重复播放上一帧，以等待音频；如果视频播放过慢，则丢帧追赶音频。 这一策略的实现方式是：引入frame_timer概念，标记帧的显示时刻和应结束显示的时刻，再与系统时刻对比，决定重复还是丢帧。 lastvp的应结束显示的时刻，除了考虑这一帧本身的显示时长，还应考虑了video clock与audio clock的差值。 并不是每时每刻都在同步，而是有一个“准同步”的差值区域。 FrameQueue的分析 ffplay 是通过FrameQueue来保存解码后的数据；\nFrame结构体 Frame是用来存储解码后的一帧数据，其中包括视频、音频和字幕；\ntypedef struct Frame { AVFrame *frame;//音视频解码数据 AVSubtitle sub;//字幕解码数据 int serial; double pts; /* presentation timestamp for the frame */ double duration; /* estimated duration of the frame */ int64_t pos; /* byte position of the frame in the input file */ int width; int height; int format; AVRational sar; int uploaded; int flip_v; } Frame; FrameQueue结构体 FrameQueue是用来表示整个帧队列；\ntypedef struct FrameQueue { Frame queue[FRAME_QUEUE_SIZE];//队列元素，用数组模拟队列 int rindex;//读指针 int windex;//写指针 int size;//当前存储的节点个数 int max_size;//最大允许存储的节点个数 int keep_last;//是否要保留最后一个读节点 int rindex_shown;//当前节点是否已经显示 SDL_mutex *mutex; SDL_cond *cond; PacketQueue *pktq;//关联的PacketQueue } FrameQueue; FrameQueue的设计思想是通过数组实现队列（环形缓冲区）；\n设计理念：\n高效率的读写模型 高效的内存模型 环形缓冲区设计，同时可以访问上一读节点 FrameQueue实现函数分析 初始化函数 FrameQueue的初始化函数是frame_queue_init;\nstatic int frame_queue_init(FrameQueue *f, PacketQueue *pktq, int max_size, int keep_last) { int i; memset(f, 0, sizeof(FrameQueue)); if (!(f-\u003emutex = SDL_CreateMutex())) { av_log(NULL, AV_LOG_FATAL, \"SDL_CreateMutex(): %s\\n\", SDL_GetError()); return AVERROR(ENOMEM); } if (!(f-\u003econd = SDL_CreateCond())) { av_log(NULL, AV_LOG_FATAL, \"SDL_CreateCond(): %s\\n\", SDL_GetError()); return AVERROR(ENOMEM); } f-\u003epktq = pktq; f-\u003emax_size = FFMIN(max_size, FRAME_QUEUE_SIZE); f-\u003ekeep_last = !!keep_last; for (i = 0; i \u003c f-\u003emax_size; i++) if (!(f-\u003equeue[i].frame = av_frame_alloc())) return AVERROR(ENOMEM); return 0; } 其中主要是内存初始化和锁初始化，关键参数是max_size和keep_last;max_size是最大允许存储的节点个数,最大不能超过\nFRAME_QUEUE_SIZE，FRAME_QUEUE_SIZE定义如下：\n#define VIDEO_PICTURE_QUEUE_SIZE 3 //视频显示缓存最大帧数 #define SUBPICTURE_QUEUE_SIZE 16 //字幕缓存最大帧数 #define SAMPLE_QUEUE_SIZE 9 //默认最大帧数 #define FRAME_QUEUE_SIZE FFMAX(SAMPLE_QUEUE_SIZE, FFMAX(VIDEO_PICTURE_QUEUE_SIZE, SUBPICTURE_QUEUE_SIZE)) 如此看来最大不能超过16；\nkeep_last是一个bool值，表示是否在环形缓冲区的读写过程中保留最后一个读节点不被覆写。f-\u003ekeep_last = !!keep_last;里的双感叹号是C中的一种技巧，旨在让int参数规整为0/1的“bool值”。\n数组queue中的每个元素的frame(AVFrame*)的字段调用av_frame_alloc分配内存。\n反初始化函数 static void frame_queue_destory(FrameQueue *f) { int i; for (i = 0; i \u003c f-\u003emax_size; i++) { Frame *vp = \u0026f-\u003equeue[i]; frame_queue_unref_item(vp); av_frame_free(\u0026vp-\u003eframe); } SDL_DestroyMutex(f-\u003emutex); SDL_DestroyCond(f-\u003econd); } queue元素的释放分两步；\nframe_queue_unref_item,释放的内存都是关联的内存，而非结构体自身内存; av_frame_free,av_frame_free与初始化中的av_frame_alloc对应，用于释放AVFrame. frame_queue_unref_item定义如下：\nstatic void frame_queue_unref_item(Frame *vp) { av_frame_unref(vp-\u003eframe);//frame计数减1 avsubtitle_free(\u0026vp-\u003esub);//sub关联的内存释放 } AVFrame内部有许多的AVBufferRef类型字段，而AVBufferRef只是AVBuffer的引用，AVBuffer通过引用计数自动管理内存（简易垃圾回收机制）。因此AVFrame在不需要的时候，需要通过av_frame_unref减少引用计数。(这个还在学习阶段)\nFrameQueue的‘写’操作 FrameQueue的‘写’操作分为两个步骤；\nframe_queue_peek_writable获取一个可写节点； frame_queue_push告知FrameQueue“存入”该节点。 FrameQueue始终是一个线程写，另一个线程读。读写没有其他线程产生竞争，唯一需要的是读与写线程间的同步。FrameQueue的整个优化和设计思路正是基于这一点的。这个设计思想类似于Linux内核中的kfifo。\nframe_queue_peek_writable定义如下：\nstatic Frame *frame_queue_peek_writable(FrameQueue *f) { /* wait until we have space to put a new frame */ SDL_LockMutex(f-\u003emutex); while (f-\u003esize \u003e= f-\u003emax_size \u0026\u0026 !f-\u003epktq-\u003eabort_request) { SDL_CondWait(f-\u003econd, f-\u003emutex); } SDL_UnlockMutex(f-\u003emutex); if (f-\u003epktq-\u003eabort_request) return NULL; return \u0026f-\u003equeue[f-\u003ewindex]; } 函数分3步：\n加锁情况下，等待直到队列有空余空间可写（f-\u003esize \u003c f-\u003emax_size） 如果有退出请求（f-\u003epktq-\u003eabort_request），则返回NULL 返回windex位置的元素（windex指向当前应写位置） 因为queue数组被当做一个环形缓冲区使用，那么的确存在underrun和overrun的情况，即读过快，或写过快的情况，这时如果不加控制，就会呈现缓冲区覆盖。\nFrameQueue的精明之处在于，先通过size判断当前缓冲区内空间是否够写，或者够读，比如这里先通过一个循环的条件等待，判断f-\u003esize \u003e= f-\u003emax_size，如果f-\u003esize \u003e= f-\u003emax_size，那么说明队列中的节点已经写满，也就是已经overrun了，此时如果再写，肯定会覆写未读数据，那么就需要继续等待。当无需等待时，windex指向的内存一定是已经读过的（除非代码异常了）。\n调用frame_queue_peek_writable取到Frame指针后，就可以对Frame内的字段自由改写，因为只有一个写进程，且无需担心读进程覆写（如上分析，读进程要读一个节点时，也会先判断underrun的情况）。\n实现步骤：\nFrame* vp = frame_queue_peek_writable(q); //将要存储的数据写入frame字段，比如： av_frame_move_ref(vp-\u003eframe, src_frame); //存入队列 frame_queue_push(q); frame_queue_push代码如下：\nstatic void frame_queue_push(FrameQueue *f) { if (++f-\u003ewindex == f-\u003emax_size) f-\u003ewindex = 0; SDL_LockMutex(f-\u003emutex); f-\u003esize++; SDL_CondSignal(f-\u003econd); SDL_UnlockMutex(f-\u003emutex); } 执行两个步骤：\nwindex加1，如果超过max_size，则回环为0 加锁情况下大小加1. frame_queue的写过程总结示意图如下：\nFrameQueue的’读’操作 FrameQueue的‘读’操作分为两个步骤；\nframe_queue_peek_readable获取一个可读节点 frame_queue_next告知FrameQueue“取出”该节点。 frame_queue_peek_readable代码如下：\nstatic Frame *frame_queue_peek_readable(FrameQueue *f) { /* wait until we have a readable a new frame */ SDL_LockMutex(f-\u003emutex); //加锁情况下，判断是否有可读节点 while (f-\u003esize - f-\u003erindex_shown \u003c= 0 \u0026\u0026 !f-\u003epktq-\u003eabort_request) { SDL_CondWait(f-\u003econd, f-\u003emutex); } SDL_UnlockMutex(f-\u003emutex); //如果有退出请求，则返回NULL if (f-\u003epktq-\u003eabort_request) return NULL; //读取当前可读节点 return \u0026f-\u003equeue[(f-\u003erindex + f-\u003erindex_shown) % f-\u003emax_size]; } frame_queue_next代码如下：\nstatic void frame_queue_next(FrameQueue *f) { //如果支持keep_last，且rindex_shown为0，则rindex_shown赋1，返回 if (f-\u003ekeep_last \u0026\u0026 !f-\u003erindex_shown) { f-\u003erindex_shown = 1; return; } //否则，移动rindex指针，并减小size frame_queue_unref_item(\u0026f-\u003equeue[f-\u003erindex]); if (++f-\u003erindex == f-\u003emax_size) f-\u003erindex = 0; SDL_LockMutex(f-\u003emutex); f-\u003esize--; SDL_CondSignal(f-\u003econd); SDL_UnlockMutex(f-\u003emutex); } frame_queue_next用于在读完一个节点后调用，用于标记一个节点已经被读过。\n读过程可以描述为：\nFrame* vp = frame_queue_peek_readable(f); //读取vp的数据，比如 printf(\"pict_type=%d\\n\", vp-\u003eframe-\u003epict_type); frame_queue_next(f); 标记一个节点为已读，执行两个步骤：\nrindex加1，如果超过max_size，则回环为0 加锁情况下大小减1. 对于以及读过的节点，需要调用frame_queue_unref_item释放关联内存。\n执行rindex操作前，需要先判断rindex_shown的值，如果为0，则赋1。如下图：\n这里模拟了从初始化开始的2次“读”。\n还没开始读，rindex和rindex_shown均为0。这时要peek的读节点是节点0(图中黑色块）。\n第一次读，调用next，满足条件f-\u003ekeep_last \u0026\u0026 !f-\u003erindex_shown，所以rindex仍然是0，而rindex_shown为1.此时节点0（灰色块）是已读节点，也是要keep的last节点，将要读的节点是节点1（黑色块）。（恰好是rindex+rindex_shown）\n第二次读，peek了黑色块后，调用next，不满足条件f-\u003ekeep_last \u0026\u0026 !f-\u003erindex_shown，所以rindex为1，而rindex_shown为2.此时节点1（灰色块）是last节点，节点2（黑色块）是将要读的节点。（也恰好是rindex+rindex_shown）\n继续往后分析，会一直重复第二次读的情况，始终是rindex指向了last，而rindex_shown一直为1，rindex+rindex_shown刚好是将要读的节点。\nFrameQueue的读过程也分析完了。\n辅助函数 //（上文中的用词是“将要读的节点”，也就是黑色块），与frame_queue_peek_readable等效，但没有检查是否有可读节点 //读当前节点 static Frame *frame_queue_peek(FrameQueue *f) { return \u0026f-\u003equeue[(f-\u003erindex + f-\u003erindex_shown) % f-\u003emax_size]; } //读下一个节点 static Frame *frame_queue_peek_next(FrameQueue *f) { return \u0026f-\u003equeue[(f-\u003erindex + f-\u003erindex_shown + 1) % f-\u003emax_size]; } //读上一个节点 static Frame *frame_queue_peek_last(FrameQueue *f) { return \u0026f-\u003equeue[f-\u003erindex]; } /* return the number of undisplayed frames in the queue */ static int frame_queue_nb_remaining(FrameQueue *f) { return f-\u003esize - f-\u003erindex_shown; } /* return last shown position */ static int64_t frame_queue_last_pos(FrameQueue *f) { Frame *fp = \u0026f-\u003equeue[f-\u003erindex]; if (f-\u003erindex_shown \u0026\u0026 fp-\u003eserial == f-\u003epktq-\u003eserial) return fp-\u003epos; else return -1; } 看下节点位置：\n参考链接： https://www.zhihu.com/column/avtec\nhttps://cloud.tencent.com/developer/article/1373966\n",
  "wordCount" : "4314",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://rong05.github.io/learn/av-learn/ffplay_learn/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "LEAN",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rong05.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rong05.github.io/" accesskey="h" title="LEAN (Alt + H)">LEAN</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://rong05.github.io/fr/" title="French"
                            aria-label=":fr:">🇫🇷</a>
                    </li>
                    <li>
                        <a href="https://rong05.github.io/fa/" title="Fa"
                            aria-label="Fa">Fa</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rong05.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://rong05.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://rong05.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://discord.gg/ahpmTvhVmp" title="Discord">
                    <span>Discord</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://rong05.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://rong05.github.io/learn/">Learns</a></div>
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">21 min&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/learn/av-learn/ffplay_learn.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#ffplay%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" aria-label="ffplay源码分析">ffplay源码分析</a><ul>
                        
                <li>
                    <a href="#%e6%80%bb%e7%bb%93%e6%9e%84%e5%9b%be" aria-label="总结构图">总结构图</a></li>
                <li>
                    <a href="#%e8%a7%86%e9%a2%91%e9%83%a8%e5%88%86" aria-label="视频部分">视频部分</a><ul>
                        
                <li>
                    <a href="#ffplay-video%e7%9a%84%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%bc%8f" aria-label="ffplay video的线程模式">ffplay video的线程模式</a><ul>
                        
                <li>
                    <a href="#stream_open" aria-label="stream_open">stream_open</a></li>
                <li>
                    <a href="#%e8%af%bb%e5%8f%96%e7%ba%bf%e7%a8%8bread_thread" aria-label="读取线程(read_thread)">读取线程(read_thread)</a><ul>
                        
                <li>
                    <a href="#%e5%87%86%e5%a4%87%e9%98%b6%e6%ae%b5" aria-label="准备阶段">准备阶段</a><ul>
                        
                <li>
                    <a href="#avformat_open_input" aria-label="avformat_open_input"><strong><code>avformat_open_input</code></strong></a></li>
                <li>
                    <a href="#avformat_find_stream_info" aria-label="avformat_find_stream_info"><strong><code>avformat_find_stream_info</code></strong></a></li>
                <li>
                    <a href="#av_find_best_stream" aria-label="av_find_best_stream"><strong><code>av_find_best_stream</code></strong></a></li>
                <li>
                    <a href="#stream_component_open" aria-label="stream_component_open"><strong><code>stream_component_open</code></strong></a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%bb%e5%be%aa%e7%8e%af%e8%af%bb%e6%95%b0%e6%8d%ae" aria-label="主循环读数据">主循环读数据</a><ul>
                        
                <li>
                    <a href="#%e6%9a%82%e5%81%9c%e6%81%a2%e5%a4%8d%e5%a4%84%e7%90%86" aria-label="暂停/恢复处理：">暂停/恢复处理：</a></li>
                <li>
                    <a href="#seek%e7%9a%84%e5%a4%84%e7%90%86" aria-label="seek的处理：">seek的处理：</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e5%8c%ba%e5%a4%a7%e5%b0%8f%e5%88%a4%e6%96%ad" aria-label="缓冲区大小判断：">缓冲区大小判断：</a></li>
                <li>
                    <a href="#%e5%9c%a8%e6%92%ad%e6%94%be%e5%ae%8c%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e5%a4%84%e7%90%86" aria-label="在播放完的情况下处理：">在播放完的情况下处理：</a></li>
                <li>
                    <a href="#%e8%af%bb%e8%a7%a3%e5%a4%8d%e7%94%a8%e5%a4%84%e7%90%86" aria-label="读（解复用）处理：">读（解复用）处理：</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%a7%86%e9%a2%91%e8%a7%a3%e7%a0%81%e7%ba%bf%e7%a8%8bvideo_thread" aria-label="视频解码线程(video_thread)">视频解码线程(video_thread)</a><ul>
                        
                <li>
                    <a href="#%e5%8f%82%e6%95%b0%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="参数初始化">参数初始化</a></li>
                <li>
                    <a href="#%e5%be%aa%e7%8e%af%e8%a7%a3%e7%a0%81" aria-label="循环解码">循环解码</a><ul>
                        
                <li>
                    <a href="#get_video_frame" aria-label="get_video_frame"><code>get_video_frame</code></a></li>
                <li>
                    <a href="#decoder_decode_frame" aria-label="decoder_decode_frame"><code>decoder_decode_frame</code></a></li>
                <li>
                    <a href="#queue_picture" aria-label="queue_picture"><code>queue_picture</code></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#ffplay-audio%e8%be%93%e5%87%ba%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%88%86%e6%9e%90" aria-label="ffplay audio输出的线程分析">ffplay audio输出的线程分析</a><ul>
                        
                <li>
                    <a href="#sdl%e6%89%93%e5%bc%80%e9%9f%b3%e9%a2%91%e8%be%93%e5%87%ba" aria-label="sdl打开音频输出">sdl打开音频输出</a></li>
                <li>
                    <a href="#%e9%9f%b3%e9%a2%91%e8%be%93%e5%87%ba%e9%80%bb%e8%be%91" aria-label="音频输出逻辑">音频输出逻辑</a></li>
                <li>
                    <a href="#%e5%a1%ab%e5%85%85audio_buf" aria-label="填充audio_buf">填充audio_buf</a></li></ul>
                </li>
                <li>
                    <a href="#ffplay%e6%97%b6%e9%97%b4%e5%90%8c%e6%ad%a5" aria-label="ffplay时间同步">ffplay时间同步</a><ul>
                        
                <li>
                    <a href="#dts%e5%92%8cpts" aria-label="DTS和PTS">DTS和PTS</a></li>
                <li>
                    <a href="#%e8%ae%a1%e7%ae%97%e8%a7%86%e9%a2%91frame%e7%9a%84%e6%98%be%e7%a4%ba%e6%97%b6%e9%97%b4" aria-label="计算视频Frame的显示时间">计算视频Frame的显示时间</a></li>
                <li>
                    <a href="#%e4%bb%a5%e9%9f%b3%e9%a2%91%e4%b8%ba%e4%b8%bb%e6%97%b6%e9%92%9f%e5%90%8c%e6%ad%a5" aria-label="以音频为主时钟同步">以音频为主时钟同步</a><ul>
                        
                <li>
                    <a href="#frame_timer" aria-label="frame_timer"><code>frame_timer</code></a></li>
                <li>
                    <a href="#dealy%e8%ae%a1%e7%ae%97" aria-label="dealy计算">dealy计算</a></li>
                <li>
                    <a href="#sync_threshold%e7%90%86%e8%a7%a3" aria-label="sync_threshold理解："><code>sync_threshold</code>理解：</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#framequeue%e7%9a%84%e5%88%86%e6%9e%90" aria-label="FrameQueue的分析"><code>FrameQueue</code>的分析</a><ul>
                        
                <li>
                    <a href="#frame%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="Frame结构体"><code>Frame</code>结构体</a></li>
                <li>
                    <a href="#framequeue%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="FrameQueue结构体"><code>FrameQueue</code>结构体</a></li>
                <li>
                    <a href="#framequeue%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e5%88%86%e6%9e%90" aria-label="FrameQueue实现函数分析"><code>FrameQueue</code>实现函数分析</a><ul>
                        
                <li>
                    <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e5%87%bd%e6%95%b0" aria-label="初始化函数">初始化函数</a></li>
                <li>
                    <a href="#%e5%8f%8d%e5%88%9d%e5%a7%8b%e5%8c%96%e5%87%bd%e6%95%b0" aria-label="反初始化函数">反初始化函数</a></li>
                <li>
                    <a href="#framequeue%e7%9a%84%e5%86%99%e6%93%8d%e4%bd%9c" aria-label="FrameQueue的‘写’操作">FrameQueue的‘写’操作</a></li>
                <li>
                    <a href="#framequeue%e7%9a%84%e8%af%bb%e6%93%8d%e4%bd%9c" aria-label="FrameQueue的&amp;rsquo;读&amp;rsquo;操作">FrameQueue的&rsquo;读&rsquo;操作</a></li>
                <li>
                    <a href="#%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0" aria-label="辅助函数">辅助函数</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" aria-label="参考链接：">参考链接：</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>[TOC]</p>
<h1 id="ffplay源码分析">ffplay源码分析<a hidden class="anchor" aria-hidden="true" href="#ffplay源码分析">#</a></h1>
<p>熟悉FFmpeg项目从源码看起，以下是我阅读FFplay的源代码的总结；FFplay是FFmpeg项目提供的播放器示例，它的源代码的量也是不少的，其中很多知识点是我们可以学习和借鉴的。</p>
<h2 id="总结构图">总结构图<a hidden class="anchor" aria-hidden="true" href="#总结构图">#</a></h2>
<p>参照雷神（<a href="https://blog.csdn.net/leixiaohua1020">雷霄骅</a>）的FFplay的总体函数调用结构图，自己总结了一个最新版本的结构，其中还有诸多不足，以后有机会慢慢完善；如下图所示。</p>
<img src="img/ffplay.png" alt="总结构图" style="zoom:50%;" />
<p>这就不对主要函数分别解析，我来学习一下其中关键性的思想和ffplay的体系结构。</p>
<h2 id="视频部分">视频部分<a hidden class="anchor" aria-hidden="true" href="#视频部分">#</a></h2>
<h3 id="ffplay-video的线程模式">ffplay video的线程模式<a hidden class="anchor" aria-hidden="true" href="#ffplay-video的线程模式">#</a></h3>
<img src="img/ffplay_video.png" style="zoom:50%;" />
<p>ffplay选择了sdl作为显示SDK，以实现跨平台支持；因为使用了SDL，而video的显示也依赖SDL的窗口显示系统，所以先从main函数的SDL初始化看起：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">       <span class="cm">/* register all codecs, demux and protocols */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if CONFIG_AVDEVICE
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="nf">avdevice_register_all</span><span class="p">();</span> <span class="c1">//注册所有解码器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="nf">avformat_network_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">init_opts</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sigterm_handler</span><span class="p">);</span>  <span class="cm">/* Interrupt (ANSI).    */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">sigterm_handler</span><span class="p">);</span> <span class="cm">/* Termination (ANSI).  */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">show_banner</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span> <span class="c1">//打印ffmpag库版本信息，编译时间，编译选项，类库信息等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nf">parse_options</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">opt_input_file</span><span class="p">);</span> <span class="c1">//解析输入的命令。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="nf">SDL_Init</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="c1">//初始化sdl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_FATAL</span><span class="p">,</span> <span class="s">&#34;Could not initialize SDL - %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">SDL_GetError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_FATAL</span><span class="p">,</span> <span class="s">&#34;(Did you set the DISPLAY variable?)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_EventState</span><span class="p">(</span><span class="n">SDL_SYSWMEVENT</span><span class="p">,</span> <span class="n">SDL_IGNORE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_EventState</span><span class="p">(</span><span class="n">SDL_USEREVENT</span><span class="p">,</span> <span class="n">SDL_IGNORE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">  	<span class="c1">//注册flush packet 只是一个标记作用，用于packet队列中，在对packet队列分析时有说明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">av_init_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flush_pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">flush_pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">flush_pkt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">display_disable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">SDL_WINDOW_HIDDEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">alwaysontop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if SDL_VERSION_ATLEAST(2, 0, 5)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="n">flags</span> <span class="o">|=</span> <span class="n">SDL_WINDOW_ALWAYS_ON_TOP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_WARNING</span><span class="p">,</span> <span class="s">&#34;Your SDL version doesn&#39;t support SDL_WINDOW_ALWAYS_ON_TOP. Feature will be inactive.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">borderless</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">flags</span> <span class="o">|=</span> <span class="n">SDL_WINDOW_BORDERLESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">flags</span> <span class="o">|=</span> <span class="n">SDL_WINDOW_RESIZABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="c1">//创建sdl 窗口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">window</span> <span class="o">=</span> <span class="nf">SDL_CreateWindow</span><span class="p">(</span><span class="n">program_name</span><span class="p">,</span> <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span> <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span> <span class="n">default_width</span><span class="p">,</span> <span class="n">default_height</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">SDL_SetHint</span><span class="p">(</span><span class="n">SDL_HINT_RENDER_SCALE_QUALITY</span><span class="p">,</span> <span class="s">&#34;linear&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">//创建sdl 窗口的渲染器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">renderer</span> <span class="o">=</span> <span class="nf">SDL_CreateRenderer</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">SDL_RENDERER_ACCELERATED</span> <span class="o">|</span> <span class="n">SDL_RENDERER_PRESENTVSYNC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">renderer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_WARNING</span><span class="p">,</span> <span class="s">&#34;Failed to initialize a hardware accelerated renderer: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">SDL_GetError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">                <span class="n">renderer</span> <span class="o">=</span> <span class="nf">SDL_CreateRenderer</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">renderer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">SDL_GetRendererInfo</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">renderer_info</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_VERBOSE</span><span class="p">,</span> <span class="s">&#34;Initialized %s renderer.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">renderer_info</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">window</span> <span class="o">||</span> <span class="o">!</span><span class="n">renderer</span> <span class="o">||</span> <span class="o">!</span><span class="n">renderer_info</span><span class="p">.</span><span class="n">num_texture_formats</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_FATAL</span><span class="p">,</span> <span class="s">&#34;Failed to create window or renderer: %s&#34;</span><span class="p">,</span> <span class="nf">SDL_GetError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="nf">do_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="n">is</span> <span class="o">=</span> <span class="nf">stream_open</span><span class="p">(</span><span class="n">input_filename</span><span class="p">,</span> <span class="n">file_iformat</span><span class="p">);</span> <span class="c1">//创建read_thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_FATAL</span><span class="p">,</span> <span class="s">&#34;Failed to initialize VideoState!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">do_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">event_loop</span><span class="p">(</span><span class="n">is</span><span class="p">);</span> <span class="c1">//主线程 ，sdl——event事件监听和处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>而这里我们主要的两个函数是<code>stream_open</code>和<code>event_loop</code>；<code>stream_open</code>函数的作用是创建<code>read_thread</code>，<code>read_thread</code>会打开文件，解析封装，获取<code>AVStream</code>信息，启动解码器（创建解码线程），并开始读取文件；<code>event_loop</code>函数的作用是处理SDL事件队列中的事件和刷新显示数据，下面会针对这两个函数视频部分的内容进行详细说明。</p>
<h4 id="stream_open">stream_open<a hidden class="anchor" aria-hidden="true" href="#stream_open">#</a></h4>
<p>其实在<code>stream_open</code>函数里的关键内容都是初始化一些参数，主要的处理逻辑在<code>read_thread</code>中进行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">VideoState</span> <span class="o">*</span><span class="nf">stream_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="n">AVInputFormat</span> <span class="o">*</span><span class="n">iformat</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">VideoState</span> <span class="o">*</span><span class="n">is</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">is</span> <span class="o">=</span> <span class="nf">av_mallocz</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">VideoState</span><span class="p">));</span> <span class="c1">//创建VideoState 这个很重要，它贯穿整个ffplay
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* start video display */</span> <span class="c1">//初始化解码后的帧队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">frame_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">,</span> <span class="n">VIDEO_PICTURE_QUEUE_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">     <span class="c1">//初始化解码前的帧队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">packet_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="p">...</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//创建读线程的条件信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">continue_read_thread</span> <span class="o">=</span> <span class="nf">SDL_CreateCond</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_FATAL</span><span class="p">,</span> <span class="s">&#34;SDL_CreateCond(): %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">SDL_GetError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">init_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">vidclk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">.</span><span class="n">serial</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">is</span><span class="o">-&gt;</span><span class="n">read_tid</span> <span class="o">=</span> <span class="nf">SDL_CreateThread</span><span class="p">(</span><span class="n">read_thread</span><span class="p">,</span> <span class="s">&#34;read_thread&#34;</span><span class="p">,</span> <span class="n">is</span><span class="p">);</span> <span class="c1">//创建读线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="nl">fail</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nf">stream_close</span><span class="p">(</span><span class="n">is</span><span class="p">);</span><span class="c1">//出错free一些初始化参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>**<code>VideoState</code>**结构的参数详细说明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*视频状态器，贯穿整个ffplay的结构*/</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VideoState</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SDL_Thread</span> <span class="o">*</span><span class="n">read_tid</span><span class="p">;</span>      <span class="c1">//解复用（或读）线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVInputFormat</span> <span class="o">*</span><span class="n">iformat</span><span class="p">;</span>    <span class="c1">//输入格式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">abort_request</span><span class="p">;</span>         <span class="c1">//中止请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">force_refresh</span><span class="p">;</span>         <span class="c1">//强制刷新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">paused</span><span class="p">;</span>                <span class="c1">//暂停
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">last_paused</span><span class="p">;</span>           <span class="c1">//最后一次暂停状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">queue_attachments_req</span><span class="p">;</span> <span class="c1">//队列附件请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">seek_req</span><span class="p">;</span>              <span class="c1">//快进请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">seek_flags</span><span class="p">;</span>            <span class="c1">//快进标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int64_t</span> <span class="n">seek_pos</span><span class="p">;</span>          <span class="c1">//快进位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int64_t</span> <span class="n">seek_rel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">read_pause_return</span><span class="p">;</span> <span class="c1">//读暂停
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">ic</span><span class="p">;</span>   <span class="c1">//解码格式上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">realtime</span><span class="p">;</span>          <span class="c1">//是否实时码流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Clock</span> <span class="n">audclk</span><span class="p">;</span> <span class="c1">//音频时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Clock</span> <span class="n">vidclk</span><span class="p">;</span> <span class="c1">//视频时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Clock</span> <span class="n">extclk</span><span class="p">;</span> <span class="c1">//外部时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">FrameQueue</span> <span class="n">pictq</span><span class="p">;</span> <span class="c1">//视频队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">FrameQueue</span> <span class="n">subpq</span><span class="p">;</span> <span class="c1">//字幕队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">FrameQueue</span> <span class="n">sampq</span><span class="p">;</span> <span class="c1">//pcm流队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Decoder</span> <span class="n">auddec</span><span class="p">;</span> <span class="c1">//音频解码器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Decoder</span> <span class="n">viddec</span><span class="p">;</span> <span class="c1">//视频解码器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Decoder</span> <span class="n">subdec</span><span class="p">;</span> <span class="c1">//字幕解码器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">audio_stream</span><span class="p">;</span> <span class="c1">//音频码流id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">av_sync_type</span><span class="p">;</span> <span class="c1">//时钟同步类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">audio_clock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">audio_clock_serial</span><span class="p">;</span> <span class="c1">//音频时钟序号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">audio_diff_cum</span><span class="p">;</span>  <span class="c1">// 用于音频差分计算 /* used for AV difference average computation */
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">audio_diff_avg_coef</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">audio_diff_threshold</span><span class="p">;</span>        <span class="c1">//音频差分阈值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">audio_diff_avg_count</span><span class="p">;</span>           <span class="c1">// 平均差分数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVStream</span> <span class="o">*</span><span class="n">audio_st</span><span class="p">;</span>                 <span class="c1">// 音频码流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">PacketQueue</span> <span class="n">audioq</span><span class="p">;</span>                 <span class="c1">// 音频源包队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">audio_hw_buf_size</span><span class="p">;</span>              <span class="c1">// 硬件缓冲大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">audio_buf</span><span class="p">;</span>                 <span class="c1">// 音频缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">audio_buf1</span><span class="p">;</span>                <span class="c1">// 音频缓冲区1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_buf_size</span><span class="p">;</span>        <span class="c1">// 音频缓冲大小 /* in bytes */
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_buf1_size</span><span class="p">;</span>       <span class="c1">// 音频缓冲大小 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">audio_buf_index</span><span class="p">;</span> <span class="cm">/* in bytes */</span> <span class="c1">// 音频缓冲索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">audio_write_buf_size</span><span class="p">;</span>           <span class="c1">// 音频写入缓冲大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">audio_volume</span><span class="p">;</span>                   <span class="c1">// 音量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">muted</span><span class="p">;</span>                          <span class="c1">// 是否静音
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">AudioParams</span> <span class="n">audio_src</span><span class="p">;</span>       <span class="c1">// 音频参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#if CONFIG_AVFILTER
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">struct</span> <span class="n">AudioParams</span> <span class="n">audio_filter_src</span><span class="p">;</span> <span class="c1">// 音频过滤器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">struct</span> <span class="n">AudioParams</span> <span class="n">audio_tgt</span><span class="p">;</span> <span class="c1">// 音频参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">SwrContext</span> <span class="o">*</span><span class="n">swr_ctx</span><span class="p">;</span>   <span class="c1">// 音频转码上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">frame_drops_early</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">frame_drops_late</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">enum</span> <span class="n">ShowMode</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="c1">// 显示类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">SHOW_MODE_NONE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">SHOW_MODE_VIDEO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">SHOW_MODE_WAVES</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">SHOW_MODE_RDFT</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">SHOW_MODE_NB</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">show_mode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int16_t</span> <span class="n">sample_array</span><span class="p">[</span><span class="n">SAMPLE_ARRAY_SIZE</span><span class="p">];</span> <span class="c1">// 采样数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">sample_array_index</span><span class="p">;</span>                  <span class="c1">// 采样索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">last_i_start</span><span class="p">;</span>                        <span class="c1">// 上一开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">RDFTContext</span> <span class="o">*</span><span class="n">rdft</span><span class="p">;</span>                       <span class="c1">// 自适应滤波器上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">rdft_bits</span><span class="p">;</span>                           <span class="c1">// 自使用比特率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">FFTSample</span> <span class="o">*</span><span class="n">rdft_data</span><span class="p">;</span>                    <span class="c1">// 快速傅里叶采样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">xpos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">last_vis_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">vis_texture</span><span class="p">;</span> <span class="c1">// 音频Texture
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">sub_texture</span><span class="p">;</span> <span class="c1">// 字幕Texture
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">vid_texture</span><span class="p">;</span> <span class="c1">// 视频Texture
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">subtitle_stream</span><span class="p">;</span>   <span class="c1">// 字幕码流Id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVStream</span> <span class="o">*</span><span class="n">subtitle_st</span><span class="p">;</span> <span class="c1">// 字幕码流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">PacketQueue</span> <span class="n">subtitleq</span><span class="p">;</span> <span class="c1">// 字幕源包队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">frame_timer</span><span class="p">;</span>                 <span class="c1">// 帧计时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">frame_last_returned_time</span><span class="p">;</span>    <span class="c1">// 上一次返回时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">frame_last_filter_delay</span><span class="p">;</span>     <span class="c1">// 上一个过滤器延时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">video_stream</span><span class="p">;</span>                   <span class="c1">// 视频码流Id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVStream</span> <span class="o">*</span><span class="n">video_st</span><span class="p">;</span>                 <span class="c1">// 视频码流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">PacketQueue</span> <span class="n">videoq</span><span class="p">;</span>                 <span class="c1">// 视频包队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">max_frame_duration</span><span class="p">;</span>          <span class="c1">// 最大帧间显示时间     // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">SwsContext</span> <span class="o">*</span><span class="n">img_convert_ctx</span><span class="p">;</span> <span class="c1">// 视频转码上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">SwsContext</span> <span class="o">*</span><span class="n">sub_convert_ctx</span><span class="p">;</span> <span class="c1">// 字幕转码上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">eof</span><span class="p">;</span>                            <span class="c1">// 结束标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>                 <span class="c1">// 文件名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">xleft</span><span class="p">,</span> <span class="n">ytop</span><span class="p">;</span> <span class="c1">// 宽高，其实坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">step</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if CONFIG_AVFILTER
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="kt">int</span> <span class="n">vfilter_idx</span><span class="p">;</span>                   <span class="c1">// 过滤器索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVFilterContext</span> <span class="o">*</span><span class="n">in_video_filter</span><span class="p">;</span>  <span class="c1">// the first filter in the video chain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVFilterContext</span> <span class="o">*</span><span class="n">out_video_filter</span><span class="p">;</span> <span class="c1">// the last filter in the video chain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVFilterContext</span> <span class="o">*</span><span class="n">in_audio_filter</span><span class="p">;</span>  <span class="c1">// the first filter in the audio chain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVFilterContext</span> <span class="o">*</span><span class="n">out_audio_filter</span><span class="p">;</span> <span class="c1">// the last filter in the audio chain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVFilterGraph</span> <span class="o">*</span><span class="n">agraph</span><span class="p">;</span>             <span class="c1">// audio filter graph
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">last_video_stream</span><span class="p">,</span> <span class="n">last_audio_stream</span><span class="p">,</span> <span class="n">last_subtitle_stream</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SDL_cond</span> <span class="o">*</span><span class="n">continue_read_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">VideoState</span><span class="p">;</span>
</span></span></code></pre></div><h4 id="读取线程read_thread">读取线程(read_thread)<a hidden class="anchor" aria-hidden="true" href="#读取线程read_thread">#</a></h4>
<p>read_thread主要按以下步骤执行：</p>
<ol>
<li>准备阶段：打开文件，检测Stream信息，打开解码器</li>
<li>主循环读数据，解封装：读取Packet，存入PacketQueue</li>
</ol>
<p>read_thread的函数比较长，这里不贴完整代码，直接根据其功能分步分析。</p>
<h5 id="准备阶段">准备阶段<a hidden class="anchor" aria-hidden="true" href="#准备阶段">#</a></h5>
<p>主要执行一下几个步骤的函数：</p>
<ol>
<li><code>avformat_open_input</code></li>
<li><code>avformat_find_stream_info</code></li>
<li><code>av_find_best_stream</code></li>
<li><code>stream_component_open</code></li>
</ol>
<h6 id="avformat_open_input"><strong><code>avformat_open_input</code></strong><a hidden class="anchor" aria-hidden="true" href="#avformat_open_input">#</a></h6>
<p>该函数用于打开输入流（这个包括文件和网络流，在ffmpeg内部会把每一个协议封装成<code>URLProtocol</code>，文件对于ffmpeg也是一种协议“file”）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="n">ic</span> <span class="o">=</span> <span class="nf">avformat_alloc_context</span><span class="p">();</span> <span class="c1">//创建 AVformatContext
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_FATAL</span><span class="p">,</span> <span class="s">&#34;Could not allocate context.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置解码中断回调方法 ，这很重要，在网络中断的时候，发生调用；不设置很容易造成阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ic</span><span class="o">-&gt;</span><span class="n">interrupt_callback</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">decode_interrupt_cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ic</span><span class="o">-&gt;</span><span class="n">interrupt_callback</span><span class="p">.</span><span class="n">opaque</span> <span class="o">=</span> <span class="n">is</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">av_dict_get</span><span class="p">(</span><span class="n">format_opts</span><span class="p">,</span> <span class="s">&#34;scan_all_pmts&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_DICT_MATCH_CASE</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_dict_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format_opts</span><span class="p">,</span> <span class="s">&#34;scan_all_pmts&#34;</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="n">AV_DICT_DONT_OVERWRITE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">scan_all_pmts_set</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="nf">avformat_open_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ic</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">iformat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">format_opts</span><span class="p">);</span> <span class="c1">//打开文件或网络流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">print_error</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>重点强调：**<code>interrupt_callback</code>**用于ffmpeg内部在执行耗时操作时检查是否有退出请求，并提前中断，避免用户退出请求没有及时响应；</p>
<h6 id="avformat_find_stream_info"><strong><code>avformat_find_stream_info</code></strong><a hidden class="anchor" aria-hidden="true" href="#avformat_find_stream_info">#</a></h6>
<p>该函数是通过读取媒体文件的部分数据来分析流信息；在一些缺少头信息的封装下特别有用，如注释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Read</span> <span class="n">packets</span> <span class="n">of</span> <span class="n">a</span> <span class="n">media</span> <span class="n">file</span> <span class="n">to</span> <span class="n">get</span> <span class="n">stream</span> <span class="n">information</span><span class="p">.</span> <span class="n">This</span>
</span></span><span class="line"><span class="cl"><span class="n">is</span> <span class="n">useful</span> <span class="k">for</span> <span class="n">file</span> <span class="n">formats</span> <span class="n">with</span> <span class="n">no</span> <span class="n">headers</span> <span class="n">such</span> <span class="n">as</span> <span class="n">MPEG</span><span class="p">.</span> <span class="n">This</span>
</span></span><span class="line"><span class="cl"><span class="n">function</span> <span class="n">also</span> <span class="n">computes</span> <span class="n">the</span> <span class="n">real</span> <span class="n">framerate</span> <span class="n">in</span> <span class="k">case</span> <span class="n">of</span> <span class="n">MPEG</span><span class="o">-</span><span class="mi">2</span> <span class="n">repeat</span>
</span></span><span class="line"><span class="cl"><span class="n">rame</span> <span class="n">mode</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="n">The</span> <span class="n">logical</span> <span class="n">file</span> <span class="n">position</span> <span class="n">is</span> <span class="n">not</span> <span class="n">changed</span> <span class="n">by</span> <span class="n">this</span> <span class="n">function</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">examined</span> <span class="n">packets</span> <span class="n">may</span> <span class="n">be</span> <span class="n">buffered</span> <span class="k">for</span> <span class="n">later</span> <span class="n">processing</span><span class="p">.</span>
</span></span></code></pre></div><h6 id="av_find_best_stream"><strong><code>av_find_best_stream</code></strong><a hidden class="anchor" aria-hidden="true" href="#av_find_best_stream">#</a></h6>
<p>该函数选择对应的媒体流，ffplay主要通过下述注释中的3个参数找到“最佳流”；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">av_find_best_stream</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">ic</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="k">enum</span> <span class="n">AVMediaType</span> <span class="n">type</span><span class="p">,</span><span class="c1">//要选择的流类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="kt">int</span> <span class="n">wanted_stream_nb</span><span class="p">,</span><span class="c1">//目标流索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="kt">int</span> <span class="n">related_stream</span><span class="p">,</span><span class="c1">//参考流索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">AVCodec</span> <span class="o">**</span><span class="n">decoder_ret</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</span></span></code></pre></div><h6 id="stream_component_open"><strong><code>stream_component_open</code></strong><a hidden class="anchor" aria-hidden="true" href="#stream_component_open">#</a></h6>
<p>该函数是根据目标流打开对应的解码器；<code>stream_component_open</code>的函数内容比较长，接下来就逐步分析一下ffplay是如何打开解码器的：</p>
<ol>
<li>创建和初始化<code>AVCodecContex</code>，然后通过<code>avcodec_parameters_to_context</code>把所选流的解码参数赋给<code>avctx</code>，最后设了<code>time_base</code>.代码如下：</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">   <span class="c1">//创建编解码器上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">avctx</span> <span class="o">=</span> <span class="nf">avcodec_alloc_context3</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//从找到对应的流中的codecpar，codecpar其实是avcodec_parameters，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 然后将它完全复制到创建的AVCodecContext
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="nf">avcodec_parameters_to_context</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">stream_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">pkt_timebase</span> <span class="o">=</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">stream_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">;</span>
</span></span></code></pre></div><ol start="2">
<li>
<p>通过<code>avcodec_find_decoder</code>找到对应的解码器（<code>AVCodec</code>）,如果用户设置了<code>forced_codec_name</code>，则通过<code>avcodec_find_decoder_by_name</code>找到对应的解码器；在找到解码器后通过<code>avcodec_open2</code>是否能打开解码器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="n">codec</span> <span class="o">=</span> <span class="nf">avcodec_find_decoder</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">codec_id</span><span class="p">);</span> <span class="c1">//找到对应的解码器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">AVMEDIA_TYPE_AUDIO</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">last_audio_stream</span> <span class="o">=</span> <span class="n">stream_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">forced_codec_name</span> <span class="o">=</span> <span class="n">audio_codec_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">AVMEDIA_TYPE_SUBTITLE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">last_subtitle_stream</span> <span class="o">=</span> <span class="n">stream_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">forced_codec_name</span> <span class="o">=</span> <span class="n">subtitle_codec_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">AVMEDIA_TYPE_VIDEO</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">last_video_stream</span> <span class="o">=</span> <span class="n">stream_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">forced_codec_name</span> <span class="o">=</span> <span class="n">video_codec_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//通过编码器的名字，来打开对应的解码器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">forced_codec_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">codec</span> <span class="o">=</span> <span class="nf">avcodec_find_decoder_by_name</span><span class="p">(</span><span class="n">forced_codec_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">forced_codec_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_WARNING</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="s">&#34;No codec could be found with name &#39;%s&#39;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">forced_codec_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_WARNING</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="s">&#34;No decoder could be found for codec %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">avcodec_get_name</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">codec_id</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//打开解码器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="nf">avcodec_open2</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>对于解码器特定参数的初始化和创建对应流的解码线程；（节选自AVMEDIA_TYPE_VIDEO分支）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span> <span class="o">=</span> <span class="n">stream_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span> <span class="o">=</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">stream_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">decoder_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">viddec</span><span class="p">,</span> <span class="n">avctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">continue_read_thread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="nf">decoder_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">viddec</span><span class="p">,</span> <span class="n">video_thread</span><span class="p">,</span> <span class="s">&#34;video_decoder&#34;</span><span class="p">,</span> <span class="n">is</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">queue_attachments_req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></div><p>看看<code>decoder_init</code>和<code>decoder_start</code>两个函数的定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decoder_init</span><span class="p">(</span><span class="n">Decoder</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">PacketQueue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="n">SDL_cond</span> <span class="o">*</span><span class="n">empty_queue_cond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Decoder</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="o">-&gt;</span><span class="n">avctx</span> <span class="o">=</span> <span class="n">avctx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="o">-&gt;</span><span class="n">empty_queue_cond</span> <span class="o">=</span> <span class="n">empty_queue_cond</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="o">-&gt;</span><span class="n">start_pts</span> <span class="o">=</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="o">-&gt;</span><span class="n">pkt_serial</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">decoder_start</span><span class="p">(</span><span class="n">Decoder</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">thread_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">packet_queue_start</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="o">-&gt;</span><span class="n">decoder_tid</span> <span class="o">=</span> <span class="nf">SDL_CreateThread</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">thread_name</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">decoder_tid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span> <span class="s">&#34;SDL_CreateThread(): %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">SDL_GetError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>decoder_init</code>比较简单，看<code>decoder_start</code>。<code>decoder_start</code>中“启动”了PacketQueue，并创建了一个名为&quot;decoder&quot;的线程专门用于解码，具体的解码流程由传入参数fn决定。比如对于视频，是<code>video_thread</code>。</p>
</li>
</ol>
<h5 id="主循环读数据">主循环读数据<a hidden class="anchor" aria-hidden="true" href="#主循环读数据">#</a></h5>
<p>在读线程中的主循环读数据阶段，主要的代码就<code>av_read_frame</code>和<code>packet_queue_put</code>，<code>av_read_frame</code>从文件中读取视频数据，并获取一个AVPacket，<code>packet_queue_put</code>把它放入到对应的PacketQueue中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">abort_request</span><span class="p">)</span> <span class="c1">//中断，结束播放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span> <span class="o">!=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">last_paused</span><span class="p">)</span><span class="c1">//暂停/恢复的处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="p">...</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">       	<span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">seek_req</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="c1">//跳帧请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="p">...</span>
</span></span><span class="line"><span class="cl">       	<span class="p">}</span>
</span></span><span class="line"><span class="cl">      	   <span class="cm">/* if the queue are full, no need to read more */</span> <span class="c1">//数据队列满的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">infinite_buffer</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">MAX_QUEUE_SIZE</span> <span class="o">||</span> <span class="p">(</span><span class="nf">stream_has_enough_packets</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_st</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                                                                                         <span class="nf">stream_has_enough_packets</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                                                                                         <span class="nf">stream_has_enough_packets</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_st</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* wait 10 ms */</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_LockMutex</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_CondWaitTimeout</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">continue_read_thread</span><span class="p">,</span> <span class="n">wait_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_UnlockMutex</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//循环播放处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_st</span> <span class="o">||</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">auddec</span><span class="p">.</span><span class="n">finished</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">.</span><span class="n">serial</span> <span class="o">&amp;&amp;</span> <span class="nf">frame_queue_nb_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">sampq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span> <span class="o">||</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">viddec</span><span class="p">.</span><span class="n">finished</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">.</span><span class="n">serial</span> <span class="o">&amp;&amp;</span> <span class="nf">frame_queue_nb_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">loop</span> <span class="o">||</span> <span class="o">--</span><span class="n">loop</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">stream_seek</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">start_time</span> <span class="o">!=</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">?</span> <span class="nl">start_time</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">autoexit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ret</span> <span class="o">=</span> <span class="n">AVERROR_EOF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="nf">av_read_frame</span><span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span> <span class="c1">//将数据读取出，送入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">==</span> <span class="n">AVERROR_EOF</span> <span class="o">||</span> <span class="nf">avio_feof</span><span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">pb</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_put_nullpacket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_put_nullpacket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_stream</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_put_nullpacket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">is</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">pb</span> <span class="o">&amp;&amp;</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">pb</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">autoexit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*读取失败的话，读取失败的原因有很多，其他地方可能会重新Signal这个锁condition。如果没有singal这个condition的话，就会等待10ms之后，
</span></span></span><span class="line"><span class="cl"><span class="cm">            再释放，重新循环读取. 那这个continue_read_thread 到底是锁了哪呢？*/</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_LockMutex</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_CondWaitTimeout</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">continue_read_thread</span><span class="p">,</span> <span class="n">wait_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_UnlockMutex</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">is</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* check if packet is in play range specified by user, then queue, otherwise discard */</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//记录stream_start_time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stream_start_time</span> <span class="o">=</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果没有pts, 就用dts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pkt_ts</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">==</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">?</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="nl">dts</span> <span class="p">:</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">pts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*判断是否在范围内。如果duration还没被定义的话，通过
</span></span></span><span class="line"><span class="cl"><span class="cm">        或者在定义的duration内才可以，用当前的pts-start_time .
</span></span></span><span class="line"><span class="cl"><span class="cm">        duration 会在解码器打开之后，才会被初始化*/</span>
</span></span><span class="line"><span class="cl">        <span class="n">pkt_in_play_range</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">==</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                            <span class="p">(</span><span class="n">pkt_ts</span> <span class="o">-</span> <span class="p">(</span><span class="n">stream_start_time</span> <span class="o">!=</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">?</span> <span class="nl">stream_start_time</span> <span class="p">:</span> <span class="mi">0</span><span class="p">))</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">                                        <span class="nf">av_q2d</span><span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">)</span> <span class="o">-</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">start_time</span> <span class="o">!=</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">?</span> <span class="nl">start_time</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span> <span class="o">&lt;=</span>
</span></span><span class="line"><span class="cl">                                <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">duration</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将解复用得到的数据包添加到对应的待解码队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span> <span class="o">&amp;&amp;</span> <span class="n">pkt_in_play_range</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">packet_queue_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span> <span class="o">&amp;&amp;</span> <span class="n">pkt_in_play_range</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span><span class="o">-&gt;</span><span class="n">disposition</span> <span class="o">&amp;</span> <span class="n">AV_DISPOSITION_ATTACHED_PIC</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">packet_queue_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_stream</span> <span class="o">&amp;&amp;</span> <span class="n">pkt_in_play_range</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">packet_queue_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_packet_unref</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><h6 id="暂停恢复处理">暂停/恢复处理：<a hidden class="anchor" aria-hidden="true" href="#暂停恢复处理">#</a></h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span> <span class="o">!=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">last_paused</span><span class="p">)</span> <span class="p">{</span><span class="c1">//如果paused变量改变，说明暂停状态改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">is</span><span class="o">-&gt;</span><span class="n">last_paused</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span><span class="p">)</span><span class="c1">//如果暂停调用av_read_pause
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">is</span><span class="o">-&gt;</span><span class="n">read_pause_return</span> <span class="o">=</span> <span class="nf">av_read_pause</span><span class="p">(</span><span class="n">ic</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="c1">//如果恢复播放调用av_read_play
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">av_read_play</span><span class="p">(</span><span class="n">ic</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ffmpeg有专门针对暂停和恢复的函数，所以直接调用就可以了。</p>
<h6 id="seek的处理">seek的处理：<a hidden class="anchor" aria-hidden="true" href="#seek的处理">#</a></h6>
<p>主要的seek操作通过avformat_seek_file完成。根据avformat_seek_file的返回值，如果seek成功，需要：</p>
<ol>
<li>清除PacketQueue的缓存，并放入一个flush_pkt。放入的flush_pkt可以让PacketQueue的serial增1，以区分seek前后的数据;(在分析PacketQueue会详细说明)</li>
<li>同步外部时钟；（在音视频同步部分会详细说明）</li>
<li>最后清理一些变量，通过<code>step_to_next_frame</code>完成</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> 						<span class="n">ret</span> <span class="o">=</span> <span class="nf">avformat_seek_file</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">ic</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">seek_min</span><span class="p">,</span> <span class="n">seek_target</span><span class="p">,</span> <span class="n">seek_max</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">seek_flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="s">&#34;%s: error while seeking</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//清空缓冲队列，向解码线程传入flush事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_stream</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">              	<span class="c1">//同步外部时钟信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">seek_flags</span> <span class="o">&amp;</span> <span class="n">AVSEEK_FLAG_BYTE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">set_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">extclk</span><span class="p">,</span> <span class="n">NAN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">set_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">extclk</span><span class="p">,</span> <span class="n">seek_target</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">AV_TIME_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">is</span><span class="o">-&gt;</span><span class="n">seek_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">is</span><span class="o">-&gt;</span><span class="n">queue_attachments_req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">is</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">step_to_next_frame</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
</span></span></code></pre></div><h6 id="缓冲区大小判断">缓冲区大小判断：<a hidden class="anchor" aria-hidden="true" href="#缓冲区大小判断">#</a></h6>
<p>缓冲区大小满的情况判断有两种：</p>
<ol>
<li>所有流队列缓冲大小总和大于MAX_QUEUE_SIZE（15M）时；</li>
<li>各种流的队列都已有够用的包；</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* if the queue are full, no need to read more */</span> <span class="c1">//数据队列满的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">infinite_buffer</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">MAX_QUEUE_SIZE</span> <span class="c1">//所有流队列缓冲大小总和大于MAX_QUEUE_SIZE（15M）时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">||</span> <span class="p">(</span><span class="nf">stream_has_enough_packets</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_st</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">)</span> <span class="c1">//各种流都已有够用的包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">&amp;&amp;</span><span class="nf">stream_has_enough_packets</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">            <span class="o">&amp;&amp;</span><span class="nf">stream_has_enough_packets</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_st</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* wait 10 ms */</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_LockMutex</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_CondWaitTimeout</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">continue_read_thread</span><span class="p">,</span> <span class="n">wait_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_UnlockMutex</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span></code></pre></div><p>在看看函数<code>stream_has_enough_packets</code>是如何判断流队列都已有够用的包</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">stream_has_enough_packets</span><span class="p">(</span><span class="n">AVStream</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">,</span> <span class="n">PacketQueue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">stream_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">           <span class="n">queue</span><span class="o">-&gt;</span><span class="n">abort_request</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">           <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">disposition</span> <span class="o">&amp;</span> <span class="n">AV_DISPOSITION_ATTACHED_PIC</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">           <span class="n">queue</span><span class="o">-&gt;</span><span class="n">nb_packets</span> <span class="o">&gt;</span> <span class="n">MIN_FRAMES</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">duration</span> <span class="o">||</span> <span class="nf">av_q2d</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">)</span> <span class="o">*</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">duration</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从函数内部结构可以看出，在满足PacketQueue总时长为0，或总时长超过1s的前提下：</p>
<p>有这么几种情况包是够用的：</p>
<ol>
<li>流没有打开（stream_id &lt; 0）</li>
<li>有退出请求（queue-&gt;abort_request）</li>
<li>配置了AV_DISPOSITION_ATTACHED_PIC，流以附件图片/“封面图片”的形式存储在文件；</li>
<li>队列内包个数大于MIN_FRAMES（=25）</li>
</ol>
<h6 id="在播放完的情况下处理">在播放完的情况下处理：<a hidden class="anchor" aria-hidden="true" href="#在播放完的情况下处理">#</a></h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_st</span> <span class="o">||</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">auddec</span><span class="p">.</span><span class="n">finished</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">.</span><span class="n">serial</span> 
</span></span><span class="line"><span class="cl">                               <span class="o">&amp;&amp;</span> <span class="nf">frame_queue_nb_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">sampq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">        											<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span> <span class="o">||</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">viddec</span><span class="p">.</span><span class="n">finished</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">.</span><span class="n">serial</span> 
</span></span><span class="line"><span class="cl">                             <span class="o">&amp;&amp;</span> <span class="nf">frame_queue_nb_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">loop</span> <span class="o">||</span> <span class="o">--</span><span class="n">loop</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">stream_seek</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">start_time</span> <span class="o">!=</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">?</span> <span class="nl">start_time</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">autoexit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ret</span> <span class="o">=</span> <span class="n">AVERROR_EOF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span></code></pre></div><p>判断播放已完成的条件，需要满足：</p>
<ol>
<li>不在暂停状态</li>
<li>音频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了</li>
<li>视频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了</li>
</ol>
<p>在确认已结束的情况下，用户有两个变量可以控制播放器行为：</p>
<ol>
<li>loop: 控制播放次数（当前这次也算在内，也就是最小就是1次了），0表示无限次</li>
<li>autoexit：自动退出，也就是播放完成后自动退出。</li>
</ol>
<h6 id="读解复用处理">读（解复用）处理：<a hidden class="anchor" aria-hidden="true" href="#读解复用处理">#</a></h6>
<p>解复用处理的步骤如下：</p>
<ol>
<li>通过<code>av_read_frame</code>读取一个包（<code>AVPacket</code>）</li>
<li>返回值处理，一些出错处理过程</li>
<li><code>pkt_ts</code>重计算过程</li>
<li><code>packet_queue_put</code>放入各自队列，或者丢弃</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="n">ret</span> <span class="o">=</span> <span class="nf">av_read_frame</span><span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span> <span class="c1">//将数据读取出，送入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="c1">//文件读取完了，调用packet_queue_put_nullpacket通知解码线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">==</span> <span class="n">AVERROR_EOF</span> <span class="o">||</span> <span class="nf">avio_feof</span><span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">pb</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_put_nullpacket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_put_nullpacket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_stream</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">packet_queue_put_nullpacket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">is</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//发生错误了，退出主循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">pb</span> <span class="o">&amp;&amp;</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">pb</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">autoexit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*读取失败的话，读取失败的原因有很多，其他地方可能会重新Signal这个锁condition。
</span></span></span><span class="line"><span class="cl"><span class="cm">            如果没有singal这个condition的话，就会等待10ms之后，
</span></span></span><span class="line"><span class="cl"><span class="cm">            再释放，重新循环读取. 那这个continue_read_thread 到底是锁了哪呢？*/</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_LockMutex</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_CondWaitTimeout</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">continue_read_thread</span><span class="p">,</span> <span class="n">wait_mutex</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">SDL_UnlockMutex</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">is</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* check if packet is in play range specified by user, then queue, otherwise discard */</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//记录stream_start_time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stream_start_time</span> <span class="o">=</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果没有pts, 就用dts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pkt_ts</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">==</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">?</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="nl">dts</span> <span class="p">:</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">pts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*判断是否在范围内。如果duration还没被定义的话，通过
</span></span></span><span class="line"><span class="cl"><span class="cm">        或者在定义的duration内才可以，用当前的pts-start_time .
</span></span></span><span class="line"><span class="cl"><span class="cm">        duration 会在解码器打开之后，才会被初始化*/</span>
</span></span><span class="line"><span class="cl">        <span class="n">pkt_in_play_range</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">==</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                            <span class="p">(</span><span class="n">pkt_ts</span> <span class="o">-</span> <span class="p">(</span><span class="n">stream_start_time</span> <span class="o">!=</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">?</span> <span class="nl">stream_start_time</span> <span class="p">:</span> <span class="mi">0</span><span class="p">))</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">                                        <span class="nf">av_q2d</span><span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">)</span> <span class="o">-</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">start_time</span> <span class="o">!=</span> <span class="n">AV_NOPTS_VALUE</span> <span class="o">?</span> <span class="nl">start_time</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span> <span class="o">&lt;=</span>
</span></span><span class="line"><span class="cl">                                <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">duration</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将解复用得到的数据包添加到对应的待解码队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span> <span class="o">&amp;&amp;</span> <span class="n">pkt_in_play_range</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">packet_queue_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_stream</span> 
</span></span><span class="line"><span class="cl">                 <span class="o">&amp;&amp;</span> <span class="n">pkt_in_play_range</span> 
</span></span><span class="line"><span class="cl">                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span><span class="o">-&gt;</span><span class="n">disposition</span> 
</span></span><span class="line"><span class="cl">                      <span class="o">&amp;</span> <span class="n">AV_DISPOSITION_ATTACHED_PIC</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">packet_queue_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitle_stream</span> <span class="o">&amp;&amp;</span> <span class="n">pkt_in_play_range</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">packet_queue_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">subtitleq</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_packet_unref</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span></code></pre></div><h4 id="视频解码线程video_thread">视频解码线程(video_thread)<a hidden class="anchor" aria-hidden="true" href="#视频解码线程video_thread">#</a></h4>
<p>在read_thread中已经创建了对应需要的解码器(<code>AVCodec</code>)；而在video_thread中需要创建<code>AVFrame</code>,来接收解码后的数据；确定视频帧率，开启循环解码；</p>
<h5 id="参数初始化">参数初始化<a hidden class="anchor" aria-hidden="true" href="#参数初始化">#</a></h5>
<p>创建AVFrame和得到大致的视频帧率</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="n">VideoState</span> <span class="o">*</span><span class="n">is</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nf">av_frame_alloc</span><span class="p">();</span> <span class="c1">//创建AVFrame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">pts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">duration</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">AVRational</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//猜测视频帧率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVRational</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">av_guess_frame_rate</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">ic</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
</span></span></code></pre></div><h5 id="循环解码">循环解码<a hidden class="anchor" aria-hidden="true" href="#循环解码">#</a></h5>
<p>循环解码的总流：</p>
<ol>
<li><code>get_video_frame</code>获取解码后的一帧图像</li>
<li>“计算”时长和pts</li>
<li>调用<code>queue_picture</code>将一帧图像放入FrameQueue</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="k">for</span> <span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="nf">get_video_frame</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">the_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//获取当前帧播放时长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_rate</span><span class="p">.</span><span class="n">num</span> <span class="o">&amp;&amp;</span> 
</span></span><span class="line"><span class="cl">                        <span class="n">frame_rate</span><span class="p">.</span><span class="n">den</span> <span class="o">?</span> 
</span></span><span class="line"><span class="cl">                        <span class="nf">av_q2d</span><span class="p">((</span><span class="n">AVRational</span><span class="p">){</span><span class="n">frame_rate</span><span class="p">.</span><span class="n">den</span><span class="p">,</span> <span class="n">frame_rate</span><span class="p">.</span><span class="n">num</span><span class="p">})</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//当前帧显示时间戳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">pts</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">==</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">)</span> <span class="o">?</span> <span class="nl">NAN</span> <span class="p">:</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">*</span> <span class="nf">av_q2d</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将当前帧压入frame_queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ret</span> <span class="o">=</span> <span class="nf">queue_picture</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pkt_pos</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">viddec</span><span class="p">.</span><span class="n">pkt_serial</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_frame_unref</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span> <span class="c1">//释放frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">the_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><h6 id="get_video_frame"><code>get_video_frame</code><a hidden class="anchor" aria-hidden="true" href="#get_video_frame">#</a></h6>
<p>​		调用<code>decoder_decode_frame</code>解码,获取成功后主要做丢帧处理，丢帧的主要条件是<code>diff - is-&gt;frame_last_filter_delay &lt; 0</code>，<code>frame_last_filter_delay</code>与滤镜有关，可以先忽略，也就是<code>diff &lt; 0</code>的时候丢帧——<code>pts &lt; get_master_clock(is)</code>的时候丢帧。<code>decoder_decode_frame</code>真正解码函数；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">get_video_frame</span><span class="p">(</span><span class="n">VideoState</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">got_picture</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">got_picture</span> <span class="o">=</span> <span class="nf">decoder_decode_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">viddec</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">got_picture</span><span class="p">)</span><span class="c1">//解码是否成功，主要做丢帧处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">double</span> <span class="n">dpts</span> <span class="o">=</span> <span class="n">NAN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">!=</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">)</span><span class="c1">//通过 pts*av_q2d(timebase)可以得到准确的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">dpts</span> <span class="o">=</span> <span class="nf">av_q2d</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">)</span> <span class="o">*</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">//重新得到视频的比例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">sample_aspect_ratio</span> <span class="o">=</span> <span class="nf">av_guess_sample_aspect_ratio</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">ic</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">framedrop</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">framedrop</span> <span class="o">&amp;&amp;</span> <span class="nf">get_master_sync_type</span><span class="p">(</span><span class="n">is</span><span class="p">)</span> <span class="o">!=</span> <span class="n">AV_SYNC_VIDEO_MASTER</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">!=</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//得到的是当前的时间和时间钟之间的差值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kt">double</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">dpts</span> <span class="o">-</span> <span class="nf">get_master_clock</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">isnan</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">fabs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">AV_NOSYNC_THRESHOLD</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">diff</span> <span class="o">-</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_last_filter_delay</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">is</span><span class="o">-&gt;</span><span class="n">viddec</span><span class="p">.</span><span class="n">pkt_serial</span> <span class="o">==</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">vidclk</span><span class="p">.</span><span class="n">serial</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">.</span><span class="n">nb_packets</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_drops_early</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">av_frame_unref</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">got_picture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">got_picture</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h6 id="decoder_decode_frame"><code>decoder_decode_frame</code><a hidden class="anchor" aria-hidden="true" href="#decoder_decode_frame">#</a></h6>
<p><code>decoder_decode_frame</code>的主干代码是一个循环，要拿到一帧解码数据，或解码出错、文件结束，才会返回。</p>
<p>循环总共3个步骤：</p>
<ol>
<li>流连续的情况下，不断调用avcodec_receive_frame获取解码后的frame</li>
<li>取一个packet，顺带过滤“过时”的packet</li>
<li>将packet送入解码器</li>
</ol>
<p>有一个<code>packet_pending</code>的概念，用于在send失败时重新发送；当收到flush_pkt时进行相应的flush事件处理，PacketQueue发生改变时第一个pkt将是flush_pkt，根据ffmpeg的API要求，需要调用<code>avcodec_flush_buffers</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">decoder_decode_frame</span><span class="p">(</span><span class="n">Decoder</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="n">AVSubtitle</span> <span class="o">*</span><span class="n">sub</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">AVPacket</span> <span class="n">pkt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//1. 流连续的情况下，不断调用avcodec_receive_frame获取解码后的frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">pkt_serial</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">do</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">abort_request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">switch</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="nl">AVMEDIA_TYPE_VIDEO</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ret</span> <span class="o">=</span> <span class="nf">avcodec_receive_frame</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">avctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">decoder_reorder_pts</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">best_effort_timestamp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">decoder_reorder_pts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pkt_dts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">AVERROR_EOF</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">d</span><span class="o">-&gt;</span><span class="n">finished</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">pkt_serial</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">avcodec_flush_buffers</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">avctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="c1">//2. 取一个packet，顺带过滤“过时”的packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">do</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 队列为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">nb_packets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">SDL_CondSignal</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">empty_queue_cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//如果有待重发的pkt，则先取待重发的pkt，否则从队列中取一个pkt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">packet_pending</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">av_packet_move_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">d</span><span class="o">-&gt;</span><span class="n">packet_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//取出下一帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="nf">packet_queue_get</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">pkt_serial</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//队列的序列不相同时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">pkt_serial</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_packet_unref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="c1">//针对flush_pkt的处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">flush_pkt</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">avcodec_flush_buffers</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">avctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">d</span><span class="o">-&gt;</span><span class="n">finished</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">d</span><span class="o">-&gt;</span><span class="n">next_pts</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">start_pts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">d</span><span class="o">-&gt;</span><span class="n">next_pts_tb</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">start_pts_tb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//3. 将packet送入解码器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="nf">avcodec_send_packet</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">avctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">)</span> <span class="o">==</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">av_log</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span> <span class="s">&#34;Receive_frame and send_packet both returned EAGAIN, which is an API violation.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">d</span><span class="o">-&gt;</span><span class="n">packet_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">av_packet_move_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">            <span class="nf">av_packet_unref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h6 id="queue_picture"><code>queue_picture</code><a hidden class="anchor" aria-hidden="true" href="#queue_picture">#</a></h6>
<p><code>queue_picture</code>主要用于把<code>get_video_frame</code>函数取到正确解码后的一帧数据放入FrameQueue；</p>
<ol>
<li><code>frame_queue_peek_writable</code>取FrameQueue的当前写节点；</li>
<li>把该解码后的帧数据拷贝给节点(struct Frame)保存</li>
<li><code>frame_queue_push</code>，“push”节点到队列中</li>
</ol>
<p>AVFrame的拷贝是通过<code>av_frame_move_ref</code>实现的，所以拷贝后<code>src_frame</code>就是无效的；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_picture</span><span class="p">(</span><span class="n">VideoState</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">src_frame</span><span class="p">,</span> <span class="kt">double</span> <span class="n">pts</span><span class="p">,</span> <span class="kt">double</span> <span class="n">duration</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">serial</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Frame</span> <span class="o">*</span><span class="n">vp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(DEBUG_SYNC)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;frame_type=%c pts=%0.3f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="nf">av_get_picture_type_char</span><span class="p">(</span><span class="n">src_frame</span><span class="o">-&gt;</span><span class="n">pict_type</span><span class="p">),</span> <span class="n">pts</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vp</span> <span class="o">=</span> <span class="nf">frame_queue_peek_writable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">)))</span> <span class="c1">//判断是否有空间可以写入，并取FrameQueue的当前写节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">sar</span> <span class="o">=</span> <span class="n">src_frame</span><span class="o">-&gt;</span><span class="n">sample_aspect_ratio</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">uploaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">src_frame</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">src_frame</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">format</span> <span class="o">=</span> <span class="n">src_frame</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">=</span> <span class="n">serial</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//修改窗口大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">set_default_window_size</span><span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">sar</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">av_frame_move_ref</span><span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">,</span> <span class="n">src_frame</span><span class="p">);</span> <span class="c1">//将src_frame的内存空间指向vp-&gt;frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">frame_queue_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">);</span>            <span class="c1">//重新推入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="ffplay-audio输出的线程分析">ffplay audio输出的线程分析<a hidden class="anchor" aria-hidden="true" href="#ffplay-audio输出的线程分析">#</a></h3>
<p>ffplay audio的解码过程与video的一样，都在<code>decoder_decode_frame</code>函数中执行，在 video已经进行分析，这里就不做单独分析了，主要分析audio的输出；ffplay的audio输出同样也是通过SDL实现的;audio输出相关内容，且尽量不涉及音视频同步知识，音视频同步将专门一个章节分析。</p>
<p>audio的输出在SDL下是被动输出，即在开启SDL会在需要输出时，回调通知，在回调函数中，SDL会告知要发送多少的数据。</p>
<p>sdl通过sdl_audio_callback函数向ffplay要音频数据，ffplay将sampq中的数据通过<code>audio_decode_frame</code>函数取出，放入<code>is-&gt;audio_buf</code>，然后送出给sdl。在后续回调时先找<code>audio_buf</code>要数据，数据不足的情况下，再调用<code>audio_decode_frame</code>补充<code>audio_buf</code></p>
<h4 id="sdl打开音频输出">sdl打开音频输出<a hidden class="anchor" aria-hidden="true" href="#sdl打开音频输出">#</a></h4>
<p>在<code>stream_component_open</code>中的audio分支进行调用<code>audio_open</code>打开sdl音频输出；代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">case</span> <span class="nl">AVMEDIA_TYPE_AUDIO</span><span class="p">:</span> <span class="c1">//音频相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#if CONFIG_AVFILTER          </span><span class="c1">//过滤器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">AVFilterContext</span> <span class="o">*</span><span class="n">sink</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//从avctx(即AVCodecContext)中获取音频格式参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_filter_src</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_filter_src</span><span class="p">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_filter_src</span><span class="p">.</span><span class="n">channel_layout</span> <span class="o">=</span> <span class="nf">get_valid_channel_layout</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">channel_layout</span><span class="p">,</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_filter_src</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">sample_fmt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="nf">configure_audio_filters</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">afilters</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">sink</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">out_audio_filter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">sample_rate</span> <span class="o">=</span> <span class="nf">av_buffersink_get_sample_rate</span><span class="p">(</span><span class="n">sink</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">nb_channels</span> <span class="o">=</span> <span class="nf">av_buffersink_get_channels</span><span class="p">(</span><span class="n">sink</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel_layout</span> <span class="o">=</span> <span class="nf">av_buffersink_get_channel_layout</span><span class="p">(</span><span class="n">sink</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="n">sample_rate</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">nb_channels</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel_layout</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">channel_layout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* prepare audio output */</span> <span class="c1">//打开音频输出通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="cm">/*调用audio_open打开sdl音频输出，实际打开的设备参数保存在audio_tgt，返回值表示输出设备的缓冲区大小*/</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="nf">audio_open</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">channel_layout</span><span class="p">,</span> <span class="n">nb_channels</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_hw_buf_size</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_src</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//初始化audio_buf相关参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* init averaging filter */</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_diff_avg_coef</span> <span class="o">=</span> <span class="nf">exp</span><span class="p">(</span><span class="nf">log</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span> <span class="o">/</span> <span class="n">AUDIO_DIFF_AVG_NB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_diff_avg_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* since we do not have a precise anough audio FIFO fullness,
</span></span></span><span class="line"><span class="cl"><span class="cm">           we correct audio sync only if larger than this threshold */</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_diff_threshold</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_hw_buf_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">bytes_per_sec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_stream</span> <span class="o">=</span> <span class="n">stream_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_st</span> <span class="o">=</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">stream_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">decoder_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">auddec</span><span class="p">,</span> <span class="n">avctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">continue_read_thread</span><span class="p">);</span> <span class="c1">//初始化对应的解码线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">((</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">iformat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AVFMT_NOBINSEARCH</span> <span class="o">|</span> <span class="n">AVFMT_NOGENSEARCH</span> <span class="o">|</span> <span class="n">AVFMT_NO_BYTE_SEEK</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">iformat</span><span class="o">-&gt;</span><span class="n">read_seek</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">is</span><span class="o">-&gt;</span><span class="n">auddec</span><span class="p">.</span><span class="n">start_pts</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_st</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">is</span><span class="o">-&gt;</span><span class="n">auddec</span><span class="p">.</span><span class="n">start_pts_tb</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_st</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="nf">decoder_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">auddec</span><span class="p">,</span> <span class="n">audio_thread</span><span class="p">,</span> <span class="s">&#34;audio_decoder&#34;</span><span class="p">,</span> <span class="n">is</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 正式开启解码线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">SDL_PauseAudioDevice</span><span class="p">(</span><span class="n">audio_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span></code></pre></div><p>由于不同的音频输出设备支持的参数不同，音轨的参数不一定能被输出设备支持（此时就需要重采样了），<code>audio_tgt</code>就保存了输出设备参数。</p>
<p>介绍下audio_buf相关的几个变量：</p>
<ul>
<li>audio_buf: 从要输出的AVFrame中取出的音频数据（PCM），如果有必要，则对该数据重采样。</li>
<li>audio_buf_size: audio_buf的总大小</li>
<li>audio_buf_index: 下一次可读的audio_buf的index位置。</li>
<li>audio_write_buf_size：audio_buf已经输出的大小，即audio_buf_size - audio_buf_index</li>
</ul>
<h4 id="音频输出逻辑">音频输出逻辑<a hidden class="anchor" aria-hidden="true" href="#音频输出逻辑">#</a></h4>
<p>在<code>audio_open</code>函数内，通过通过<code>SDL_OpenAudioDevice</code>注册<code>sdl_audio_callback</code>函数为音频输出的回调函数。那么，主要的音频输出的逻辑就在<code>sdl_audio_callback</code>函数内了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* prepare a new audio buffer */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">sdl_audio_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">,</span> <span class="n">Uint8</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">VideoState</span> <span class="o">*</span><span class="n">is</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">audio_size</span><span class="p">,</span> <span class="n">len1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">audio_callback_time</span> <span class="o">=</span> <span class="nf">av_gettime_relative</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="c1">//循环发送，直到发够所需数据长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="c1">//如果audio_buf消耗完了，就调用audio_decode_frame重新填充audio_buf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_index</span> <span class="o">&gt;=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">audio_size</span> <span class="o">=</span> <span class="nf">audio_decode_frame</span><span class="p">(</span><span class="n">is</span><span class="p">);</span><span class="c1">//填充audio_buf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">audio_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* if error, just output silence */</span>
</span></span><span class="line"><span class="cl">                <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_size</span> <span class="o">=</span> <span class="n">SDL_AUDIO_MIN_BUFFER_SIZE</span> <span class="o">/</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">frame_size</span> <span class="o">*</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">frame_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">show_mode</span> <span class="o">!=</span> <span class="n">SHOW_MODE_VIDEO</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">update_sample_display</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="p">(</span><span class="kt">int16_t</span> <span class="o">*</span><span class="p">)</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf</span><span class="p">,</span> <span class="n">audio_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_size</span> <span class="o">=</span> <span class="n">audio_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">       	<span class="c1">//根据缓冲区剩余大小量力而行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">len1</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_size</span> <span class="o">-</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">len1</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">len1</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      	<span class="c1">//根据audio_volume决定如何输出audio_buf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">muted</span> <span class="o">&amp;&amp;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf</span> <span class="o">&amp;&amp;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_volume</span> <span class="o">==</span> <span class="n">SDL_MIX_MAXVOLUME</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">memcpy</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf</span> <span class="o">+</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_index</span><span class="p">,</span> <span class="n">len1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">memset</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">muted</span> <span class="o">&amp;&amp;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">SDL_MixAudioFormat</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf</span> <span class="o">+</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_index</span><span class="p">,</span> <span class="n">AUDIO_S16SYS</span><span class="p">,</span> <span class="n">len1</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_volume</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">       	<span class="c1">//调整各buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">len</span> <span class="o">-=</span> <span class="n">len1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">stream</span> <span class="o">+=</span> <span class="n">len1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_index</span> <span class="o">+=</span> <span class="n">len1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_write_buf_size</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_size</span> <span class="o">-</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Let&#39;s assume the audio driver that is used by SDL has two periods. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">isnan</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock</span><span class="p">))</span><span class="c1">//更新audclk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">set_clock_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audclk</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock</span> <span class="o">-</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_hw_buf_size</span> <span class="o">+</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_write_buf_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">bytes_per_sec</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock_serial</span><span class="p">,</span> <span class="n">audio_callback_time</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sync_clock_to_slave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">extclk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audclk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>sdl_audio_callback</code>的缓冲区输出过程:</p>
<ol>
<li>输出audio_buf到stream，如果audio_volume为最大音量，则只需memcpy复制给stream即可。否则，可以利用SDL_MixAudioFormat进行音量调整和混音</li>
<li>如果audio_buf消耗完了，就调用<code>audio_decode_frame</code>重新填充audio_buf</li>
<li>set_clock_at更新audclk时，完整的帧包含的时间戳-实际写入的帧数+2个硬件buffer的延迟，audio_clock是当前audio_buf的显示结束时间(pts+duration)，由于audio driver本身会持有一小块缓冲区，典型地，会是两块交替使用，所以有<code>2 * is-&gt;audio_hw_buf_size</code>. 因为我们的写入的时候，还需要考虑传入的buffer的大小，预期情况下，如果buffer相同，则这里就是原来的pts-硬件延迟的时间。</li>
</ol>
<h4 id="填充audio_buf">填充audio_buf<a hidden class="anchor" aria-hidden="true" href="#填充audio_buf">#</a></h4>
<p>调用<code>audio_decode_frame</code>重新填充audio_buf，<code>audio_decode_frame</code>并没有真正意义上的<code>decode</code>代码，最多是进行了重采样。主流程有以下步骤：</p>
<ol>
<li>从sampq取一帧，必要时丢帧。如发生了seek，此时serial会不连续，就需要丢帧处理</li>
<li>计算这一帧的字节数。通过av_samples_get_buffer_size可以方便计算出结果</li>
<li>获取这一帧的数据。对于frame格式和输出设备不同的，需要重采样；如果格式相同，则直接拷贝指针输出即可。总之，需要在audio_buf中保存与输出设备格式相同的音频数据</li>
<li>更新audio_clock，audio_clock_serial。用于设置audclk.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Decode one audio frame and return its uncompressed size.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The processed audio frame is decoded, converted if required, and
</span></span></span><span class="line"><span class="cl"><span class="cm"> * stored in is-&gt;audio_buf, with size in bytes given by the return
</span></span></span><span class="line"><span class="cl"><span class="cm"> * value.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">audio_decode_frame</span><span class="p">(</span><span class="n">VideoState</span> <span class="o">*</span><span class="n">is</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">resampled_data_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">dec_channel_layout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">av_unused</span> <span class="kt">double</span> <span class="n">audio_clock0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">wanted_nb_samples</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Frame</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span><span class="p">)</span><span class="c1">//暂停状态，返回-1，sdl_audio_callback会处理为输出静音
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined(_WIN32)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="k">while</span> <span class="p">(</span><span class="nf">frame_queue_nb_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">sampq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">((</span><span class="nf">av_gettime_relative</span><span class="p">()</span> <span class="o">-</span> <span class="n">audio_callback_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000000LL</span> <span class="o">*</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_hw_buf_size</span> <span class="o">/</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">bytes_per_sec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_usleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">af</span> <span class="o">=</span> <span class="nf">frame_queue_peek_readable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">sampq</span><span class="p">)))</span><span class="c1">//1. 从sampq取一帧，必要时丢帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">frame_queue_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">sampq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">!=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audioq</span><span class="p">.</span><span class="n">serial</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2. 计算这一帧的字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">data_size</span> <span class="o">=</span> <span class="nf">av_samples_get_buffer_size</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_samples</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//[]计算dec_channel_layout，用于确认是否需要重新初始化重采样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dec_channel_layout</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">channel_layout</span> <span class="o">&amp;&amp;</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">==</span> <span class="nf">av_get_channel_layout_nb_channels</span><span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">channel_layout</span><span class="p">))</span> <span class="o">?</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="nl">channel_layout</span> <span class="p">:</span> <span class="nf">av_get_default_channel_layout</span><span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">wanted_nb_samples</span> <span class="o">=</span> <span class="nf">synchronize_audio</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_samples</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="c1">//[]判断是否需要重新初始化重采样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">format</span> <span class="o">!=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_src</span><span class="p">.</span><span class="n">fmt</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="n">dec_channel_layout</span> <span class="o">!=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_src</span><span class="p">.</span><span class="n">channel_layout</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">sample_rate</span> <span class="o">!=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_src</span><span class="p">.</span><span class="n">freq</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">wanted_nb_samples</span> <span class="o">!=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_samples</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">swr_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//创建和设置swr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span> <span class="o">=</span> <span class="nf">swr_alloc_set_opts</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">channel_layout</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">fmt</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">freq</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="n">dec_channel_layout</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span> <span class="o">||</span> <span class="nf">swr_init</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="s">&#34;Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">,</span> <span class="nf">av_get_sample_fmt_name</span><span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">),</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">freq</span><span class="p">,</span> <span class="nf">av_get_sample_fmt_name</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">fmt</span><span class="p">),</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">channels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">swr_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_src</span><span class="p">.</span><span class="n">channel_layout</span> <span class="o">=</span> <span class="n">dec_channel_layout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_src</span><span class="p">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_src</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_src</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//3. 获取这一帧的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span><span class="p">)</span><span class="c1">//[]如果初始化了重采样，则对这一帧数据重采样输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="p">)</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">extended_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">out</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">out_count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">wanted_nb_samples</span> <span class="o">*</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">freq</span> <span class="o">/</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">sample_rate</span> <span class="o">+</span> <span class="mi">256</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">out_size</span> <span class="o">=</span> <span class="nf">av_samples_get_buffer_size</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">out_count</span><span class="p">,</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">fmt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">len2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">out_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span> <span class="s">&#34;av_samples_get_buffer_size() failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">wanted_nb_samples</span> <span class="o">!=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_samples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">swr_set_compensation</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span><span class="p">,</span> <span class="p">(</span><span class="n">wanted_nb_samples</span> <span class="o">-</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_samples</span><span class="p">)</span> <span class="o">*</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">freq</span> <span class="o">/</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">wanted_nb_samples</span> <span class="o">*</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">freq</span> <span class="o">/</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span> <span class="s">&#34;swr_set_compensation() failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_fast_malloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf1_size</span><span class="p">,</span> <span class="n">out_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//进行转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">len2</span> <span class="o">=</span> <span class="nf">swr_convert</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">out_count</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_samples</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">len2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span> <span class="s">&#34;swr_convert() failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">len2</span> <span class="o">==</span> <span class="n">out_count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_WARNING</span><span class="p">,</span> <span class="s">&#34;audio buffer is probably too small</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">swr_init</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">swr_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">swr_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//重新计算采样的数据大小，并返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">resampled_data_size</span> <span class="o">=</span> <span class="n">len2</span> <span class="o">*</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">channels</span> <span class="o">*</span> <span class="nf">av_get_bytes_per_sample</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_tgt</span><span class="p">.</span><span class="n">fmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_buf</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">resampled_data_size</span> <span class="o">=</span> <span class="n">data_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//audio_clock0用于打印调试信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">audio_clock0</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* update the audio clock with the pts */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//4. 更新audio_clock，audio_clock_serial,更新pts  这个pts 等于当前的帧包含的所有帧数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">isnan</span><span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">pts</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_samples</span> <span class="o">/</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock</span> <span class="o">=</span> <span class="n">NAN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock_serial</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef DEBUG
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="kt">double</span> <span class="n">last_clock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;audio: delay=%0.3f clock=%0.3f clock0=%0.3f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock</span> <span class="o">-</span> <span class="n">last_clock</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock</span><span class="p">,</span> <span class="n">audio_clock0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">last_clock</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">audio_clock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">return</span> <span class="n">resampled_data_size</span><span class="p">;</span><span class="c1">//返回audio_buf的数据大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="ffplay时间同步">ffplay时间同步<a hidden class="anchor" aria-hidden="true" href="#ffplay时间同步">#</a></h3>
<p>由于音频和视频的输出不在同一个线程，而且，也不一定会同时解出同一个pts的音频帧和视频帧。因此，在进行音频和视频的播放时，需要对音频和视频的播放速度、播放时刻进行控制，以实现音频和视频保持同步，即所谓的音视频同步。</p>
<p>在ffplay中，音频（audio）和视频（video）有各自的输出线程，其中音频的输出线程是sdl的音频输出回调线程，video的输出线程是程序的主线程。</p>
<p>音视频的同步策略，一般有如下几种：</p>
<ul>
<li>视频同步到音频，即音频为主时钟</li>
<li>音频同步到视频，即视频为主时钟</li>
<li>视频、音频同步到外部时钟，即外部时钟（系统时间）为主时钟</li>
<li>视频和音频各自输出，即不作同步处理，或称之为各自为主时钟</li>
</ul>
<p>由于人耳对于声音变化的敏感度比视觉高，因此，一般采样的策略是将视频同步到音频，即对画面进行适当的丢帧或重复以追赶或等待音频。</p>
<h4 id="dts和pts">DTS和PTS<a hidden class="anchor" aria-hidden="true" href="#dts和pts">#</a></h4>
<p>在音视频流中的包都含有<strong>DTS</strong>和<strong>PTS</strong>，我们以此作为选择基准，到底是播放快了还是慢了，或者正以同步的速度播放。</p>
<ul>
<li>DTS：Decoding Time Stamp 解码时间戳——告诉解码器packet解码顺序</li>
<li>PTS：Presenting Time Stamp 显示时间戳——指示从packet中解码出来的数据的显示顺序</li>
</ul>
<h4 id="计算视频frame的显示时间">计算视频Frame的显示时间<a hidden class="anchor" aria-hidden="true" href="#计算视频frame的显示时间">#</a></h4>
<p>要想知道ffmpeg如果计算视频一帧的显示时间，就需先了解ffmpeg的timebase；因为pts的单位就是timebase；</p>
<p>timebase的类型是结构体AVRational（用于表示分数），如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">AVRational</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span> <span class="c1">///&lt; Numerator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">den</span><span class="p">;</span> <span class="c1">///&lt; Denominator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">AVRational</span><span class="p">;</span>
</span></span></code></pre></div><p>如<code>timebase={1, 1000}</code>表示千分之一秒，那么pts=1000，即为1秒，那么这一帧就需要在第一秒的时候呈现在ffplay中，将pts转化为秒，一般做法是：<code>pts * av_q2d(timebase)</code></p>
<p>&ldquo;时钟&quot;的概念，ffplay定义的结构体是Clock：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Clock</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">pts</span><span class="p">;</span>       <span class="cm">/* clock base */</span><span class="c1">// 时钟基准
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">pts_drift</span><span class="p">;</span> <span class="cm">/* clock base minus time at which we updated the clock */</span><span class="c1">// 更新时钟的差值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">last_updated</span><span class="p">;</span><span class="c1">// 上一次更新的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">speed</span><span class="p">;</span><span class="c1">// 速度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">serial</span><span class="p">;</span>  <span class="c1">// 时钟基于使用该序列的包 /* clock is based on a packet with this serial */
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">paused</span><span class="p">;</span><span class="c1">// 停止标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">queue_serial</span><span class="p">;</span> <span class="c1">// 指向当前数据包队列序列的指针，用于过时的时钟检测 /* pointer to the current packet queue serial, used for obsolete clock detection */
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">Clock</span><span class="p">;</span>
</span></span></code></pre></div><p>时钟的工作原理：</p>
<ol>
<li>通过<code>set_clock_at</code>不断对时；</li>
<li>获取的时间是一个估算值。估算是通过对时时记录的pts_drift估算的</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 更新视频的pts
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param is     [description]
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pts    [description]
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pos    [description]
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param serial [description]
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="k">void</span> <span class="nx">update_video_pts</span><span class="p">(</span><span class="nx">VideoState</span> <span class="o">*</span><span class="nx">is</span><span class="p">,</span> <span class="kr">double</span> <span class="nx">pts</span><span class="p">,</span> <span class="nx">int64_t</span> <span class="nx">pos</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">serial</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* update current video pts */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">set_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">is</span><span class="o">-&gt;</span><span class="nx">vidclk</span><span class="p">,</span> <span class="nx">pts</span><span class="p">,</span> <span class="nx">serial</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//将尾部的时间钟，用视频的时机钟来进行同步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sync_clock_to_slave</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">is</span><span class="o">-&gt;</span><span class="nx">extclk</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">is</span><span class="o">-&gt;</span><span class="nx">vidclk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="k">void</span> <span class="nx">set_clock</span><span class="p">(</span><span class="nx">Clock</span> <span class="o">*</span><span class="nx">c</span><span class="p">,</span> <span class="kr">double</span> <span class="nx">pts</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">serial</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">double</span> <span class="nx">time</span> <span class="o">=</span> <span class="nx">av_gettime_relative</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">set_clock_at</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">pts</span><span class="p">,</span> <span class="nx">serial</span><span class="p">,</span> <span class="nx">time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//使用当前的事来计算这几个值。也就是这一帧送显之前的操作的时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">static</span> <span class="k">void</span> <span class="nx">set_clock_at</span><span class="p">(</span><span class="nx">Clock</span> <span class="o">*</span><span class="nx">c</span><span class="p">,</span> <span class="kr">double</span> <span class="nx">pts</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">serial</span><span class="p">,</span> <span class="kr">double</span> <span class="nx">time</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="o">-&gt;</span><span class="nx">pts</span> <span class="o">=</span> <span class="nx">pts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="o">-&gt;</span><span class="nx">last_updated</span> <span class="o">=</span> <span class="nx">time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="o">-&gt;</span><span class="nx">pts_drift</span> <span class="o">=</span> <span class="nx">c</span><span class="o">-&gt;</span><span class="nx">pts</span> <span class="o">-</span> <span class="nx">time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="o">-&gt;</span><span class="nx">serial</span> <span class="o">=</span> <span class="nx">serial</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>以一个时间轴，从左往右看。首先我们调用<code>set_clock_at</code>进行一次对时，假设这时的<code>pts</code>是落后系统时间<code>time</code>的，那么计算<code>pts_drift = pts - time</code>。</p>
<p>接着，过了一会儿，且在下次对时前，通过<code>get_clock</code>来查询时间，因为这时的<code>pts</code>已经过时，不能直接拿pts当做这个时钟的时间。不过我们前面计算过<code>pts_drift</code>，也就是<code>pts</code>和<code>time</code>的差值，所以我们可以通过当前时刻的系统时间来估算这个时刻的pts：<code>pts = time + pts_drift</code>.</p>
<p>当然，由于pts_drift是一直在变动的(drift与漂移、抖动的意思)，所以get_clock是估算值，真实的pts可能落在比如图示虚线圆的位置。</p>
<img src="./img/ffplay_clock.png" style="zoom:50%;" />
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">double</span> <span class="nf">get_clock</span><span class="p">(</span><span class="n">Clock</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">queue_serial</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">NAN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">paused</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//pts_drift 是更新的时间钟的差值？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//最后的时间是 更新的差值+ 当前的时间-当前的时间和上一次更新的时间之间的差值*速度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//默认的情况下，根据上一次的drift计算下一次要出现的时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">double</span> <span class="n">time</span> <span class="o">=</span> <span class="nf">av_gettime_relative</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pts_drift</span> <span class="o">+</span> <span class="n">time</span> <span class="o">-</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">last_updated</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="以音频为主时钟同步">以音频为主时钟同步<a hidden class="anchor" aria-hidden="true" href="#以音频为主时钟同步">#</a></h4>
<p>接下来主要讲以音频为主时钟的部分，大致流程如下：</p>
<img src="img/ffplay_video_clock.png" style="zoom:60%;" />
<p>在这个流程中，“计算上一帧显示时长”这一步骤至关重要。代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* called to display each frame */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">video_refresh</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">remaining_time</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">video_st</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nl">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="nf">frame_queue_nb_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">{</span> <span class="c1">//判断队列是否有数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="c1">// nothing to do, no picture to display in the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">else</span>
</span></span><span class="line"><span class="cl">          <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="kt">double</span> <span class="n">last_duration</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">delay</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="n">Frame</span> <span class="o">*</span><span class="n">vp</span><span class="p">,</span> <span class="o">*</span><span class="n">lastvp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="c1">//lastvp上一帧，vp当前帧 ，nextvp下一帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">              <span class="cm">/* dequeue the picture */</span> <span class="c1">//出队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="n">lastvp</span> <span class="o">=</span> <span class="nf">frame_queue_peek_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="n">vp</span> <span class="o">=</span> <span class="nf">frame_queue_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">              1、刚开始的时候（第一帧）lastvp == vp ，因为还没有调用frame_queue_next f-&gt;rindex_shown还未为1
</span></span></span><span class="line"><span class="cl"><span class="cm">              2、调用frame_queue_next，将f-&gt;rindex_shown置1，还没有增加f-&gt;rindex
</span></span></span><span class="line"><span class="cl"><span class="cm">              3、第二帧开始lastvp上一帧，vp 将要显示的一帧
</span></span></span><span class="line"><span class="cl"><span class="cm">              */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             <span class="cm">/*如果将要显示的一帧的序列与现在解码的不同就直接抛弃*/</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">!=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">videoq</span><span class="p">.</span><span class="n">serial</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">{</span> 
</span></span><span class="line"><span class="cl">                  <span class="nf">frame_queue_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">);</span><span class="c1">//移动读索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span><span class="c1">//重新获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              <span class="c1">//如果上一帧序号不等于将要显示的一帧序号，表示将要显示的一帧是新的播放序列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">              新的播放序列重置当前时间，这样就会走到正常显示将要显示的一帧（新序的第一帧）
</span></span></span><span class="line"><span class="cl"><span class="cm">              */</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="n">lastvp</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">!=</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_timer</span> <span class="o">=</span> <span class="nf">av_gettime_relative</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">;</span> <span class="c1">//获取当前时间，用于帧间对比
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span><span class="p">)</span> <span class="c1">//暂停后重新开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="k">goto</span> <span class="n">display</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              <span class="cm">/* compute nominal last_duration */</span>
</span></span><span class="line"><span class="cl">              <span class="n">last_duration</span> <span class="o">=</span> <span class="nf">vp_duration</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">lastvp</span><span class="p">,</span> <span class="n">vp</span><span class="p">);</span><span class="c1">//计算上一帧的持续时长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="n">delay</span> <span class="o">=</span> <span class="nf">compute_target_delay</span><span class="p">(</span><span class="n">last_duration</span><span class="p">,</span> <span class="n">is</span><span class="p">);</span> <span class="c1">//音视频同步信息，参考audio clock计算上一帧真正的持续时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">              <span class="n">time</span> <span class="o">=</span> <span class="nf">av_gettime_relative</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">;</span><span class="c1">//取系统时刻
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="cm">/*delay ： 是上一帧要持续显示的时长，也就是将要显示的一帧的开始显示时间
</span></span></span><span class="line"><span class="cl"><span class="cm">              is-&gt;frame_timer ： 上一帧显示的时间
</span></span></span><span class="line"><span class="cl"><span class="cm">              is-&gt;frame_timer + delay ： 将要显示这一帧的时间
</span></span></span><span class="line"><span class="cl"><span class="cm">              如果time 还没达到显示这一帧的时间，就计算等待时间用于上一层等待，继续显示上一帧
</span></span></span><span class="line"><span class="cl"><span class="cm">              如果seek后，delay = 0 ，time 就会大于is-&gt;frame_timer + delay，就往下走显示
</span></span></span><span class="line"><span class="cl"><span class="cm">              */</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_timer</span> <span class="o">+</span> <span class="n">delay</span><span class="p">)</span><span class="c1">//如果上一帧显示时长未满，重复显示上一帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="p">{</span> <span class="c1">//进入视频显示，计算一个等待时间返回上一层，现在视频快了，让视频继续显示上一帧等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="o">*</span><span class="n">remaining_time</span> <span class="o">=</span> <span class="nf">FFMIN</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_timer</span> <span class="o">+</span> <span class="n">delay</span> <span class="o">-</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                  <span class="k">goto</span> <span class="n">display</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="p">}</span>
</span></span><span class="line"><span class="cl">              <span class="cm">/*第一帧数据时is-&gt;frame_timer = 0，会执行到time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX
</span></span></span><span class="line"><span class="cl"><span class="cm">              如果与系统时间的偏离太大，则修正为系统时间*/</span>
</span></span><span class="line"><span class="cl">              <span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_timer</span> <span class="o">+=</span> <span class="n">delay</span><span class="p">;</span><span class="c1">//frame_timer更新为上一帧结束时刻，也是当前帧开始时刻
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">time</span> <span class="o">-</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_timer</span> <span class="o">&gt;</span> <span class="n">AV_SYNC_THRESHOLD_MAX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_timer</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span><span class="c1">//如果与系统时间的偏离太大，则修正为系统时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">              <span class="nf">SDL_LockMutex</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="cm">/*更新视频时钟
</span></span></span><span class="line"><span class="cl"><span class="cm">              注意：这个更新视频时钟在丢帧之前，那么如果这帧pts设置视频时钟后
</span></span></span><span class="line"><span class="cl"><span class="cm">              下面又将这帧丢弃，视频时钟就是被丢弃的这一帧*/</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">isnan</span><span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">pts</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                  <span class="nf">update_video_pts</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">pts</span><span class="p">,</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span> <span class="c1">//更新视频时钟检测
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="nf">SDL_UnlockMutex</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              <span class="cm">/*drop帧处理
</span></span></span><span class="line"><span class="cl"><span class="cm">              队列要有将要显示这一帧的下一帧
</span></span></span><span class="line"><span class="cl"><span class="cm">              第一帧，队列内有2帧
</span></span></span><span class="line"><span class="cl"><span class="cm">              后面就是，队列内有3帧，因为保留了上一帧（显示帧）*/</span>
</span></span><span class="line"><span class="cl">              <span class="c1">//丢帧逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="k">if</span> <span class="p">(</span><span class="nf">frame_queue_nb_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">Frame</span> <span class="o">*</span><span class="n">nextvp</span> <span class="o">=</span> <span class="nf">frame_queue_peek_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">);</span><span class="c1">//获取将要显示帧的下一帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">duration</span> <span class="o">=</span> <span class="nf">vp_duration</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">vp</span><span class="p">,</span> <span class="n">nextvp</span><span class="p">);</span><span class="c1">//当前帧显示时长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">//如果系统时间已经大于当前帧，则丢弃当前帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">step</span> <span class="c1">//非逐帧模式播放情况下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">framedrop</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="c1">//允许drop帧处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="o">||</span> <span class="p">(</span><span class="n">framedrop</span> <span class="o">&amp;&amp;</span> <span class="nf">get_master_sync_type</span><span class="p">(</span><span class="n">is</span><span class="p">)</span> <span class="o">!=</span> <span class="n">AV_SYNC_VIDEO_MASTER</span><span class="p">))</span> <span class="c1">//主时钟不是视频
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="o">&amp;&amp;</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_timer</span> <span class="o">+</span> <span class="n">duration</span><span class="p">)</span><span class="c1">//当前时间已经到了nextvp的播放时间，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="p">{</span>
</span></span><span class="line"><span class="cl">                      <span class="c1">//此时is-&gt;frame_timer就是将要显示这一帧vp的播放时间了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="n">is</span><span class="o">-&gt;</span><span class="n">frame_drops_late</span><span class="o">++</span><span class="p">;</span><span class="c1">//丢帧统计
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="nf">frame_queue_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">);</span><span class="c1">//丢弃将要显示这一帧，移动读索引读到下一帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span><span class="c1">//回到函数开始位置，继续重试(这里不能直接while丢帧，因为很可能audio clock重新对时了，这样delay值需要重新计算)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">              <span class="p">}</span>
</span></span><span class="line"><span class="cl">              <span class="cm">/*上一帧与将要显示这一帧之间的duration用来计算将要显示这一帧的播放时间
</span></span></span><span class="line"><span class="cl"><span class="cm">              将要显示这一帧与上一帧之间的duration用来计算是否丢弃将要显示这一帧*/</span>
</span></span><span class="line"><span class="cl">            <span class="p">...</span>
</span></span><span class="line"><span class="cl">              <span class="nf">frame_queue_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">              <span class="n">is</span><span class="o">-&gt;</span><span class="n">force_refresh</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//刷新画面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">step</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">paused</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="nf">stream_toggle_pause</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nl">display</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* display picture */</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">display_disable</span> 
</span></span><span class="line"><span class="cl">              <span class="o">&amp;&amp;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">force_refresh</span> 
</span></span><span class="line"><span class="cl">              <span class="o">&amp;&amp;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">show_mode</span> <span class="o">==</span> <span class="n">SHOW_MODE_VIDEO</span> 
</span></span><span class="line"><span class="cl">              <span class="o">&amp;&amp;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">pictq</span><span class="p">.</span><span class="n">rindex_shown</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="nf">video_display</span><span class="p">(</span><span class="n">is</span><span class="p">);</span><span class="c1">//显示视频
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果视频播放过快，则重复播放上一帧，以等待音频；如果视频播放过慢，则丢帧追赶音频。实现的方式是，参考audio clock，计算上一帧（在屏幕上的那个画面）还应显示多久（含帧本身时长），然后与系统时刻对比，是否该显示下一帧了。</p>
<h5 id="frame_timer"><code>frame_timer</code><a hidden class="anchor" aria-hidden="true" href="#frame_timer">#</a></h5>
<p><code>frame_timer</code>:可以理解为帧显示时刻，如更新前，是上一帧的显示时刻；对于更新后（<code>is-&gt;frame_timer += delay</code>），则为当前帧显示时刻。</p>
<p>上一帧显示时刻加上delay（还应显示多久（含帧本身时长））即为上一帧应结束显示的时刻。具体原理看如下示意图：</p>
<img src="img/ffplay_delay.png" style="zoom:50%;" />
<p>这里给出了3种情况的示意图：</p>
<ul>
<li>time1：系统时刻小于lastvp结束显示的时刻（frame_timer+dealy），即虚线圆圈位置。此时应该继续显示lastvp</li>
<li>time2：系统时刻大于lastvp的结束显示时刻，但小于vp的结束显示时刻（vp的显示时间开始于虚线圆圈，结束于黑色圆圈）。此时既不重复显示lastvp，也不丢弃vp，即应显示vp</li>
<li>time3：系统时刻大于vp结束显示时刻（黑色圆圈位置，也是nextvp预计的开始显示时刻）。此时应该丢弃vp。</li>
</ul>
<h5 id="dealy计算">dealy计算<a hidden class="anchor" aria-hidden="true" href="#dealy计算">#</a></h5>
<p>lastvp的显示时长delay是如何计算的，主要在<code>compute_target_delay</code>中实现，代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">double</span> <span class="nf">compute_target_delay</span><span class="p">(</span><span class="kt">double</span> <span class="n">delay</span><span class="p">,</span> <span class="n">VideoState</span> <span class="o">*</span><span class="n">is</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">sync_threshold</span><span class="p">,</span> <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* update delay to follow master synchronisation source */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//只有同步时钟不是视频时钟时才计算，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">get_master_sync_type</span><span class="p">(</span><span class="n">is</span><span class="p">)</span> <span class="o">!=</span> <span class="n">AV_SYNC_VIDEO_MASTER</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="c1">// 判断同步类型，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="cm">/* if video is slave, we try to correct big delays by
</span></span></span><span class="line"><span class="cl"><span class="cm">           duplicating or deleting a frame */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">        get_clock(&amp;is-&gt;vidclk) ：返回经过从上次设置时钟到现在数据时间到了什么时间位置
</span></span></span><span class="line"><span class="cl"><span class="cm">        get_master_clock(is) ： 返回主时钟到了什么时间位置（音频时钟或者外部时钟）
</span></span></span><span class="line"><span class="cl"><span class="cm">        diff ： 就是当前视频播放的位置与主时钟之前的差值
</span></span></span><span class="line"><span class="cl"><span class="cm">        &lt;0 ： 视频慢了
</span></span></span><span class="line"><span class="cl"><span class="cm">        &gt;0 ：视频快了
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="n">diff</span> <span class="o">=</span> <span class="nf">get_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">vidclk</span><span class="p">)</span> <span class="o">-</span> <span class="nf">get_master_clock</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* skip or repeat frame. We take into account the
</span></span></span><span class="line"><span class="cl"><span class="cm">           delay to compute the threshold. I still don&#39;t know
</span></span></span><span class="line"><span class="cl"><span class="cm">           if it is the best guess */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*AV_SYNC_THRESHOLD_MIN 同步阀值最小范围：0.04 （秒） 1/25帧的时间
</span></span></span><span class="line"><span class="cl"><span class="cm">        AV_SYNC_THRESHOLD_MAX 同步阀值最大范围：0.1 （秒） 1/10帧的时间
</span></span></span><span class="line"><span class="cl"><span class="cm">        delay ： 理论上的两帧之间的时间
</span></span></span><span class="line"><span class="cl"><span class="cm">        返回一个同步阀值在同步阀值范围内，使用delay设置
</span></span></span><span class="line"><span class="cl"><span class="cm">        因为delay上层传来是两帧之间的时间，那只要在阀值范围内，这个时间就是sync_threshold*/</span>
</span></span><span class="line"><span class="cl">        <span class="n">sync_threshold</span> <span class="o">=</span> <span class="nf">FFMAX</span><span class="p">(</span><span class="n">AV_SYNC_THRESHOLD_MIN</span><span class="p">,</span> <span class="nf">FFMIN</span><span class="p">(</span><span class="n">AV_SYNC_THRESHOLD_MAX</span><span class="p">,</span> <span class="n">delay</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">isnan</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">fabs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">max_frame_duration</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//根据阀值判断是快了还是慢了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">sync_threshold</span><span class="p">)</span><span class="c1">//差值已经超出阀值最小，视频慢了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">delay</span> <span class="o">=</span> <span class="nf">FFMAX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">delay</span> <span class="o">+</span> <span class="n">diff</span><span class="p">);</span><span class="cm">/*上一帧需要加快，delay + -diff，这样算出来的delay基本都是0，上一帧还要显示delay时间*/</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;=</span> <span class="n">sync_threshold</span> <span class="o">&amp;&amp;</span> <span class="n">delay</span> <span class="o">&gt;</span> <span class="n">AV_SYNC_FRAMEDUP_THRESHOLD</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span> <span class="o">+</span> <span class="n">diff</span><span class="p">;</span><span class="cm">/*视频快了，上一帧就要减慢，delay+diff，AV_SYNC_FRAMEDUP_THRESHOLD 0.1秒，如果帧持续时间超过这个值，它将不会被成倍来补偿进行同步*/</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;=</span> <span class="n">sync_threshold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">delay</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">delay</span><span class="p">;</span><span class="cm">/*视频快了，delay 相当上一帧显示两次，因为diff == sync_threshold也是快了一帧*/</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_TRACE</span><span class="p">,</span> <span class="s">&#34;video: delay=%0.3f A-V=%f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">delay</span><span class="p">,</span> <span class="o">-</span><span class="n">diff</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">delay</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="sync_threshold理解"><code>sync_threshold</code>理解：<a hidden class="anchor" aria-hidden="true" href="#sync_threshold理解">#</a></h5>
<img src="img/ffplay_sync_threshold.png" style="zoom:50%;" />
<p>从图上可以看出来sync_threshold是建立一块区域，在这块区域内无需调整lastvp的显示时长，直接返回delay即可。也就是在这块区域内认为是准同步的。</p>
<p>如果小于-sync_threshold，那就是视频播放较慢，需要适当丢帧。具体是返回一个最大为0的值。根据前面frame_timer的图，至少应更新画面为vp。</p>
<p>如果大于sync_threshold，那么视频播放太快，需要适当重复显示lastvp。具体是返回2倍的delay，也就是2倍的lastvp显示时长，也就是让lastvp再显示一帧。</p>
<h5 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h5>
<ul>
<li>基本策略是：如果视频播放过快，则重复播放上一帧，以等待音频；如果视频播放过慢，则丢帧追赶音频。</li>
<li>这一策略的实现方式是：引入frame_timer概念，标记帧的显示时刻和应结束显示的时刻，再与系统时刻对比，决定重复还是丢帧。</li>
<li>lastvp的应结束显示的时刻，除了考虑这一帧本身的显示时长，还应考虑了video clock与audio clock的差值。</li>
<li>并不是每时每刻都在同步，而是有一个“准同步”的差值区域。</li>
</ul>
<h3 id="framequeue的分析"><code>FrameQueue</code>的分析<a hidden class="anchor" aria-hidden="true" href="#framequeue的分析">#</a></h3>
<p>ffplay 是通过<code>FrameQueue</code>来保存解码后的数据；</p>
<h4 id="frame结构体"><code>Frame</code>结构体<a hidden class="anchor" aria-hidden="true" href="#frame结构体">#</a></h4>
<p><code>Frame</code>是用来存储解码后的一帧数据，其中包括视频、音频和字幕；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Frame</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span><span class="c1">//音视频解码数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AVSubtitle</span> <span class="n">sub</span><span class="p">;</span><span class="c1">//字幕解码数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">serial</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">pts</span><span class="p">;</span>      <span class="cm">/* presentation timestamp for the frame */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">duration</span><span class="p">;</span> <span class="cm">/* estimated duration of the frame */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">pos</span><span class="p">;</span>     <span class="cm">/* byte position of the frame in the input file */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">format</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">AVRational</span> <span class="n">sar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">uploaded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">flip_v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">Frame</span><span class="p">;</span>
</span></span></code></pre></div><h4 id="framequeue结构体"><code>FrameQueue</code>结构体<a hidden class="anchor" aria-hidden="true" href="#framequeue结构体">#</a></h4>
<p><code>FrameQueue</code>是用来表示整个帧队列；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">FrameQueue</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Frame</span> <span class="n">queue</span><span class="p">[</span><span class="n">FRAME_QUEUE_SIZE</span><span class="p">];</span><span class="c1">//队列元素，用数组模拟队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">rindex</span><span class="p">;</span><span class="c1">//读指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">windex</span><span class="p">;</span><span class="c1">//写指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span><span class="c1">//当前存储的节点个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">max_size</span><span class="p">;</span><span class="c1">//最大允许存储的节点个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">keep_last</span><span class="p">;</span><span class="c1">//是否要保留最后一个读节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">rindex_shown</span><span class="p">;</span><span class="c1">//当前节点是否已经显示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SDL_mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">SDL_cond</span> <span class="o">*</span><span class="n">cond</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PacketQueue</span> <span class="o">*</span><span class="n">pktq</span><span class="p">;</span><span class="c1">//关联的PacketQueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">FrameQueue</span><span class="p">;</span>
</span></span></code></pre></div><p><code>FrameQueue</code>的设计思想是通过数组实现队列（环形缓冲区）；</p>
<p>设计理念：</p>
<ul>
<li>高效率的读写模型</li>
<li>高效的内存模型</li>
<li>环形缓冲区设计，同时可以访问上一读节点</li>
</ul>
<h4 id="framequeue实现函数分析"><code>FrameQueue</code>实现函数分析<a hidden class="anchor" aria-hidden="true" href="#framequeue实现函数分析">#</a></h4>
<h5 id="初始化函数">初始化函数<a hidden class="anchor" aria-hidden="true" href="#初始化函数">#</a></h5>
<p><code>FrameQueue</code>的初始化函数是<code>frame_queue_init</code>;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">frame_queue_init</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">PacketQueue</span> <span class="o">*</span><span class="n">pktq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keep_last</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">FrameQueue</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span> <span class="o">=</span> <span class="nf">SDL_CreateMutex</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_FATAL</span><span class="p">,</span> <span class="s">&#34;SDL_CreateMutex(): %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">SDL_GetError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">cond</span> <span class="o">=</span> <span class="nf">SDL_CreateCond</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">AV_LOG_FATAL</span><span class="p">,</span> <span class="s">&#34;SDL_CreateCond(): %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">SDL_GetError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">-&gt;</span><span class="n">pktq</span> <span class="o">=</span> <span class="n">pktq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">-&gt;</span><span class="n">max_size</span> <span class="o">=</span> <span class="nf">FFMIN</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="n">FRAME_QUEUE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">-&gt;</span><span class="n">keep_last</span> <span class="o">=</span> <span class="o">!!</span><span class="n">keep_last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">frame</span> <span class="o">=</span> <span class="nf">av_frame_alloc</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中主要是内存初始化和锁初始化，关键参数是<code>max_size</code>和<code>keep_last</code>;<code>max_size</code>是最大允许存储的节点个数,最大不能超过</p>
<p><code>FRAME_QUEUE_SIZE</code>，<code>FRAME_QUEUE_SIZE</code>定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define VIDEO_PICTURE_QUEUE_SIZE 3 </span><span class="c1">//视频显示缓存最大帧数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SUBPICTURE_QUEUE_SIZE 16   </span><span class="c1">//字幕缓存最大帧数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SAMPLE_QUEUE_SIZE 9        </span><span class="c1">//默认最大帧数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define FRAME_QUEUE_SIZE FFMAX(SAMPLE_QUEUE_SIZE, FFMAX(VIDEO_PICTURE_QUEUE_SIZE, SUBPICTURE_QUEUE_SIZE))
</span></span></span></code></pre></div><p>如此看来最大不能超过16；</p>
<p><code>keep_last</code>是一个bool值，表示是否在环形缓冲区的读写过程中保留最后一个读节点不被覆写。<code>f-&gt;keep_last = !!keep_last;</code>里的双感叹号是C中的一种技巧，旨在让int参数规整为0/1的“bool值”。</p>
<p>数组queue中的每个元素的frame(AVFrame*)的字段调用<code>av_frame_alloc</code>分配内存。</p>
<h5 id="反初始化函数">反初始化函数<a hidden class="anchor" aria-hidden="true" href="#反初始化函数">#</a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">frame_queue_destory</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Frame</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">frame_queue_unref_item</span><span class="p">(</span><span class="n">vp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">av_frame_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_DestroyMutex</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_DestroyCond</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>queue元素的释放分两步；</p>
<ol>
<li><code>frame_queue_unref_item</code>,释放的内存都是<strong>关联</strong>的内存，而非结构体自身内存;</li>
<li><code>av_frame_free</code>,<code>av_frame_free</code>与初始化中的<code>av_frame_alloc</code>对应，用于释放AVFrame.</li>
</ol>
<p><code>frame_queue_unref_item</code>定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">frame_queue_unref_item</span><span class="p">(</span><span class="n">Frame</span> <span class="o">*</span><span class="n">vp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">av_frame_unref</span><span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">);</span><span class="c1">//frame计数减1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">avsubtitle_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">sub</span><span class="p">);</span><span class="c1">//sub关联的内存释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>AVFrame内部有许多的AVBufferRef类型字段，而AVBufferRef只是AVBuffer的引用，AVBuffer通过引用计数自动管理内存（简易垃圾回收机制）。因此AVFrame在不需要的时候，需要通过<code>av_frame_unref</code>减少引用计数。(这个还在学习阶段)</p>
<h5 id="framequeue的写操作">FrameQueue的‘写’操作<a hidden class="anchor" aria-hidden="true" href="#framequeue的写操作">#</a></h5>
<p>FrameQueue的‘写’操作分为两个步骤；</p>
<ol>
<li><code>frame_queue_peek_writable</code>获取一个可写节点；</li>
<li><code>frame_queue_push</code>告知FrameQueue“存入”该节点。</li>
</ol>
<p>FrameQueue始终是一个线程写，另一个线程读。读写没有其他线程产生竞争，唯一需要的是读与写线程间的同步。FrameQueue的整个优化和设计思路正是基于这一点的。这个设计思想类似于Linux内核中的kfifo。</p>
<p><code>frame_queue_peek_writable</code>定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">Frame</span> <span class="o">*</span><span class="nf">frame_queue_peek_writable</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* wait until we have space to put a new frame */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_LockMutex</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">max_size</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">           <span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">pktq</span><span class="o">-&gt;</span><span class="n">abort_request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">SDL_CondWait</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_UnlockMutex</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">pktq</span><span class="o">-&gt;</span><span class="n">abort_request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">windex</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>函数分3步：</p>
<ol>
<li>加锁情况下，等待直到队列有空余空间可写（<code>f-&gt;size &lt; f-&gt;max_size</code>）</li>
<li>如果有退出请求（<code>f-&gt;pktq-&gt;abort_request</code>），则返回NULL</li>
<li>返回<code>windex</code>位置的元素（<code>windex</code>指向当前应写位置）</li>
</ol>
<p>因为queue数组被当做一个环形缓冲区使用，那么的确存在underrun和overrun的情况，即读过快，或写过快的情况，这时如果不加控制，就会呈现缓冲区覆盖。</p>
<p>FrameQueue的精明之处在于，先通过size判断当前缓冲区内空间是否够写，或者够读，比如这里先通过一个循环的条件等待，判断<code>f-&gt;size &gt;= f-&gt;max_size</code>，如果<code>f-&gt;size &gt;= f-&gt;max_size</code>，那么说明队列中的节点已经写满，也就是已经overrun了，此时如果再写，肯定会覆写未读数据，那么就需要继续等待。当无需等待时，windex指向的内存一定是已经读过的（除非代码异常了）。</p>
<p>调用<code>frame_queue_peek_writable</code>取到Frame指针后，就可以对Frame内的字段自由改写，因为只有一个写进程，且无需担心读进程覆写（如上分析，读进程要读一个节点时，也会先判断underrun的情况）。</p>
<p>实现步骤：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Frame</span><span class="o">*</span> <span class="n">vp</span> <span class="o">=</span> <span class="nf">frame_queue_peek_writable</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//将要存储的数据写入frame字段，比如：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">av_frame_move_ref</span><span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">,</span> <span class="n">src_frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//存入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">frame_queue_push</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</span></span></code></pre></div><p><code>frame_queue_push</code>代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">frame_queue_push</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">windex</span> <span class="o">==</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">-&gt;</span><span class="n">windex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_LockMutex</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_CondSignal</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_UnlockMutex</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>执行两个步骤：</p>
<ol>
<li>windex加1，如果超过max_size，则回环为0</li>
<li>加锁情况下大小加1.</li>
</ol>
<p>frame_queue的写过程总结示意图如下：</p>
<img src="img/ffplay_framequeue.png" style="zoom:50%;" />
<h5 id="framequeue的读操作">FrameQueue的&rsquo;读&rsquo;操作<a hidden class="anchor" aria-hidden="true" href="#framequeue的读操作">#</a></h5>
<p>FrameQueue的‘读’操作分为两个步骤；</p>
<ol>
<li><code>frame_queue_peek_readable</code>获取一个可读节点</li>
<li><code>frame_queue_next</code>告知FrameQueue“取出”该节点。</li>
</ol>
<p><code>frame_queue_peek_readable</code>代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">Frame</span> <span class="o">*</span><span class="nf">frame_queue_peek_readable</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* wait until we have a readable a new frame */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_LockMutex</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//加锁情况下，判断是否有可读节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex_shown</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">           <span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">pktq</span><span class="o">-&gt;</span><span class="n">abort_request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">SDL_CondWait</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_UnlockMutex</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果有退出请求，则返回NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">pktq</span><span class="o">-&gt;</span><span class="n">abort_request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//读取当前可读节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex_shown</span><span class="p">)</span> <span class="o">%</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>frame_queue_next</code>代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">frame_queue_next</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果支持keep_last，且rindex_shown为0，则rindex_shown赋1，返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">keep_last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex_shown</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex_shown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//否则，移动rindex指针，并减小size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">frame_queue_unref_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex</span> <span class="o">==</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_LockMutex</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_CondSignal</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_UnlockMutex</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>frame_queue_next</code>用于在读完一个节点后调用，用于标记一个节点已经被读过。</p>
<p>读过程可以描述为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Frame</span><span class="o">*</span> <span class="n">vp</span> <span class="o">=</span> <span class="nf">frame_queue_peek_readable</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//读取vp的数据，比如
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;pict_type=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">pict_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">frame_queue_next</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span></span></code></pre></div><p>标记一个节点为已读，执行两个步骤：</p>
<ol>
<li>rindex加1，如果超过max_size，则回环为0</li>
<li>加锁情况下大小减1.</li>
</ol>
<p><em><strong>对于以及读过的节点，需要调用<code>frame_queue_unref_item</code>释放关联内存。</strong></em></p>
<p>执行rindex操作前，需要先判断<code>rindex_shown</code>的值，如果为0，则赋1。如下图：</p>
<img src="img/ffplay_framequeue_read.png" style="zoom:50%;" />
<p>这里模拟了从初始化开始的2次“读”。</p>
<p>还没开始读，rindex和rindex_shown均为0。这时要peek的读节点是节点0(图中黑色块）。</p>
<p>第一次读，调用next，满足条件<code>f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown</code>，所以rindex仍然是0，而rindex_shown为1.此时节点0（灰色块）是已读节点，也是要keep的last节点，将要读的节点是节点1（黑色块）。（恰好是rindex+rindex_shown）</p>
<p>第二次读，peek了黑色块后，调用next，不满足条件<code>f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown</code>，所以rindex为1，而rindex_shown为2.此时节点1（灰色块）是last节点，节点2（黑色块）是将要读的节点。（也恰好是rindex+rindex_shown）</p>
<p>继续往后分析，会一直重复第二次读的情况，始终是rindex指向了last，而rindex_shown一直为1，rindex+rindex_shown刚好是将要读的节点。</p>
<p>FrameQueue的读过程也分析完了。</p>
<h5 id="辅助函数">辅助函数<a hidden class="anchor" aria-hidden="true" href="#辅助函数">#</a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//（上文中的用词是“将要读的节点”，也就是黑色块），与frame_queue_peek_readable等效，但没有检查是否有可读节点
</span></span></span><span class="line"><span class="cl"><span class="c1">//读当前节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">Frame</span> <span class="o">*</span><span class="nf">frame_queue_peek</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex_shown</span><span class="p">)</span> <span class="o">%</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//读下一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">Frame</span> <span class="o">*</span><span class="nf">frame_queue_peek_next</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex_shown</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//读上一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">Frame</span> <span class="o">*</span><span class="nf">frame_queue_peek_last</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* return the number of undisplayed frames in the queue */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">frame_queue_nb_remaining</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex_shown</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* return last shown position */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">frame_queue_last_pos</span><span class="p">(</span><span class="n">FrameQueue</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Frame</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rindex_shown</span> <span class="o">&amp;&amp;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">==</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">pktq</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>看下节点位置：</p>
<img src="img/ffplay_framequeue_index.png" style="zoom:50%;" />
<h2 id="参考链接">参考链接：<a hidden class="anchor" aria-hidden="true" href="#参考链接">#</a></h2>
<p><a href="https://www.zhihu.com/column/avtec">https://www.zhihu.com/column/avtec</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1373966">https://cloud.tencent.com/developer/article/1373966</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://rong05.github.io/learn/android/mediacodec_source_learn/">
    <span class="title">« Prev</span>
    <br>
    <span></span>
  </a>
  <a class="next" href="https://rong05.github.io/learn/av-learn/rtp_protocol/">
    <span class="title">Next »</span>
    <br>
    <span></span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on x"
        href="https://x.com/intent/tweet/?text=&amp;url=https%3a%2f%2frong05.github.io%2flearn%2fav-learn%2fffplay_learn%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z"/>
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frong05.github.io%2flearn%2fav-learn%2fffplay_learn%2f&amp;title=&amp;summary=&amp;source=https%3a%2f%2frong05.github.io%2flearn%2fav-learn%2fffplay_learn%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2frong05.github.io%2flearn%2fav-learn%2fffplay_learn%2f&title=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frong05.github.io%2flearn%2fav-learn%2fffplay_learn%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on whatsapp"
        href="https://api.whatsapp.com/send?text=%20-%20https%3a%2f%2frong05.github.io%2flearn%2fav-learn%2fffplay_learn%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on telegram"
        href="https://telegram.me/share/url?text=&amp;url=https%3a%2f%2frong05.github.io%2flearn%2fav-learn%2fffplay_learn%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on ycombinator"
        href="https://news.ycombinator.com/submitlink?t=&u=https%3a%2f%2frong05.github.io%2flearn%2fav-learn%2fffplay_learn%2f">
        <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
            xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
            <path
                d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://rong05.github.io/">LEAN</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
